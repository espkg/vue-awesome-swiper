(function (e, t) { typeof exports === 'object' && typeof module === 'object' ? module.exports = t() : typeof define === 'function' && define.amd ? define([], t) : typeof exports === 'object' ? exports['vue-awesome-swiper'] = t() : e['vue-awesome-swiper'] = t() })(typeof self !== 'undefined' ? self : this, function () { return (function (e) { const t = {}; function a (s) { if (t[s]) return t[s].exports; const i = t[s] = { i: s, l: !1, exports: {} }; return e[s].call(i.exports, i, i.exports, a), i.l = !0, i.exports } return a.m = e, a.c = t, a.d = function (e, t, s) { a.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: s }) }, a.r = function (e) { typeof Symbol !== 'undefined' && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' }), Object.defineProperty(e, '__esModule', { value: !0 }) }, a.t = function (e, t) { if (1 & t && (e = a(e)), 8 & t) return e; if (4 & t && typeof e === 'object' && e && e.__esModule) return e; const s = Object.create(null); if (a.r(s), Object.defineProperty(s, 'default', { enumerable: !0, value: e }), 2 & t && typeof e !== 'string') for (const i in e)a.d(s, i, function (t) { return e[t] }.bind(null, i)); return s }, a.n = function (e) { const t = e && e.__esModule ? function () { return e.default } : function () { return e }; return a.d(t, 'a', t), t }, a.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, a.p = '', a(a.s = 'fb15') }({ '02a3': function (e, t, a) { (function (t, a) { e.exports = a() })(0, function () { 'use strict'; const e = typeof document === 'undefined' ? { body: {}, addEventListener: function () {}, removeEventListener: function () {}, activeElement: { blur: function () {}, nodeName: '' }, querySelector: function () { return null }, querySelectorAll: function () { return [] }, getElementById: function () { return null }, createEvent: function () { return { initEvent: function () {} } }, createElement: function () { return { children: [], childNodes: [], style: {}, setAttribute: function () {}, getElementsByTagName: function () { return [] } } }, location: { hash: '' } } : document; const t = typeof window === 'undefined' ? { document: e, navigator: { userAgent: '' }, location: {}, history: {}, CustomEvent: function () { return this }, addEventListener: function () {}, removeEventListener: function () {}, getComputedStyle: function () { return { getPropertyValue: function () { return '' } } }, Image: function () {}, Date: function () {}, screen: {}, setTimeout: function () {}, clearTimeout: function () {} } : window; const a = function (e) { for (var t = this, a = 0; a < e.length; a += 1)t[a] = e[a]; return t.length = e.length, this }; function s (s, i) { const n = []; let r = 0; if (s && !i && s instanceof a) return s; if (s) if (typeof s === 'string') { let o; let l; const d = s.trim(); if (d.indexOf('<') >= 0 && d.indexOf('>') >= 0) { let c = 'div'; for (d.indexOf('<li') === 0 && (c = 'ul'), d.indexOf('<tr') === 0 && (c = 'tbody'), d.indexOf('<td') !== 0 && d.indexOf('<th') !== 0 || (c = 'tr'), d.indexOf('<tbody') === 0 && (c = 'table'), d.indexOf('<option') === 0 && (c = 'select'), l = e.createElement(c), l.innerHTML = d, r = 0; r < l.childNodes.length; r += 1)n.push(l.childNodes[r]) } else for (o = i || s[0] !== '#' || s.match(/[ .<>:~]/) ? (i || e).querySelectorAll(s.trim()) : [e.getElementById(s.trim().split('#')[1])], r = 0; r < o.length; r += 1)o[r] && n.push(o[r]) } else if (s.nodeType || s === t || s === e)n.push(s); else if (s.length > 0 && s[0].nodeType) for (r = 0; r < s.length; r += 1)n.push(s[r]); return new a(n) } function i (e) { for (var t = [], a = 0; a < e.length; a += 1)t.indexOf(e[a]) === -1 && t.push(e[a]); return t } function n (e) { if (typeof e === 'undefined') return this; for (let t = e.split(' '), a = 0; a < t.length; a += 1) for (let s = 0; s < this.length; s += 1) typeof this[s] !== 'undefined' && typeof this[s].classList !== 'undefined' && this[s].classList.add(t[a]); return this } function r (e) { for (let t = e.split(' '), a = 0; a < t.length; a += 1) for (let s = 0; s < this.length; s += 1) typeof this[s] !== 'undefined' && typeof this[s].classList !== 'undefined' && this[s].classList.remove(t[a]); return this } function o (e) { return !!this[0] && this[0].classList.contains(e) } function l (e) { for (let t = e.split(' '), a = 0; a < t.length; a += 1) for (let s = 0; s < this.length; s += 1) typeof this[s] !== 'undefined' && typeof this[s].classList !== 'undefined' && this[s].classList.toggle(t[a]); return this } function d (e, t) { const a = arguments; if (arguments.length === 1 && typeof e === 'string') return this[0] ? this[0].getAttribute(e) : void 0; for (let s = 0; s < this.length; s += 1) if (a.length === 2) this[s].setAttribute(e, t); else for (const i in e) this[s][i] = e[i], this[s].setAttribute(i, e[i]); return this } function c (e) { for (let t = 0; t < this.length; t += 1) this[t].removeAttribute(e); return this } function p (e, t) { let a; if (typeof t !== 'undefined') { for (let s = 0; s < this.length; s += 1)a = this[s], a.dom7ElementDataStorage || (a.dom7ElementDataStorage = {}), a.dom7ElementDataStorage[e] = t; return this } if (a = this[0], a) { if (a.dom7ElementDataStorage && e in a.dom7ElementDataStorage) return a.dom7ElementDataStorage[e]; const i = a.getAttribute('data-' + e); return i || void 0 } } function u (e) { for (let t = 0; t < this.length; t += 1) { const a = this[t].style; a.webkitTransform = e, a.transform = e } return this } function h (e) { typeof e !== 'string' && (e += 'ms'); for (let t = 0; t < this.length; t += 1) { const a = this[t].style; a.webkitTransitionDuration = e, a.transitionDuration = e } return this } function f () { let e; const t = []; let a = arguments.length; while (a--)t[a] = arguments[a]; let i = t[0]; let n = t[1]; let r = t[2]; let o = t[3]; function l (e) { const t = e.target; if (t) { const a = e.target.dom7EventData || []; if (a.indexOf(e) < 0 && a.unshift(e), s(t).is(n))r.apply(t, a); else for (let i = s(t).parents(), o = 0; o < i.length; o += 1)s(i[o]).is(n) && r.apply(i[o], a) } } function d (e) { const t = e && e.target && e.target.dom7EventData || []; t.indexOf(e) < 0 && t.unshift(e), r.apply(this, t) } typeof t[1] === 'function' && (e = t, i = e[0], r = e[1], o = e[2], n = void 0), o || (o = !1); for (var c, p = i.split(' '), u = 0; u < this.length; u += 1) { const h = this[u]; if (n) for (c = 0; c < p.length; c += 1) { const f = p[c]; h.dom7LiveListeners || (h.dom7LiveListeners = {}), h.dom7LiveListeners[f] || (h.dom7LiveListeners[f] = []), h.dom7LiveListeners[f].push({ listener: r, proxyListener: l }), h.addEventListener(f, l, o) } else for (c = 0; c < p.length; c += 1) { const m = p[c]; h.dom7Listeners || (h.dom7Listeners = {}), h.dom7Listeners[m] || (h.dom7Listeners[m] = []), h.dom7Listeners[m].push({ listener: r, proxyListener: d }), h.addEventListener(m, d, o) } } return this } function m () { let e; const t = []; let a = arguments.length; while (a--)t[a] = arguments[a]; let s = t[0]; let i = t[1]; let n = t[2]; let r = t[3]; typeof t[1] === 'function' && (e = t, s = e[0], n = e[1], r = e[2], i = void 0), r || (r = !1); for (let o = s.split(' '), l = 0; l < o.length; l += 1) for (let d = o[l], c = 0; c < this.length; c += 1) { const p = this[c]; let u = void 0; if (!i && p.dom7Listeners ? u = p.dom7Listeners[d] : i && p.dom7LiveListeners && (u = p.dom7LiveListeners[d]), u && u.length) for (let h = u.length - 1; h >= 0; h -= 1) { const f = u[h]; n && f.listener === n ? (p.removeEventListener(d, f.proxyListener, r), u.splice(h, 1)) : n && f.listener && f.listener.dom7proxy && f.listener.dom7proxy === n ? (p.removeEventListener(d, f.proxyListener, r), u.splice(h, 1)) : n || (p.removeEventListener(d, f.proxyListener, r), u.splice(h, 1)) } } return this } function v () { const a = []; let s = arguments.length; while (s--)a[s] = arguments[s]; for (let i = a[0].split(' '), n = a[1], r = 0; r < i.length; r += 1) for (let o = i[r], l = 0; l < this.length; l += 1) { const d = this[l]; let c = void 0; try { c = new t.CustomEvent(o, { detail: n, bubbles: !0, cancelable: !0 }) } catch (p) { c = e.createEvent('Event'), c.initEvent(o, !0, !0), c.detail = n }d.dom7EventData = a.filter(function (e, t) { return t > 0 }), d.dispatchEvent(c), d.dom7EventData = [], delete d.dom7EventData } return this } function g (e) { let t; const a = ['webkitTransitionEnd', 'transitionend']; const s = this; function i (n) { if (n.target === this) for (e.call(this, n), t = 0; t < a.length; t += 1)s.off(a[t], i) } if (e) for (t = 0; t < a.length; t += 1)s.on(a[t], i); return this } function b (e) { if (this.length > 0) { if (e) { const t = this.styles(); return this[0].offsetWidth + parseFloat(t.getPropertyValue('margin-right')) + parseFloat(t.getPropertyValue('margin-left')) } return this[0].offsetWidth } return null } function w (e) { if (this.length > 0) { if (e) { const t = this.styles(); return this[0].offsetHeight + parseFloat(t.getPropertyValue('margin-top')) + parseFloat(t.getPropertyValue('margin-bottom')) } return this[0].offsetHeight } return null } function y () { if (this.length > 0) { const a = this[0]; const s = a.getBoundingClientRect(); const i = e.body; const n = a.clientTop || i.clientTop || 0; const r = a.clientLeft || i.clientLeft || 0; const o = a === t ? t.scrollY : a.scrollTop; const l = a === t ? t.scrollX : a.scrollLeft; return { top: s.top + o - n, left: s.left + l - r } } return null } function x () { return this[0] ? t.getComputedStyle(this[0], null) : {} } function E (e, a) { let s; if (arguments.length === 1) { if (typeof e !== 'string') { for (s = 0; s < this.length; s += 1) for (const i in e) this[s].style[i] = e[i]; return this } if (this[0]) return t.getComputedStyle(this[0], null).getPropertyValue(e) } if (arguments.length === 2 && typeof e === 'string') { for (s = 0; s < this.length; s += 1) this[s].style[e] = a; return this } return this } function T (e) { if (!e) return this; for (let t = 0; t < this.length; t += 1) if (!1 === e.call(this[t], t, this[t])) return this; return this } function S (e) { for (var t = [], s = this, i = 0; i < s.length; i += 1)e.call(s[i], i, s[i]) && t.push(s[i]); return new a(t) } function C (e) { if (typeof e === 'undefined') return this[0] ? this[0].innerHTML : void 0; for (let t = 0; t < this.length; t += 1) this[t].innerHTML = e; return this } function M (e) { if (typeof e === 'undefined') return this[0] ? this[0].textContent.trim() : null; for (let t = 0; t < this.length; t += 1) this[t].textContent = e; return this } function $ (i) { let n; let r; const o = this[0]; if (!o || typeof i === 'undefined') return !1; if (typeof i === 'string') { if (o.matches) return o.matches(i); if (o.webkitMatchesSelector) return o.webkitMatchesSelector(i); if (o.msMatchesSelector) return o.msMatchesSelector(i); for (n = s(i), r = 0; r < n.length; r += 1) if (n[r] === o) return !0; return !1 } if (i === e) return o === e; if (i === t) return o === t; if (i.nodeType || i instanceof a) { for (n = i.nodeType ? [i] : i, r = 0; r < n.length; r += 1) if (n[r] === o) return !0; return !1 } return !1 } function P () { let e; let t = this[0]; if (t) { e = 0; while ((t = t.previousSibling) !== null)t.nodeType === 1 && (e += 1); return e } } function k (e) { if (typeof e === 'undefined') return this; let t; const s = this.length; return e > s - 1 ? new a([]) : e < 0 ? (t = s + e, new a(t < 0 ? [] : [this[t]])) : new a([this[e]]) } function z () { let t; const s = []; let i = arguments.length; while (i--)s[i] = arguments[i]; for (let n = 0; n < s.length; n += 1) { t = s[n]; for (let r = 0; r < this.length; r += 1) if (typeof t === 'string') { const o = e.createElement('div'); o.innerHTML = t; while (o.firstChild) this[r].appendChild(o.firstChild) } else if (t instanceof a) for (let l = 0; l < t.length; l += 1) this[r].appendChild(t[l]); else this[r].appendChild(t) } return this } function L (t) { let s, i; for (s = 0; s < this.length; s += 1) if (typeof t === 'string') { const n = e.createElement('div'); for (n.innerHTML = t, i = n.childNodes.length - 1; i >= 0; i -= 1) this[s].insertBefore(n.childNodes[i], this[s].childNodes[0]) } else if (t instanceof a) for (i = 0; i < t.length; i += 1) this[s].insertBefore(t[i], this[s].childNodes[0]); else this[s].insertBefore(t, this[s].childNodes[0]); return this } function I (e) { return this.length > 0 ? e ? this[0].nextElementSibling && s(this[0].nextElementSibling).is(e) ? new a([this[0].nextElementSibling]) : new a([]) : this[0].nextElementSibling ? new a([this[0].nextElementSibling]) : new a([]) : new a([]) } function O (e) { const t = []; let i = this[0]; if (!i) return new a([]); while (i.nextElementSibling) { const n = i.nextElementSibling; e ? s(n).is(e) && t.push(n) : t.push(n), i = n } return new a(t) } function D (e) { if (this.length > 0) { const t = this[0]; return e ? t.previousElementSibling && s(t.previousElementSibling).is(e) ? new a([t.previousElementSibling]) : new a([]) : t.previousElementSibling ? new a([t.previousElementSibling]) : new a([]) } return new a([]) } function A (e) { const t = []; let i = this[0]; if (!i) return new a([]); while (i.previousElementSibling) { const n = i.previousElementSibling; e ? s(n).is(e) && t.push(n) : t.push(n), i = n } return new a(t) } function G (e) { for (var t = [], a = 0; a < this.length; a += 1) this[a].parentNode !== null && (e ? s(this[a].parentNode).is(e) && t.push(this[a].parentNode) : t.push(this[a].parentNode)); return s(i(t)) } function B (e) { for (var t = [], a = 0; a < this.length; a += 1) { let n = this[a].parentNode; while (n)e ? s(n).is(e) && t.push(n) : t.push(n), n = n.parentNode } return s(i(t)) } function N (e) { let t = this; return typeof e === 'undefined' ? new a([]) : (t.is(e) || (t = t.parents(e).eq(0)), t) } function H (e) { for (var t = [], s = 0; s < this.length; s += 1) for (let i = this[s].querySelectorAll(e), n = 0; n < i.length; n += 1)t.push(i[n]); return new a(t) } function X (e) { for (var t = [], n = 0; n < this.length; n += 1) for (let r = this[n].childNodes, o = 0; o < r.length; o += 1)e ? r[o].nodeType === 1 && s(r[o]).is(e) && t.push(r[o]) : r[o].nodeType === 1 && t.push(r[o]); return new a(i(t)) } function V () { for (let e = 0; e < this.length; e += 1) this[e].parentNode && this[e].parentNode.removeChild(this[e]); return this } function Y () { const e = []; let t = arguments.length; while (t--)e[t] = arguments[t]; let a; let i; const n = this; for (a = 0; a < e.length; a += 1) { const r = s(e[a]); for (i = 0; i < r.length; i += 1)n[n.length] = r[i], n.length += 1 } return n }s.fn = a.prototype, s.Class = a, s.Dom7 = a; const R = { addClass: n, removeClass: r, hasClass: o, toggleClass: l, attr: d, removeAttr: c, data: p, transform: u, transition: h, on: f, off: m, trigger: v, transitionEnd: g, outerWidth: b, outerHeight: w, offset: y, css: E, each: T, html: C, text: M, is: $, index: P, eq: k, append: z, prepend: L, next: I, nextAll: O, prev: D, prevAll: A, parent: G, parents: B, closest: N, find: H, children: X, filter: S, remove: V, add: Y, styles: x }; Object.keys(R).forEach(function (e) { s.fn[e] = s.fn[e] || R[e] }); var F = { deleteProps: function (e) { const t = e; Object.keys(t).forEach(function (e) { try { t[e] = null } catch (a) {} try { delete t[e] } catch (a) {} }) }, nextTick: function (e, t) { return void 0 === t && (t = 0), setTimeout(e, t) }, now: function () { return Date.now() }, getTranslate: function (e, a) { let s, i, n; void 0 === a && (a = 'x'); const r = t.getComputedStyle(e, null); return t.WebKitCSSMatrix ? (i = r.transform || r.webkitTransform, i.split(',').length > 6 && (i = i.split(', ').map(function (e) { return e.replace(',', '.') }).join(', ')), n = new t.WebKitCSSMatrix(i === 'none' ? '' : i)) : (n = r.MozTransform || r.OTransform || r.MsTransform || r.msTransform || r.transform || r.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,'), s = n.toString().split(',')), a === 'x' && (i = t.WebKitCSSMatrix ? n.m41 : s.length === 16 ? parseFloat(s[12]) : parseFloat(s[4])), a === 'y' && (i = t.WebKitCSSMatrix ? n.m42 : s.length === 16 ? parseFloat(s[13]) : parseFloat(s[5])), i || 0 }, parseUrlQuery: function (e) { let a; let s; let i; let n; const r = {}; let o = e || t.location.href; if (typeof o === 'string' && o.length) for (o = o.indexOf('?') > -1 ? o.replace(/\S*\?/, '') : '', s = o.split('&').filter(function (e) { return e !== '' }), n = s.length, a = 0; a < n; a += 1)i = s[a].replace(/#\S+/g, '').split('='), r[decodeURIComponent(i[0])] = typeof i[1] === 'undefined' ? void 0 : decodeURIComponent(i[1]) || ''; return r }, isObject: function (e) { return typeof e === 'object' && e !== null && e.constructor && e.constructor === Object }, extend: function () { const e = []; let t = arguments.length; while (t--)e[t] = arguments[t]; for (var a = Object(e[0]), s = 1; s < e.length; s += 1) { const i = e[s]; if (void 0 !== i && i !== null) for (let n = Object.keys(Object(i)), r = 0, o = n.length; r < o; r += 1) { const l = n[r]; const d = Object.getOwnPropertyDescriptor(i, l); void 0 !== d && d.enumerable && (F.isObject(a[l]) && F.isObject(i[l]) ? F.extend(a[l], i[l]) : !F.isObject(a[l]) && F.isObject(i[l]) ? (a[l] = {}, F.extend(a[l], i[l])) : a[l] = i[l]) } } return a } }; const W = (function () { return { touch: t.Modernizr && !0 === t.Modernizr.touch || (function () { return !!(t.navigator.maxTouchPoints > 0 || 'ontouchstart' in t || t.DocumentTouch && e instanceof t.DocumentTouch) }()), pointerEvents: !!t.PointerEvent && 'maxTouchPoints' in t.navigator && t.navigator.maxTouchPoints > 0, observer: (function () { return 'MutationObserver' in t || 'WebkitMutationObserver' in t }()), passiveListener: (function () { let e = !1; try { const a = Object.defineProperty({}, 'passive', { get: function () { e = !0 } }); t.addEventListener('testPassiveListener', null, a) } catch (s) {} return e }()), gestures: (function () { return 'ongesturestart' in t }()) } }()); const j = function (e) { void 0 === e && (e = {}); const t = this; t.params = e, t.eventsListeners = {}, t.params && t.params.on && Object.keys(t.params.on).forEach(function (e) { t.on(e, t.params.on[e]) }) }; const q = { components: { configurable: !0 } }; function _ () { let e; let t; const a = this; const s = a.$el; e = typeof a.params.width !== 'undefined' ? a.params.width : s[0].clientWidth, t = typeof a.params.height !== 'undefined' ? a.params.height : s[0].clientHeight, e === 0 && a.isHorizontal() || t === 0 && a.isVertical() || (e = e - parseInt(s.css('padding-left'), 10) - parseInt(s.css('padding-right'), 10), t = t - parseInt(s.css('padding-top'), 10) - parseInt(s.css('padding-bottom'), 10), F.extend(a, { width: e, height: t, size: a.isHorizontal() ? e : t })) } function U () { const e = this; const a = e.params; const s = e.$wrapperEl; const i = e.size; const n = e.rtlTranslate; const r = e.wrongRTL; const o = e.virtual && a.virtual.enabled; const l = o ? e.virtual.slides.length : e.slides.length; const d = s.children('.' + e.params.slideClass); const c = o ? e.virtual.slides.length : d.length; let p = []; const u = []; const h = []; function f (e) { return !a.cssMode || e !== d.length - 1 } let m = a.slidesOffsetBefore; typeof m === 'function' && (m = a.slidesOffsetBefore.call(e)); let v = a.slidesOffsetAfter; typeof v === 'function' && (v = a.slidesOffsetAfter.call(e)); const g = e.snapGrid.length; const b = e.snapGrid.length; let w = a.spaceBetween; let y = -m; let x = 0; let E = 0; if (typeof i !== 'undefined') { let T, S; typeof w === 'string' && w.indexOf('%') >= 0 && (w = parseFloat(w.replace('%', '')) / 100 * i), e.virtualSize = -w, n ? d.css({ marginLeft: '', marginTop: '' }) : d.css({ marginRight: '', marginBottom: '' }), a.slidesPerColumn > 1 && (T = Math.floor(c / a.slidesPerColumn) === c / e.params.slidesPerColumn ? c : Math.ceil(c / a.slidesPerColumn) * a.slidesPerColumn, a.slidesPerView !== 'auto' && a.slidesPerColumnFill === 'row' && (T = Math.max(T, a.slidesPerView * a.slidesPerColumn))); for (var C, M = a.slidesPerColumn, $ = T / M, P = Math.floor(c / a.slidesPerColumn), k = 0; k < c; k += 1) { S = 0; const z = d.eq(k); if (a.slidesPerColumn > 1) { let L = void 0; let I = void 0; let O = void 0; if (a.slidesPerColumnFill === 'row' && a.slidesPerGroup > 1) { const D = Math.floor(k / (a.slidesPerGroup * a.slidesPerColumn)); const A = k - a.slidesPerColumn * a.slidesPerGroup * D; const G = D === 0 ? a.slidesPerGroup : Math.min(Math.ceil((c - D * M * a.slidesPerGroup) / M), a.slidesPerGroup); O = Math.floor(A / G), I = A - O * G + D * a.slidesPerGroup, L = I + O * T / M, z.css({ '-webkit-box-ordinal-group': L, '-moz-box-ordinal-group': L, '-ms-flex-order': L, '-webkit-order': L, order: L }) } else a.slidesPerColumnFill === 'column' ? (I = Math.floor(k / M), O = k - I * M, (I > P || I === P && O === M - 1) && (O += 1, O >= M && (O = 0, I += 1))) : (O = Math.floor(k / $), I = k - O * $); z.css('margin-' + (e.isHorizontal() ? 'top' : 'left'), O !== 0 && a.spaceBetween && a.spaceBetween + 'px') } if (z.css('display') !== 'none') { if (a.slidesPerView === 'auto') { const B = t.getComputedStyle(z[0], null); const N = z[0].style.transform; const H = z[0].style.webkitTransform; if (N && (z[0].style.transform = 'none'), H && (z[0].style.webkitTransform = 'none'), a.roundLengths)S = e.isHorizontal() ? z.outerWidth(!0) : z.outerHeight(!0); else if (e.isHorizontal()) { const X = parseFloat(B.getPropertyValue('width')); const V = parseFloat(B.getPropertyValue('padding-left')); const Y = parseFloat(B.getPropertyValue('padding-right')); const R = parseFloat(B.getPropertyValue('margin-left')); const W = parseFloat(B.getPropertyValue('margin-right')); const j = B.getPropertyValue('box-sizing'); S = j && j === 'border-box' ? X + R + W : X + V + Y + R + W } else { const q = parseFloat(B.getPropertyValue('height')); const _ = parseFloat(B.getPropertyValue('padding-top')); const U = parseFloat(B.getPropertyValue('padding-bottom')); const K = parseFloat(B.getPropertyValue('margin-top')); const Z = parseFloat(B.getPropertyValue('margin-bottom')); const Q = B.getPropertyValue('box-sizing'); S = Q && Q === 'border-box' ? q + K + Z : q + _ + U + K + Z }N && (z[0].style.transform = N), H && (z[0].style.webkitTransform = H), a.roundLengths && (S = Math.floor(S)) } else S = (i - (a.slidesPerView - 1) * w) / a.slidesPerView, a.roundLengths && (S = Math.floor(S)), d[k] && (e.isHorizontal() ? d[k].style.width = S + 'px' : d[k].style.height = S + 'px'); d[k] && (d[k].swiperSlideSize = S), h.push(S), a.centeredSlides ? (y = y + S / 2 + x / 2 + w, x === 0 && k !== 0 && (y = y - i / 2 - w), k === 0 && (y = y - i / 2 - w), Math.abs(y) < 0.001 && (y = 0), a.roundLengths && (y = Math.floor(y)), E % a.slidesPerGroup === 0 && p.push(y), u.push(y)) : (a.roundLengths && (y = Math.floor(y)), (E - Math.min(e.params.slidesPerGroupSkip, E)) % e.params.slidesPerGroup === 0 && p.push(y), u.push(y), y = y + S + w), e.virtualSize += S + w, x = S, E += 1 } } if (e.virtualSize = Math.max(e.virtualSize, i) + v, n && r && (a.effect === 'slide' || a.effect === 'coverflow') && s.css({ width: e.virtualSize + a.spaceBetween + 'px' }), a.setWrapperSize && (e.isHorizontal() ? s.css({ width: e.virtualSize + a.spaceBetween + 'px' }) : s.css({ height: e.virtualSize + a.spaceBetween + 'px' })), a.slidesPerColumn > 1 && (e.virtualSize = (S + a.spaceBetween) * T, e.virtualSize = Math.ceil(e.virtualSize / a.slidesPerColumn) - a.spaceBetween, e.isHorizontal() ? s.css({ width: e.virtualSize + a.spaceBetween + 'px' }) : s.css({ height: e.virtualSize + a.spaceBetween + 'px' }), a.centeredSlides)) { C = []; for (let J = 0; J < p.length; J += 1) { let ee = p[J]; a.roundLengths && (ee = Math.floor(ee)), p[J] < e.virtualSize + p[0] && C.push(ee) }p = C } if (!a.centeredSlides) { C = []; for (let te = 0; te < p.length; te += 1) { let ae = p[te]; a.roundLengths && (ae = Math.floor(ae)), p[te] <= e.virtualSize - i && C.push(ae) }p = C, Math.floor(e.virtualSize - i) - Math.floor(p[p.length - 1]) > 1 && p.push(e.virtualSize - i) } if (p.length === 0 && (p = [0]), a.spaceBetween !== 0 && (e.isHorizontal() ? n ? d.filter(f).css({ marginLeft: w + 'px' }) : d.filter(f).css({ marginRight: w + 'px' }) : d.filter(f).css({ marginBottom: w + 'px' })), a.centeredSlides && a.centeredSlidesBounds) { let se = 0; h.forEach(function (e) { se += e + (a.spaceBetween ? a.spaceBetween : 0) }), se -= a.spaceBetween; const ie = se - i; p = p.map(function (e) { return e < 0 ? -m : e > ie ? ie + v : e }) } if (a.centerInsufficientSlides) { let ne = 0; if (h.forEach(function (e) { ne += e + (a.spaceBetween ? a.spaceBetween : 0) }), ne -= a.spaceBetween, ne < i) { const re = (i - ne) / 2; p.forEach(function (e, t) { p[t] = e - re }), u.forEach(function (e, t) { u[t] = e + re }) } }F.extend(e, { slides: d, snapGrid: p, slidesGrid: u, slidesSizesGrid: h }), c !== l && e.emit('slidesLengthChange'), p.length !== g && (e.params.watchOverflow && e.checkOverflow(), e.emit('snapGridLengthChange')), u.length !== b && e.emit('slidesGridLengthChange'), (a.watchSlidesProgress || a.watchSlidesVisibility) && e.updateSlidesOffset() } } function K (e) { let t; const a = this; const s = []; let i = 0; if (typeof e === 'number' ? a.setTransition(e) : !0 === e && a.setTransition(a.params.speed), a.params.slidesPerView !== 'auto' && a.params.slidesPerView > 1) for (t = 0; t < Math.ceil(a.params.slidesPerView); t += 1) { const n = a.activeIndex + t; if (n > a.slides.length) break; s.push(a.slides.eq(n)[0]) } else s.push(a.slides.eq(a.activeIndex)[0]); for (t = 0; t < s.length; t += 1) if (typeof s[t] !== 'undefined') { const r = s[t].offsetHeight; i = r > i ? r : i }i && a.$wrapperEl.css('height', i + 'px') } function Z () { for (let e = this, t = e.slides, a = 0; a < t.length; a += 1)t[a].swiperSlideOffset = e.isHorizontal() ? t[a].offsetLeft : t[a].offsetTop } function Q (e) { void 0 === e && (e = this && this.translate || 0); const t = this; const a = t.params; const i = t.slides; const n = t.rtlTranslate; if (i.length !== 0) { typeof i[0].swiperSlideOffset === 'undefined' && t.updateSlidesOffset(); let r = -e; n && (r = e), i.removeClass(a.slideVisibleClass), t.visibleSlidesIndexes = [], t.visibleSlides = []; for (let o = 0; o < i.length; o += 1) { const l = i[o]; const d = (r + (a.centeredSlides ? t.minTranslate() : 0) - l.swiperSlideOffset) / (l.swiperSlideSize + a.spaceBetween); if (a.watchSlidesVisibility) { const c = -(r - l.swiperSlideOffset); const p = c + t.slidesSizesGrid[o]; const u = c >= 0 && c < t.size - 1 || p > 1 && p <= t.size || c <= 0 && p >= t.size; u && (t.visibleSlides.push(l), t.visibleSlidesIndexes.push(o), i.eq(o).addClass(a.slideVisibleClass)) }l.progress = n ? -d : d }t.visibleSlides = s(t.visibleSlides) } } function J (e) { const t = this; if (typeof e === 'undefined') { const a = t.rtlTranslate ? -1 : 1; e = t && t.translate && t.translate * a || 0 } const s = t.params; const i = t.maxTranslate() - t.minTranslate(); let n = t.progress; let r = t.isBeginning; let o = t.isEnd; const l = r; const d = o; i === 0 ? (n = 0, r = !0, o = !0) : (n = (e - t.minTranslate()) / i, r = n <= 0, o = n >= 1), F.extend(t, { progress: n, isBeginning: r, isEnd: o }), (s.watchSlidesProgress || s.watchSlidesVisibility) && t.updateSlidesProgress(e), r && !l && t.emit('reachBeginning toEdge'), o && !d && t.emit('reachEnd toEdge'), (l && !r || d && !o) && t.emit('fromEdge'), t.emit('progress', n) } function ee () { let e; const t = this; const a = t.slides; const s = t.params; const i = t.$wrapperEl; const n = t.activeIndex; const r = t.realIndex; const o = t.virtual && s.virtual.enabled; a.removeClass(s.slideActiveClass + ' ' + s.slideNextClass + ' ' + s.slidePrevClass + ' ' + s.slideDuplicateActiveClass + ' ' + s.slideDuplicateNextClass + ' ' + s.slideDuplicatePrevClass), e = o ? t.$wrapperEl.find('.' + s.slideClass + '[data-swiper-slide-index="' + n + '"]') : a.eq(n), e.addClass(s.slideActiveClass), s.loop && (e.hasClass(s.slideDuplicateClass) ? i.children('.' + s.slideClass + ':not(.' + s.slideDuplicateClass + ')[data-swiper-slide-index="' + r + '"]').addClass(s.slideDuplicateActiveClass) : i.children('.' + s.slideClass + '.' + s.slideDuplicateClass + '[data-swiper-slide-index="' + r + '"]').addClass(s.slideDuplicateActiveClass)); let l = e.nextAll('.' + s.slideClass).eq(0).addClass(s.slideNextClass); s.loop && l.length === 0 && (l = a.eq(0), l.addClass(s.slideNextClass)); let d = e.prevAll('.' + s.slideClass).eq(0).addClass(s.slidePrevClass); s.loop && d.length === 0 && (d = a.eq(-1), d.addClass(s.slidePrevClass)), s.loop && (l.hasClass(s.slideDuplicateClass) ? i.children('.' + s.slideClass + ':not(.' + s.slideDuplicateClass + ')[data-swiper-slide-index="' + l.attr('data-swiper-slide-index') + '"]').addClass(s.slideDuplicateNextClass) : i.children('.' + s.slideClass + '.' + s.slideDuplicateClass + '[data-swiper-slide-index="' + l.attr('data-swiper-slide-index') + '"]').addClass(s.slideDuplicateNextClass), d.hasClass(s.slideDuplicateClass) ? i.children('.' + s.slideClass + ':not(.' + s.slideDuplicateClass + ')[data-swiper-slide-index="' + d.attr('data-swiper-slide-index') + '"]').addClass(s.slideDuplicatePrevClass) : i.children('.' + s.slideClass + '.' + s.slideDuplicateClass + '[data-swiper-slide-index="' + d.attr('data-swiper-slide-index') + '"]').addClass(s.slideDuplicatePrevClass)) } function te (e) { let t; const a = this; const s = a.rtlTranslate ? a.translate : -a.translate; const i = a.slidesGrid; const n = a.snapGrid; const r = a.params; const o = a.activeIndex; const l = a.realIndex; const d = a.snapIndex; let c = e; if (typeof c === 'undefined') { for (let p = 0; p < i.length; p += 1) typeof i[p + 1] !== 'undefined' ? s >= i[p] && s < i[p + 1] - (i[p + 1] - i[p]) / 2 ? c = p : s >= i[p] && s < i[p + 1] && (c = p + 1) : s >= i[p] && (c = p); r.normalizeSlideIndex && (c < 0 || typeof c === 'undefined') && (c = 0) } if (n.indexOf(s) >= 0)t = n.indexOf(s); else { const u = Math.min(r.slidesPerGroupSkip, c); t = u + Math.floor((c - u) / r.slidesPerGroup) } if (t >= n.length && (t = n.length - 1), c !== o) { const h = parseInt(a.slides.eq(c).attr('data-swiper-slide-index') || c, 10); F.extend(a, { snapIndex: t, realIndex: h, previousIndex: o, activeIndex: c }), a.emit('activeIndexChange'), a.emit('snapIndexChange'), l !== h && a.emit('realIndexChange'), (a.initialized || a.runCallbacksOnInit) && a.emit('slideChange') } else t !== d && (a.snapIndex = t, a.emit('snapIndexChange')) } function ae (e) { const t = this; const a = t.params; const i = s(e.target).closest('.' + a.slideClass)[0]; let n = !1; if (i) for (let r = 0; r < t.slides.length; r += 1)t.slides[r] === i && (n = !0); if (!i || !n) return t.clickedSlide = void 0, void (t.clickedIndex = void 0); t.clickedSlide = i, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(s(i).attr('data-swiper-slide-index'), 10) : t.clickedIndex = s(i).index(), a.slideToClickedSlide && void 0 !== t.clickedIndex && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide() }j.prototype.on = function (e, t, a) { const s = this; if (typeof t !== 'function') return s; const i = a ? 'unshift' : 'push'; return e.split(' ').forEach(function (e) { s.eventsListeners[e] || (s.eventsListeners[e] = []), s.eventsListeners[e][i](t) }), s }, j.prototype.once = function (e, t, a) { const s = this; if (typeof t !== 'function') return s; function i () { const a = []; let n = arguments.length; while (n--)a[n] = arguments[n]; s.off(e, i), i.f7proxy && delete i.f7proxy, t.apply(s, a) } return i.f7proxy = t, s.on(e, i, a) }, j.prototype.off = function (e, t) { const a = this; return a.eventsListeners ? (e.split(' ').forEach(function (e) { typeof t === 'undefined' ? a.eventsListeners[e] = [] : a.eventsListeners[e] && a.eventsListeners[e].length && a.eventsListeners[e].forEach(function (s, i) { (s === t || s.f7proxy && s.f7proxy === t) && a.eventsListeners[e].splice(i, 1) }) }), a) : a }, j.prototype.emit = function () { const e = []; let t = arguments.length; while (t--)e[t] = arguments[t]; let a; let s; let i; const n = this; if (!n.eventsListeners) return n; typeof e[0] === 'string' || Array.isArray(e[0]) ? (a = e[0], s = e.slice(1, e.length), i = n) : (a = e[0].events, s = e[0].data, i = e[0].context || n); const r = Array.isArray(a) ? a : a.split(' '); return r.forEach(function (e) { if (n.eventsListeners && n.eventsListeners[e]) { const t = []; n.eventsListeners[e].forEach(function (e) { t.push(e) }), t.forEach(function (e) { e.apply(i, s) }) } }), n }, j.prototype.useModulesParams = function (e) { const t = this; t.modules && Object.keys(t.modules).forEach(function (a) { const s = t.modules[a]; s.params && F.extend(e, s.params) }) }, j.prototype.useModules = function (e) { void 0 === e && (e = {}); const t = this; t.modules && Object.keys(t.modules).forEach(function (a) { const s = t.modules[a]; const i = e[a] || {}; s.instance && Object.keys(s.instance).forEach(function (e) { const a = s.instance[e]; t[e] = typeof a === 'function' ? a.bind(t) : a }), s.on && t.on && Object.keys(s.on).forEach(function (e) { t.on(e, s.on[e]) }), s.create && s.create.bind(t)(i) }) }, q.components.set = function (e) { const t = this; t.use && t.use(e) }, j.installModule = function (e) { const t = []; let a = arguments.length - 1; while (a-- > 0)t[a] = arguments[a + 1]; const s = this; s.prototype.modules || (s.prototype.modules = {}); const i = e.name || Object.keys(s.prototype.modules).length + '_' + F.now(); return s.prototype.modules[i] = e, e.proto && Object.keys(e.proto).forEach(function (t) { s.prototype[t] = e.proto[t] }), e.static && Object.keys(e.static).forEach(function (t) { s[t] = e.static[t] }), e.install && e.install.apply(s, t), s }, j.use = function (e) { const t = []; let a = arguments.length - 1; while (a-- > 0)t[a] = arguments[a + 1]; const s = this; return Array.isArray(e) ? (e.forEach(function (e) { return s.installModule(e) }), s) : s.installModule.apply(s, [e].concat(t)) }, Object.defineProperties(j, q); const se = { updateSize: _, updateSlides: U, updateAutoHeight: K, updateSlidesOffset: Z, updateSlidesProgress: Q, updateProgress: J, updateSlidesClasses: ee, updateActiveIndex: te, updateClickedSlide: ae }; function ie (e) { void 0 === e && (e = this.isHorizontal() ? 'x' : 'y'); const t = this; const a = t.params; const s = t.rtlTranslate; const i = t.translate; const n = t.$wrapperEl; if (a.virtualTranslate) return s ? -i : i; if (a.cssMode) return i; let r = F.getTranslate(n[0], e); return s && (r = -r), r || 0 } function ne (e, t) { let a; const s = this; const i = s.rtlTranslate; const n = s.params; const r = s.$wrapperEl; const o = s.wrapperEl; const l = s.progress; let d = 0; let c = 0; const p = 0; s.isHorizontal() ? d = i ? -e : e : c = e, n.roundLengths && (d = Math.floor(d), c = Math.floor(c)), n.cssMode ? o[s.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = s.isHorizontal() ? -d : -c : n.virtualTranslate || r.transform('translate3d(' + d + 'px, ' + c + 'px, ' + p + 'px)'), s.previousTranslate = s.translate, s.translate = s.isHorizontal() ? d : c; const u = s.maxTranslate() - s.minTranslate(); a = u === 0 ? 0 : (e - s.minTranslate()) / u, a !== l && s.updateProgress(e), s.emit('setTranslate', s.translate, t) } function re () { return -this.snapGrid[0] } function oe () { return -this.snapGrid[this.snapGrid.length - 1] } function le (e, t, a, s, i) { let n; void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === a && (a = !0), void 0 === s && (s = !0); const r = this; const o = r.params; const l = r.wrapperEl; if (r.animating && o.preventInteractionOnTransition) return !1; let d; const c = r.minTranslate(); const p = r.maxTranslate(); if (d = s && e > c ? c : s && e < p ? p : e, r.updateProgress(d), o.cssMode) { const u = r.isHorizontal(); return t === 0 ? l[u ? 'scrollLeft' : 'scrollTop'] = -d : l.scrollTo ? l.scrollTo((n = {}, n[u ? 'left' : 'top'] = -d, n.behavior = 'smooth', n)) : l[u ? 'scrollLeft' : 'scrollTop'] = -d, !0 } return t === 0 ? (r.setTransition(0), r.setTranslate(d), a && (r.emit('beforeTransitionStart', t, i), r.emit('transitionEnd'))) : (r.setTransition(t), r.setTranslate(d), a && (r.emit('beforeTransitionStart', t, i), r.emit('transitionStart')), r.animating || (r.animating = !0, r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function (e) { r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener('transitionend', r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener('webkitTransitionEnd', r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, a && r.emit('transitionEnd')) }), r.$wrapperEl[0].addEventListener('transitionend', r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener('webkitTransitionEnd', r.onTranslateToWrapperTransitionEnd))), !0 } const de = { getTranslate: ie, setTranslate: ne, minTranslate: re, maxTranslate: oe, translateTo: le }; function ce (e, t) { const a = this; a.params.cssMode || a.$wrapperEl.transition(e), a.emit('setTransition', e, t) } function pe (e, t) { void 0 === e && (e = !0); const a = this; const s = a.activeIndex; const i = a.params; const n = a.previousIndex; if (!i.cssMode) { i.autoHeight && a.updateAutoHeight(); let r = t; if (r || (r = s > n ? 'next' : s < n ? 'prev' : 'reset'), a.emit('transitionStart'), e && s !== n) { if (r === 'reset') return void a.emit('slideResetTransitionStart'); a.emit('slideChangeTransitionStart'), r === 'next' ? a.emit('slideNextTransitionStart') : a.emit('slidePrevTransitionStart') } } } function ue (e, t) { void 0 === e && (e = !0); const a = this; const s = a.activeIndex; const i = a.previousIndex; const n = a.params; if (a.animating = !1, !n.cssMode) { a.setTransition(0); let r = t; if (r || (r = s > i ? 'next' : s < i ? 'prev' : 'reset'), a.emit('transitionEnd'), e && s !== i) { if (r === 'reset') return void a.emit('slideResetTransitionEnd'); a.emit('slideChangeTransitionEnd'), r === 'next' ? a.emit('slideNextTransitionEnd') : a.emit('slidePrevTransitionEnd') } } } const he = { setTransition: ce, transitionStart: pe, transitionEnd: ue }; function fe (e, t, a, s) { let i; void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === a && (a = !0); const n = this; let r = e; r < 0 && (r = 0); const o = n.params; const l = n.snapGrid; const d = n.slidesGrid; const c = n.previousIndex; const p = n.activeIndex; const u = n.rtlTranslate; const h = n.wrapperEl; if (n.animating && o.preventInteractionOnTransition) return !1; const f = Math.min(n.params.slidesPerGroupSkip, r); let m = f + Math.floor((r - f) / n.params.slidesPerGroup); m >= l.length && (m = l.length - 1), (p || o.initialSlide || 0) === (c || 0) && a && n.emit('beforeSlideChangeStart'); let v; const g = -l[m]; if (n.updateProgress(g), o.normalizeSlideIndex) for (let b = 0; b < d.length; b += 1)-Math.floor(100 * g) >= Math.floor(100 * d[b]) && (r = b); if (n.initialized && r !== p) { if (!n.allowSlideNext && g < n.translate && g < n.minTranslate()) return !1; if (!n.allowSlidePrev && g > n.translate && g > n.maxTranslate() && (p || 0) !== r) return !1 } if (v = r > p ? 'next' : r < p ? 'prev' : 'reset', u && -g === n.translate || !u && g === n.translate) return n.updateActiveIndex(r), o.autoHeight && n.updateAutoHeight(), n.updateSlidesClasses(), o.effect !== 'slide' && n.setTranslate(g), v !== 'reset' && (n.transitionStart(a, v), n.transitionEnd(a, v)), !1; if (o.cssMode) { const w = n.isHorizontal(); return t === 0 ? h[w ? 'scrollLeft' : 'scrollTop'] = -g : h.scrollTo ? h.scrollTo((i = {}, i[w ? 'left' : 'top'] = -g, i.behavior = 'smooth', i)) : h[w ? 'scrollLeft' : 'scrollTop'] = -g, !0 } return t === 0 ? (n.setTransition(0), n.setTranslate(g), n.updateActiveIndex(r), n.updateSlidesClasses(), n.emit('beforeTransitionStart', t, s), n.transitionStart(a, v), n.transitionEnd(a, v)) : (n.setTransition(t), n.setTranslate(g), n.updateActiveIndex(r), n.updateSlidesClasses(), n.emit('beforeTransitionStart', t, s), n.transitionStart(a, v), n.animating || (n.animating = !0, n.onSlideToWrapperTransitionEnd || (n.onSlideToWrapperTransitionEnd = function (e) { n && !n.destroyed && e.target === this && (n.$wrapperEl[0].removeEventListener('transitionend', n.onSlideToWrapperTransitionEnd), n.$wrapperEl[0].removeEventListener('webkitTransitionEnd', n.onSlideToWrapperTransitionEnd), n.onSlideToWrapperTransitionEnd = null, delete n.onSlideToWrapperTransitionEnd, n.transitionEnd(a, v)) }), n.$wrapperEl[0].addEventListener('transitionend', n.onSlideToWrapperTransitionEnd), n.$wrapperEl[0].addEventListener('webkitTransitionEnd', n.onSlideToWrapperTransitionEnd))), !0 } function me (e, t, a, s) { void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === a && (a = !0); const i = this; let n = e; return i.params.loop && (n += i.loopedSlides), i.slideTo(n, t, a, s) } function ve (e, t, a) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0); const s = this; const i = s.params; const n = s.animating; const r = s.activeIndex < i.slidesPerGroupSkip ? 1 : i.slidesPerGroup; if (i.loop) { if (n) return !1; s.loopFix(), s._clientLeft = s.$wrapperEl[0].clientLeft } return s.slideTo(s.activeIndex + r, e, t, a) } function ge (e, t, a) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0); const s = this; const i = s.params; const n = s.animating; const r = s.snapGrid; const o = s.slidesGrid; const l = s.rtlTranslate; if (i.loop) { if (n) return !1; s.loopFix(), s._clientLeft = s.$wrapperEl[0].clientLeft } const d = l ? s.translate : -s.translate; function c (e) { return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e) } let p; const u = c(d); const h = r.map(function (e) { return c(e) }); let f = (o.map(function (e) { return c(e) }), r[h.indexOf(u)], r[h.indexOf(u) - 1]); return typeof f === 'undefined' && i.cssMode && r.forEach(function (e) { !f && u >= e && (f = e) }), typeof f !== 'undefined' && (p = o.indexOf(f), p < 0 && (p = s.activeIndex - 1)), s.slideTo(p, e, t, a) } function be (e, t, a) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0); const s = this; return s.slideTo(s.activeIndex, e, t, a) } function we (e, t, a, s) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), void 0 === s && (s = 0.5); const i = this; let n = i.activeIndex; const r = Math.min(i.params.slidesPerGroupSkip, n); const o = r + Math.floor((n - r) / i.params.slidesPerGroup); const l = i.rtlTranslate ? i.translate : -i.translate; if (l >= i.snapGrid[o]) { const d = i.snapGrid[o]; const c = i.snapGrid[o + 1]; l - d > (c - d) * s && (n += i.params.slidesPerGroup) } else { const p = i.snapGrid[o - 1]; const u = i.snapGrid[o]; l - p <= (u - p) * s && (n -= i.params.slidesPerGroup) } return n = Math.max(n, 0), n = Math.min(n, i.slidesGrid.length - 1), i.slideTo(n, e, t, a) } function ye () { let e; const t = this; const a = t.params; const i = t.$wrapperEl; const n = a.slidesPerView === 'auto' ? t.slidesPerViewDynamic() : a.slidesPerView; let r = t.clickedIndex; if (a.loop) { if (t.animating) return; e = parseInt(s(t.clickedSlide).attr('data-swiper-slide-index'), 10), a.centeredSlides ? r < t.loopedSlides - n / 2 || r > t.slides.length - t.loopedSlides + n / 2 ? (t.loopFix(), r = i.children('.' + a.slideClass + '[data-swiper-slide-index="' + e + '"]:not(.' + a.slideDuplicateClass + ')').eq(0).index(), F.nextTick(function () { t.slideTo(r) })) : t.slideTo(r) : r > t.slides.length - n ? (t.loopFix(), r = i.children('.' + a.slideClass + '[data-swiper-slide-index="' + e + '"]:not(.' + a.slideDuplicateClass + ')').eq(0).index(), F.nextTick(function () { t.slideTo(r) })) : t.slideTo(r) } else t.slideTo(r) } const xe = { slideTo: fe, slideToLoop: me, slideNext: ve, slidePrev: ge, slideReset: be, slideToClosest: we, slideToClickedSlide: ye }; function Ee () { const t = this; const a = t.params; const i = t.$wrapperEl; i.children('.' + a.slideClass + '.' + a.slideDuplicateClass).remove(); let n = i.children('.' + a.slideClass); if (a.loopFillGroupWithBlank) { const r = a.slidesPerGroup - n.length % a.slidesPerGroup; if (r !== a.slidesPerGroup) { for (let o = 0; o < r; o += 1) { const l = s(e.createElement('div')).addClass(a.slideClass + ' ' + a.slideBlankClass); i.append(l) }n = i.children('.' + a.slideClass) } }a.slidesPerView !== 'auto' || a.loopedSlides || (a.loopedSlides = n.length), t.loopedSlides = Math.ceil(parseFloat(a.loopedSlides || a.slidesPerView, 10)), t.loopedSlides += a.loopAdditionalSlides, t.loopedSlides > n.length && (t.loopedSlides = n.length); const d = []; const c = []; n.each(function (e, a) { const i = s(a); e < t.loopedSlides && c.push(a), e < n.length && e >= n.length - t.loopedSlides && d.push(a), i.attr('data-swiper-slide-index', e) }); for (let p = 0; p < c.length; p += 1)i.append(s(c[p].cloneNode(!0)).addClass(a.slideDuplicateClass)); for (let u = d.length - 1; u >= 0; u -= 1)i.prepend(s(d[u].cloneNode(!0)).addClass(a.slideDuplicateClass)) } function Te () { const e = this; e.emit('beforeLoopFix'); let t; const a = e.activeIndex; const s = e.slides; const i = e.loopedSlides; const n = e.allowSlidePrev; const r = e.allowSlideNext; const o = e.snapGrid; const l = e.rtlTranslate; e.allowSlidePrev = !0, e.allowSlideNext = !0; const d = -o[a]; const c = d - e.getTranslate(); if (a < i) { t = s.length - 3 * i + a, t += i; const p = e.slideTo(t, 0, !1, !0); p && c !== 0 && e.setTranslate((l ? -e.translate : e.translate) - c) } else if (a >= s.length - i) { t = -s.length + a + i, t += i; const u = e.slideTo(t, 0, !1, !0); u && c !== 0 && e.setTranslate((l ? -e.translate : e.translate) - c) }e.allowSlidePrev = n, e.allowSlideNext = r, e.emit('loopFix') } function Se () { const e = this; const t = e.$wrapperEl; const a = e.params; const s = e.slides; t.children('.' + a.slideClass + '.' + a.slideDuplicateClass + ',.' + a.slideClass + '.' + a.slideBlankClass).remove(), s.removeAttr('data-swiper-slide-index') } const Ce = { loopCreate: Ee, loopFix: Te, loopDestroy: Se }; function Me (e) { const t = this; if (!(W.touch || !t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode)) { const a = t.el; a.style.cursor = 'move', a.style.cursor = e ? '-webkit-grabbing' : '-webkit-grab', a.style.cursor = e ? '-moz-grabbin' : '-moz-grab', a.style.cursor = e ? 'grabbing' : 'grab' } } function $e () { const e = this; W.touch || e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.el.style.cursor = '') } const Pe = { setGrabCursor: Me, unsetGrabCursor: $e }; function ke (e) { const t = this; const a = t.$wrapperEl; const s = t.params; if (s.loop && t.loopDestroy(), typeof e === 'object' && 'length' in e) for (let i = 0; i < e.length; i += 1)e[i] && a.append(e[i]); else a.append(e); s.loop && t.loopCreate(), s.observer && W.observer || t.update() } function ze (e) { const t = this; const a = t.params; const s = t.$wrapperEl; const i = t.activeIndex; a.loop && t.loopDestroy(); let n = i + 1; if (typeof e === 'object' && 'length' in e) { for (let r = 0; r < e.length; r += 1)e[r] && s.prepend(e[r]); n = i + e.length } else s.prepend(e); a.loop && t.loopCreate(), a.observer && W.observer || t.update(), t.slideTo(n, 0, !1) } function Le (e, t) { const a = this; const s = a.$wrapperEl; const i = a.params; const n = a.activeIndex; let r = n; i.loop && (r -= a.loopedSlides, a.loopDestroy(), a.slides = s.children('.' + i.slideClass)); const o = a.slides.length; if (e <= 0)a.prependSlide(t); else if (e >= o)a.appendSlide(t); else { for (var l = r > e ? r + 1 : r, d = [], c = o - 1; c >= e; c -= 1) { const p = a.slides.eq(c); p.remove(), d.unshift(p) } if (typeof t === 'object' && 'length' in t) { for (let u = 0; u < t.length; u += 1)t[u] && s.append(t[u]); l = r > e ? r + t.length : r } else s.append(t); for (let h = 0; h < d.length; h += 1)s.append(d[h]); i.loop && a.loopCreate(), i.observer && W.observer || a.update(), i.loop ? a.slideTo(l + a.loopedSlides, 0, !1) : a.slideTo(l, 0, !1) } } function Ie (e) { const t = this; const a = t.params; const s = t.$wrapperEl; const i = t.activeIndex; let n = i; a.loop && (n -= t.loopedSlides, t.loopDestroy(), t.slides = s.children('.' + a.slideClass)); let r; let o = n; if (typeof e === 'object' && 'length' in e) { for (let l = 0; l < e.length; l += 1)r = e[l], t.slides[r] && t.slides.eq(r).remove(), r < o && (o -= 1); o = Math.max(o, 0) } else r = e, t.slides[r] && t.slides.eq(r).remove(), r < o && (o -= 1), o = Math.max(o, 0); a.loop && t.loopCreate(), a.observer && W.observer || t.update(), a.loop ? t.slideTo(o + t.loopedSlides, 0, !1) : t.slideTo(o, 0, !1) } function Oe () { for (var e = this, t = [], a = 0; a < e.slides.length; a += 1)t.push(a); e.removeSlide(t) } const De = { appendSlide: ke, prependSlide: ze, addSlide: Le, removeSlide: Ie, removeAllSlides: Oe }; const Ae = (function () { const e = t.navigator.platform; const a = t.navigator.userAgent; const s = { ios: !1, android: !1, androidChrome: !1, desktop: !1, iphone: !1, ipod: !1, ipad: !1, edge: !1, ie: !1, firefox: !1, macos: !1, windows: !1, cordova: !(!t.cordova && !t.phonegap), phonegap: !(!t.cordova && !t.phonegap), electron: !1 }; const i = t.screen.width; const n = t.screen.height; const r = a.match(/(Android);?[\s\/]+([\d.]+)?/); let o = a.match(/(iPad).*OS\s([\d_]+)/); const l = a.match(/(iPod)(.*OS\s([\d_]+))?/); const d = !o && a.match(/(iPhone\sOS|iOS)\s([\d_]+)/); const c = a.indexOf('MSIE ') >= 0 || a.indexOf('Trident/') >= 0; const p = a.indexOf('Edge/') >= 0; const u = a.indexOf('Gecko/') >= 0 && a.indexOf('Firefox/') >= 0; const h = e === 'Win32'; const f = a.toLowerCase().indexOf('electron') >= 0; let m = e === 'MacIntel'; return !o && m && W.touch && (i === 1024 && n === 1366 || i === 834 && n === 1194 || i === 834 && n === 1112 || i === 768 && n === 1024) && (o = a.match(/(Version)\/([\d.]+)/), m = !1), s.ie = c, s.edge = p, s.firefox = u, r && !h && (s.os = 'android', s.osVersion = r[2], s.android = !0, s.androidChrome = a.toLowerCase().indexOf('chrome') >= 0), (o || d || l) && (s.os = 'ios', s.ios = !0), d && !l && (s.osVersion = d[2].replace(/_/g, '.'), s.iphone = !0), o && (s.osVersion = o[2].replace(/_/g, '.'), s.ipad = !0), l && (s.osVersion = l[3] ? l[3].replace(/_/g, '.') : null, s.ipod = !0), s.ios && s.osVersion && a.indexOf('Version/') >= 0 && s.osVersion.split('.')[0] === '10' && (s.osVersion = a.toLowerCase().split('version/')[1].split(' ')[0]), s.webView = !(!(d || o || l) || !a.match(/.*AppleWebKit(?!.*Safari)/i) && !t.navigator.standalone) || t.matchMedia && t.matchMedia('(display-mode: standalone)').matches, s.webview = s.webView, s.standalone = s.webView, s.desktop = !(s.ios || s.android) || f, s.desktop && (s.electron = f, s.macos = m, s.windows = h, s.macos && (s.os = 'macos'), s.windows && (s.os = 'windows')), s.pixelRatio = t.devicePixelRatio || 1, s }()); function Ge (a) { const i = this; const n = i.touchEventsData; const r = i.params; const o = i.touches; if (!i.animating || !r.preventInteractionOnTransition) { let l = a; l.originalEvent && (l = l.originalEvent); const d = s(l.target); if ((r.touchEventsTarget !== 'wrapper' || d.closest(i.wrapperEl).length) && (n.isTouchEvent = l.type === 'touchstart', (n.isTouchEvent || !('which' in l) || l.which !== 3) && !(!n.isTouchEvent && 'button' in l && l.button > 0) && (!n.isTouched || !n.isMoved))) if (r.noSwiping && d.closest(r.noSwipingSelector ? r.noSwipingSelector : '.' + r.noSwipingClass)[0])i.allowClick = !0; else if (!r.swipeHandler || d.closest(r.swipeHandler)[0]) { o.currentX = l.type === 'touchstart' ? l.targetTouches[0].pageX : l.pageX, o.currentY = l.type === 'touchstart' ? l.targetTouches[0].pageY : l.pageY; const c = o.currentX; const p = o.currentY; const u = r.edgeSwipeDetection || r.iOSEdgeSwipeDetection; const h = r.edgeSwipeThreshold || r.iOSEdgeSwipeThreshold; if (!u || !(c <= h || c >= t.screen.width - h)) { if (F.extend(n, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), o.startX = c, o.startY = p, n.touchStartTime = F.now(), i.allowClick = !0, i.updateSize(), i.swipeDirection = void 0, r.threshold > 0 && (n.allowThresholdMove = !1), l.type !== 'touchstart') { let f = !0; d.is(n.formElements) && (f = !1), e.activeElement && s(e.activeElement).is(n.formElements) && e.activeElement !== d[0] && e.activeElement.blur(); const m = f && i.allowTouchMove && r.touchStartPreventDefault; (r.touchStartForcePreventDefault || m) && l.preventDefault() }i.emit('touchStart', l) } } } } function Be (t) { const a = this; const i = a.touchEventsData; const n = a.params; const r = a.touches; const o = a.rtlTranslate; let l = t; if (l.originalEvent && (l = l.originalEvent), i.isTouched) { if (!i.isTouchEvent || l.type !== 'mousemove') { const d = l.type === 'touchmove' && l.targetTouches && (l.targetTouches[0] || l.changedTouches[0]); const c = l.type === 'touchmove' ? d.pageX : l.pageX; const p = l.type === 'touchmove' ? d.pageY : l.pageY; if (l.preventedByNestedSwiper) return r.startX = c, void (r.startY = p); if (!a.allowTouchMove) return a.allowClick = !1, void (i.isTouched && (F.extend(r, { startX: c, startY: p, currentX: c, currentY: p }), i.touchStartTime = F.now())); if (i.isTouchEvent && n.touchReleaseOnEdges && !n.loop) if (a.isVertical()) { if (p < r.startY && a.translate <= a.maxTranslate() || p > r.startY && a.translate >= a.minTranslate()) return i.isTouched = !1, void (i.isMoved = !1) } else if (c < r.startX && a.translate <= a.maxTranslate() || c > r.startX && a.translate >= a.minTranslate()) return; if (i.isTouchEvent && e.activeElement && l.target === e.activeElement && s(l.target).is(i.formElements)) return i.isMoved = !0, void (a.allowClick = !1); if (i.allowTouchCallbacks && a.emit('touchMove', l), !(l.targetTouches && l.targetTouches.length > 1)) { r.currentX = c, r.currentY = p; const u = r.currentX - r.startX; const h = r.currentY - r.startY; if (!(a.params.threshold && Math.sqrt(Math.pow(u, 2) + Math.pow(h, 2)) < a.params.threshold)) { let f; if (typeof i.isScrolling === 'undefined')a.isHorizontal() && r.currentY === r.startY || a.isVertical() && r.currentX === r.startX ? i.isScrolling = !1 : u * u + h * h >= 25 && (f = 180 * Math.atan2(Math.abs(h), Math.abs(u)) / Math.PI, i.isScrolling = a.isHorizontal() ? f > n.touchAngle : 90 - f > n.touchAngle); if (i.isScrolling && a.emit('touchMoveOpposite', l), typeof i.startMoving === 'undefined' && (r.currentX === r.startX && r.currentY === r.startY || (i.startMoving = !0)), i.isScrolling)i.isTouched = !1; else if (i.startMoving) { a.allowClick = !1, n.cssMode || l.preventDefault(), n.touchMoveStopPropagation && !n.nested && l.stopPropagation(), i.isMoved || (n.loop && a.loopFix(), i.startTranslate = a.getTranslate(), a.setTransition(0), a.animating && a.$wrapperEl.trigger('webkitTransitionEnd transitionend'), i.allowMomentumBounce = !1, !n.grabCursor || !0 !== a.allowSlideNext && !0 !== a.allowSlidePrev || a.setGrabCursor(!0), a.emit('sliderFirstMove', l)), a.emit('sliderMove', l), i.isMoved = !0; let m = a.isHorizontal() ? u : h; r.diff = m, m *= n.touchRatio, o && (m = -m), a.swipeDirection = m > 0 ? 'prev' : 'next', i.currentTranslate = m + i.startTranslate; let v = !0; let g = n.resistanceRatio; if (n.touchReleaseOnEdges && (g = 0), m > 0 && i.currentTranslate > a.minTranslate() ? (v = !1, n.resistance && (i.currentTranslate = a.minTranslate() - 1 + Math.pow(-a.minTranslate() + i.startTranslate + m, g))) : m < 0 && i.currentTranslate < a.maxTranslate() && (v = !1, n.resistance && (i.currentTranslate = a.maxTranslate() + 1 - Math.pow(a.maxTranslate() - i.startTranslate - m, g))), v && (l.preventedByNestedSwiper = !0), !a.allowSlideNext && a.swipeDirection === 'next' && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !a.allowSlidePrev && a.swipeDirection === 'prev' && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), n.threshold > 0) { if (!(Math.abs(m) > n.threshold || i.allowThresholdMove)) return void (i.currentTranslate = i.startTranslate); if (!i.allowThresholdMove) return i.allowThresholdMove = !0, r.startX = r.currentX, r.startY = r.currentY, i.currentTranslate = i.startTranslate, void (r.diff = a.isHorizontal() ? r.currentX - r.startX : r.currentY - r.startY) }n.followFinger && !n.cssMode && ((n.freeMode || n.watchSlidesProgress || n.watchSlidesVisibility) && (a.updateActiveIndex(), a.updateSlidesClasses()), n.freeMode && (i.velocities.length === 0 && i.velocities.push({ position: r[a.isHorizontal() ? 'startX' : 'startY'], time: i.touchStartTime }), i.velocities.push({ position: r[a.isHorizontal() ? 'currentX' : 'currentY'], time: F.now() })), a.updateProgress(i.currentTranslate), a.setTranslate(i.currentTranslate)) } } } } } else i.startMoving && i.isScrolling && a.emit('touchMoveOpposite', l) } function Ne (e) { const t = this; const a = t.touchEventsData; const s = t.params; const i = t.touches; const n = t.rtlTranslate; const r = t.$wrapperEl; const o = t.slidesGrid; const l = t.snapGrid; let d = e; if (d.originalEvent && (d = d.originalEvent), a.allowTouchCallbacks && t.emit('touchEnd', d), a.allowTouchCallbacks = !1, !a.isTouched) return a.isMoved && s.grabCursor && t.setGrabCursor(!1), a.isMoved = !1, void (a.startMoving = !1); s.grabCursor && a.isMoved && a.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1); let c; const p = F.now(); const u = p - a.touchStartTime; if (t.allowClick && (t.updateClickedSlide(d), t.emit('tap click', d), u < 300 && p - a.lastClickTime < 300 && t.emit('doubleTap doubleClick', d)), a.lastClickTime = F.now(), F.nextTick(function () { t.destroyed || (t.allowClick = !0) }), !a.isTouched || !a.isMoved || !t.swipeDirection || i.diff === 0 || a.currentTranslate === a.startTranslate) return a.isTouched = !1, a.isMoved = !1, void (a.startMoving = !1); if (a.isTouched = !1, a.isMoved = !1, a.startMoving = !1, c = s.followFinger ? n ? t.translate : -t.translate : -a.currentTranslate, !s.cssMode) if (s.freeMode) { if (c < -t.minTranslate()) return void t.slideTo(t.activeIndex); if (c > -t.maxTranslate()) return void (t.slides.length < l.length ? t.slideTo(l.length - 1) : t.slideTo(t.slides.length - 1)); if (s.freeModeMomentum) { if (a.velocities.length > 1) { const h = a.velocities.pop(); const f = a.velocities.pop(); const m = h.position - f.position; const v = h.time - f.time; t.velocity = m / v, t.velocity /= 2, Math.abs(t.velocity) < s.freeModeMinimumVelocity && (t.velocity = 0), (v > 150 || F.now() - h.time > 300) && (t.velocity = 0) } else t.velocity = 0; t.velocity *= s.freeModeMomentumVelocityRatio, a.velocities.length = 0; let g = 1e3 * s.freeModeMomentumRatio; const b = t.velocity * g; let w = t.translate + b; n && (w = -w); let y; let x; let E = !1; const T = 20 * Math.abs(t.velocity) * s.freeModeMomentumBounceRatio; if (w < t.maxTranslate())s.freeModeMomentumBounce ? (w + t.maxTranslate() < -T && (w = t.maxTranslate() - T), y = t.maxTranslate(), E = !0, a.allowMomentumBounce = !0) : w = t.maxTranslate(), s.loop && s.centeredSlides && (x = !0); else if (w > t.minTranslate())s.freeModeMomentumBounce ? (w - t.minTranslate() > T && (w = t.minTranslate() + T), y = t.minTranslate(), E = !0, a.allowMomentumBounce = !0) : w = t.minTranslate(), s.loop && s.centeredSlides && (x = !0); else if (s.freeModeSticky) { for (var S, C = 0; C < l.length; C += 1) if (l[C] > -w) { S = C; break }w = Math.abs(l[S] - w) < Math.abs(l[S - 1] - w) || t.swipeDirection === 'next' ? l[S] : l[S - 1], w = -w } if (x && t.once('transitionEnd', function () { t.loopFix() }), t.velocity !== 0) { if (g = n ? Math.abs((-w - t.translate) / t.velocity) : Math.abs((w - t.translate) / t.velocity), s.freeModeSticky) { const M = Math.abs((n ? -w : w) - t.translate); const $ = t.slidesSizesGrid[t.activeIndex]; g = M < $ ? s.speed : M < 2 * $ ? 1.5 * s.speed : 2.5 * s.speed } } else if (s.freeModeSticky) return void t.slideToClosest(); s.freeModeMomentumBounce && E ? (t.updateProgress(y), t.setTransition(g), t.setTranslate(w), t.transitionStart(!0, t.swipeDirection), t.animating = !0, r.transitionEnd(function () { t && !t.destroyed && a.allowMomentumBounce && (t.emit('momentumBounce'), t.setTransition(s.speed), t.setTranslate(y), r.transitionEnd(function () { t && !t.destroyed && t.transitionEnd() })) })) : t.velocity ? (t.updateProgress(w), t.setTransition(g), t.setTranslate(w), t.transitionStart(!0, t.swipeDirection), t.animating || (t.animating = !0, r.transitionEnd(function () { t && !t.destroyed && t.transitionEnd() }))) : t.updateProgress(w), t.updateActiveIndex(), t.updateSlidesClasses() } else if (s.freeModeSticky) return void t.slideToClosest(); (!s.freeModeMomentum || u >= s.longSwipesMs) && (t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses()) } else { for (var P = 0, k = t.slidesSizesGrid[0], z = 0; z < o.length; z += z < s.slidesPerGroupSkip ? 1 : s.slidesPerGroup) { const L = z < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup; typeof o[z + L] !== 'undefined' ? c >= o[z] && c < o[z + L] && (P = z, k = o[z + L] - o[z]) : c >= o[z] && (P = z, k = o[o.length - 1] - o[o.length - 2]) } const I = (c - o[P]) / k; const O = P < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup; if (u > s.longSwipesMs) { if (!s.longSwipes) return void t.slideTo(t.activeIndex); t.swipeDirection === 'next' && (I >= s.longSwipesRatio ? t.slideTo(P + O) : t.slideTo(P)), t.swipeDirection === 'prev' && (I > 1 - s.longSwipesRatio ? t.slideTo(P + O) : t.slideTo(P)) } else { if (!s.shortSwipes) return void t.slideTo(t.activeIndex); const D = t.navigation && (d.target === t.navigation.nextEl || d.target === t.navigation.prevEl); D ? d.target === t.navigation.nextEl ? t.slideTo(P + O) : t.slideTo(P) : (t.swipeDirection === 'next' && t.slideTo(P + O), t.swipeDirection === 'prev' && t.slideTo(P)) } } } function He () { const e = this; const t = e.params; const a = e.el; if (!a || a.offsetWidth !== 0) { t.breakpoints && e.setBreakpoint(); const s = e.allowSlideNext; const i = e.allowSlidePrev; const n = e.snapGrid; e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(), (t.slidesPerView === 'auto' || t.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.run(), e.allowSlidePrev = i, e.allowSlideNext = s, e.params.watchOverflow && n !== e.snapGrid && e.checkOverflow() } } function Xe (e) { const t = this; t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation())) } function Ve () { let e; const t = this; const a = t.wrapperEl; t.previousTranslate = t.translate, t.translate = t.isHorizontal() ? -a.scrollLeft : -a.scrollTop, t.translate === -0 && (t.translate = 0), t.updateActiveIndex(), t.updateSlidesClasses(); const s = t.maxTranslate() - t.minTranslate(); e = s === 0 ? 0 : (t.translate - t.minTranslate()) / s, e !== t.progress && t.updateProgress(t.translate), t.emit('setTranslate', t.translate, !1) } let Ye = !1; function Re () {} function Fe () { const t = this; const a = t.params; const s = t.touchEvents; const i = t.el; const n = t.wrapperEl; t.onTouchStart = Ge.bind(t), t.onTouchMove = Be.bind(t), t.onTouchEnd = Ne.bind(t), a.cssMode && (t.onScroll = Ve.bind(t)), t.onClick = Xe.bind(t); const r = !!a.nested; if (!W.touch && W.pointerEvents)i.addEventListener(s.start, t.onTouchStart, !1), e.addEventListener(s.move, t.onTouchMove, r), e.addEventListener(s.end, t.onTouchEnd, !1); else { if (W.touch) { const o = !(s.start !== 'touchstart' || !W.passiveListener || !a.passiveListeners) && { passive: !0, capture: !1 }; i.addEventListener(s.start, t.onTouchStart, o), i.addEventListener(s.move, t.onTouchMove, W.passiveListener ? { passive: !1, capture: r } : r), i.addEventListener(s.end, t.onTouchEnd, o), s.cancel && i.addEventListener(s.cancel, t.onTouchEnd, o), Ye || (e.addEventListener('touchstart', Re), Ye = !0) }(a.simulateTouch && !Ae.ios && !Ae.android || a.simulateTouch && !W.touch && Ae.ios) && (i.addEventListener('mousedown', t.onTouchStart, !1), e.addEventListener('mousemove', t.onTouchMove, r), e.addEventListener('mouseup', t.onTouchEnd, !1)) }(a.preventClicks || a.preventClicksPropagation) && i.addEventListener('click', t.onClick, !0), a.cssMode && n.addEventListener('scroll', t.onScroll), a.updateOnWindowResize ? t.on(Ae.ios || Ae.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', He, !0) : t.on('observerUpdate', He, !0) } function We () { const t = this; const a = t.params; const s = t.touchEvents; const i = t.el; const n = t.wrapperEl; const r = !!a.nested; if (!W.touch && W.pointerEvents)i.removeEventListener(s.start, t.onTouchStart, !1), e.removeEventListener(s.move, t.onTouchMove, r), e.removeEventListener(s.end, t.onTouchEnd, !1); else { if (W.touch) { const o = !(s.start !== 'onTouchStart' || !W.passiveListener || !a.passiveListeners) && { passive: !0, capture: !1 }; i.removeEventListener(s.start, t.onTouchStart, o), i.removeEventListener(s.move, t.onTouchMove, r), i.removeEventListener(s.end, t.onTouchEnd, o), s.cancel && i.removeEventListener(s.cancel, t.onTouchEnd, o) }(a.simulateTouch && !Ae.ios && !Ae.android || a.simulateTouch && !W.touch && Ae.ios) && (i.removeEventListener('mousedown', t.onTouchStart, !1), e.removeEventListener('mousemove', t.onTouchMove, r), e.removeEventListener('mouseup', t.onTouchEnd, !1)) }(a.preventClicks || a.preventClicksPropagation) && i.removeEventListener('click', t.onClick, !0), a.cssMode && n.removeEventListener('scroll', t.onScroll), t.off(Ae.ios || Ae.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', He) } const je = { attachEvents: Fe, detachEvents: We }; function qe () { const e = this; const t = e.activeIndex; const a = e.initialized; let s = e.loopedSlides; void 0 === s && (s = 0); const i = e.params; const n = e.$el; const r = i.breakpoints; if (r && (!r || Object.keys(r).length !== 0)) { const o = e.getBreakpoint(r); if (o && e.currentBreakpoint !== o) { const l = o in r ? r[o] : void 0; l && ['slidesPerView', 'spaceBetween', 'slidesPerGroup', 'slidesPerGroupSkip', 'slidesPerColumn'].forEach(function (e) { const t = l[e]; typeof t !== 'undefined' && (l[e] = e !== 'slidesPerView' || t !== 'AUTO' && t !== 'auto' ? e === 'slidesPerView' ? parseFloat(t) : parseInt(t, 10) : 'auto') }); const d = l || e.originalParams; const c = i.slidesPerColumn > 1; const p = d.slidesPerColumn > 1; c && !p ? n.removeClass(i.containerModifierClass + 'multirow ' + i.containerModifierClass + 'multirow-column') : !c && p && (n.addClass(i.containerModifierClass + 'multirow'), d.slidesPerColumnFill === 'column' && n.addClass(i.containerModifierClass + 'multirow-column')); const u = d.direction && d.direction !== i.direction; const h = i.loop && (d.slidesPerView !== i.slidesPerView || u); u && a && e.changeDirection(), F.extend(e.params, d), F.extend(e, { allowTouchMove: e.params.allowTouchMove, allowSlideNext: e.params.allowSlideNext, allowSlidePrev: e.params.allowSlidePrev }), e.currentBreakpoint = o, h && a && (e.loopDestroy(), e.loopCreate(), e.updateSlides(), e.slideTo(t - s + e.loopedSlides, 0, !1)), e.emit('breakpoint', d) } } } function _e (e) { if (e) { let a = !1; const s = Object.keys(e).map(function (e) { if (typeof e === 'string' && e.startsWith('@')) { const a = parseFloat(e.substr(1)); const s = t.innerHeight * a; return { value: s, point: e } } return { value: e, point: e } }); s.sort(function (e, t) { return parseInt(e.value, 10) - parseInt(t.value, 10) }); for (let i = 0; i < s.length; i += 1) { const n = s[i]; const r = n.point; const o = n.value; o <= t.innerWidth && (a = r) } return a || 'max' } } const Ue = { setBreakpoint: qe, getBreakpoint: _e }; function Ke () { const e = this; const t = e.classNames; const a = e.params; const s = e.rtl; const i = e.$el; const n = []; n.push('initialized'), n.push(a.direction), a.freeMode && n.push('free-mode'), a.autoHeight && n.push('autoheight'), s && n.push('rtl'), a.slidesPerColumn > 1 && (n.push('multirow'), a.slidesPerColumnFill === 'column' && n.push('multirow-column')), Ae.android && n.push('android'), Ae.ios && n.push('ios'), a.cssMode && n.push('css-mode'), n.forEach(function (e) { t.push(a.containerModifierClass + e) }), i.addClass(t.join(' ')) } function Ze () { const e = this; const t = e.$el; const a = e.classNames; t.removeClass(a.join(' ')) } const Qe = { addClasses: Ke, removeClasses: Ze }; function Je (e, a, s, i, n, r) { let o; function l () { r && r() }e.complete && n ? l() : a ? (o = new t.Image(), o.onload = l, o.onerror = l, i && (o.sizes = i), s && (o.srcset = s), a && (o.src = a)) : l() } function et () { const e = this; function t () { typeof e !== 'undefined' && e !== null && e && !e.destroyed && (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1), e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(), e.emit('imagesReady'))) }e.imagesToLoad = e.$el.find('img'); for (let a = 0; a < e.imagesToLoad.length; a += 1) { const s = e.imagesToLoad[a]; e.loadImage(s, s.currentSrc || s.getAttribute('src'), s.srcset || s.getAttribute('srcset'), s.sizes || s.getAttribute('sizes'), !0, t) } } const tt = { loadImage: Je, preloadImages: et }; function at () { const e = this; const t = e.params; const a = e.isLocked; const s = e.slides.length > 0 && t.slidesOffsetBefore + t.spaceBetween * (e.slides.length - 1) + e.slides[0].offsetWidth * e.slides.length; t.slidesOffsetBefore && t.slidesOffsetAfter && s ? e.isLocked = s <= e.size : e.isLocked = e.snapGrid.length === 1, e.allowSlideNext = !e.isLocked, e.allowSlidePrev = !e.isLocked, a !== e.isLocked && e.emit(e.isLocked ? 'lock' : 'unlock'), a && a !== e.isLocked && (e.isEnd = !1, e.navigation.update()) } const st = { checkOverflow: at }; const it = { init: !0, direction: 'horizontal', touchEventsTarget: 'container', initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, preventInteractionOnTransition: !1, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, freeMode: !1, freeModeMomentum: !0, freeModeMomentumRatio: 1, freeModeMomentumBounce: !0, freeModeMomentumBounceRatio: 1, freeModeMomentumVelocityRatio: 1, freeModeSticky: !1, freeModeMinimumVelocity: 0.02, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: 'slide', breakpoints: void 0, spaceBetween: 0, slidesPerView: 1, slidesPerColumn: 1, slidesPerColumnFill: 'column', slidesPerGroup: 1, slidesPerGroupSkip: 0, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !1, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: 0.5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 0, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: 0.85, watchSlidesProgress: !1, watchSlidesVisibility: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, preloadImages: !0, updateOnImagesReady: !0, loop: !1, loopAdditionalSlides: 0, loopedSlides: null, loopFillGroupWithBlank: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: 'swiper-no-swiping', noSwipingSelector: null, passiveListeners: !0, containerModifierClass: 'swiper-container-', slideClass: 'swiper-slide', slideBlankClass: 'swiper-slide-invisible-blank', slideActiveClass: 'swiper-slide-active', slideDuplicateActiveClass: 'swiper-slide-duplicate-active', slideVisibleClass: 'swiper-slide-visible', slideDuplicateClass: 'swiper-slide-duplicate', slideNextClass: 'swiper-slide-next', slideDuplicateNextClass: 'swiper-slide-duplicate-next', slidePrevClass: 'swiper-slide-prev', slideDuplicatePrevClass: 'swiper-slide-duplicate-prev', wrapperClass: 'swiper-wrapper', runCallbacksOnInit: !0 }; const nt = { update: se, translate: de, transition: he, slide: xe, loop: Ce, grabCursor: Pe, manipulation: De, events: je, breakpoints: Ue, checkOverflow: st, classes: Qe, images: tt }; const rt = {}; const ot = (function (e) { function t () { let a; let i; let n; const r = []; let o = arguments.length; while (o--)r[o] = arguments[o]; r.length === 1 && r[0].constructor && r[0].constructor === Object ? n = r[0] : (a = r, i = a[0], n = a[1]), n || (n = {}), n = F.extend({}, n), i && !n.el && (n.el = i), e.call(this, n), Object.keys(nt).forEach(function (e) { Object.keys(nt[e]).forEach(function (a) { t.prototype[a] || (t.prototype[a] = nt[e][a]) }) }); const l = this; typeof l.modules === 'undefined' && (l.modules = {}), Object.keys(l.modules).forEach(function (e) { const t = l.modules[e]; if (t.params) { const a = Object.keys(t.params)[0]; const s = t.params[a]; if (typeof s !== 'object' || s === null) return; if (!(a in n && 'enabled' in s)) return; !0 === n[a] && (n[a] = { enabled: !0 }), typeof n[a] !== 'object' || 'enabled' in n[a] || (n[a].enabled = !0), n[a] || (n[a] = { enabled: !1 }) } }); const d = F.extend({}, it); l.useModulesParams(d), l.params = F.extend({}, d, rt, n), l.originalParams = F.extend({}, l.params), l.passedParams = F.extend({}, n), l.$ = s; const c = s(l.params.el); if (i = c[0], i) { if (c.length > 1) { const p = []; return c.each(function (e, a) { const s = F.extend({}, n, { el: a }); p.push(new t(s)) }), p } let u; return i.swiper = l, c.data('swiper', l), i && i.shadowRoot && i.shadowRoot.querySelector ? (u = s(i.shadowRoot.querySelector('.' + l.params.wrapperClass)), u.children = function (e) { return c.children(e) }) : u = c.children('.' + l.params.wrapperClass), F.extend(l, { $el: c, el: i, $wrapperEl: u, wrapperEl: u[0], classNames: [], slides: s(), slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal: function () { return l.params.direction === 'horizontal' }, isVertical: function () { return l.params.direction === 'vertical' }, rtl: i.dir.toLowerCase() === 'rtl' || c.css('direction') === 'rtl', rtlTranslate: l.params.direction === 'horizontal' && (i.dir.toLowerCase() === 'rtl' || c.css('direction') === 'rtl'), wrongRTL: u.css('display') === '-webkit-box', activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, allowSlideNext: l.params.allowSlideNext, allowSlidePrev: l.params.allowSlidePrev, touchEvents: (function () { const e = ['touchstart', 'touchmove', 'touchend', 'touchcancel']; let t = ['mousedown', 'mousemove', 'mouseup']; return W.pointerEvents && (t = ['pointerdown', 'pointermove', 'pointerup']), l.touchEventsTouch = { start: e[0], move: e[1], end: e[2], cancel: e[3] }, l.touchEventsDesktop = { start: t[0], move: t[1], end: t[2] }, W.touch || !l.params.simulateTouch ? l.touchEventsTouch : l.touchEventsDesktop }()), touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, formElements: 'input, select, option, textarea, button, video, label', lastClickTime: F.now(), clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, isTouchEvent: void 0, startMoving: void 0 }, allowClick: !0, allowTouchMove: l.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), l.useModules(), l.params.init && l.init(), l } }e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t; const a = { extendedDefaults: { configurable: !0 }, defaults: { configurable: !0 }, Class: { configurable: !0 }, $: { configurable: !0 } }; return t.prototype.slidesPerViewDynamic = function () { const e = this; const t = e.params; const a = e.slides; const s = e.slidesGrid; const i = e.size; const n = e.activeIndex; let r = 1; if (t.centeredSlides) { for (var o, l = a[n].swiperSlideSize, d = n + 1; d < a.length; d += 1)a[d] && !o && (l += a[d].swiperSlideSize, r += 1, l > i && (o = !0)); for (let c = n - 1; c >= 0; c -= 1)a[c] && !o && (l += a[c].swiperSlideSize, r += 1, l > i && (o = !0)) } else for (let p = n + 1; p < a.length; p += 1)s[p] - s[n] < i && (r += 1); return r }, t.prototype.update = function () { const e = this; if (e && !e.destroyed) { let t; const a = e.snapGrid; const s = e.params; s.breakpoints && e.setBreakpoint(), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.params.freeMode ? (i(), e.params.autoHeight && e.updateAutoHeight()) : (t = (e.params.slidesPerView === 'auto' || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), t || i()), s.watchOverflow && a !== e.snapGrid && e.checkOverflow(), e.emit('update') } function i () { const t = e.rtlTranslate ? -1 * e.translate : e.translate; const a = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate()); e.setTranslate(a), e.updateActiveIndex(), e.updateSlidesClasses() } }, t.prototype.changeDirection = function (e, t) { void 0 === t && (t = !0); const a = this; const s = a.params.direction; return e || (e = s === 'horizontal' ? 'vertical' : 'horizontal'), e === s || e !== 'horizontal' && e !== 'vertical' ? a : (a.$el.removeClass('' + a.params.containerModifierClass + s).addClass('' + a.params.containerModifierClass + e), a.params.direction = e, a.slides.each(function (t, a) { e === 'vertical' ? a.style.width = '' : a.style.height = '' }), a.emit('changeDirection'), t && a.update(), a) }, t.prototype.init = function () { const e = this; e.initialized || (e.emit('beforeInit'), e.params.breakpoints && e.setBreakpoint(), e.addClasses(), e.params.loop && e.loopCreate(), e.updateSize(), e.updateSlides(), e.params.watchOverflow && e.checkOverflow(), e.params.grabCursor && e.setGrabCursor(), e.params.preloadImages && e.preloadImages(), e.params.loop ? e.slideTo(e.params.initialSlide + e.loopedSlides, 0, e.params.runCallbacksOnInit) : e.slideTo(e.params.initialSlide, 0, e.params.runCallbacksOnInit), e.attachEvents(), e.initialized = !0, e.emit('init')) }, t.prototype.destroy = function (e, t) { void 0 === e && (e = !0), void 0 === t && (t = !0); const a = this; const s = a.params; const i = a.$el; const n = a.$wrapperEl; const r = a.slides; return typeof a.params === 'undefined' || a.destroyed ? null : (a.emit('beforeDestroy'), a.initialized = !1, a.detachEvents(), s.loop && a.loopDestroy(), t && (a.removeClasses(), i.removeAttr('style'), n.removeAttr('style'), r && r.length && r.removeClass([s.slideVisibleClass, s.slideActiveClass, s.slideNextClass, s.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index')), a.emit('destroy'), Object.keys(a.eventsListeners).forEach(function (e) { a.off(e) }), !1 !== e && (a.$el[0].swiper = null, a.$el.data('swiper', null), F.deleteProps(a)), a.destroyed = !0, null) }, t.extendDefaults = function (e) { F.extend(rt, e) }, a.extendedDefaults.get = function () { return rt }, a.defaults.get = function () { return it }, a.Class.get = function () { return e }, a.$.get = function () { return s }, Object.defineProperties(t, a), t }(j)); const lt = { name: 'device', proto: { device: Ae }, static: { device: Ae } }; const dt = { name: 'support', proto: { support: W }, static: { support: W } }; const ct = (function () { function e () { const e = t.navigator.userAgent.toLowerCase(); return e.indexOf('safari') >= 0 && e.indexOf('chrome') < 0 && e.indexOf('android') < 0 } return { isEdge: !!t.navigator.userAgent.match(/Edge/g), isSafari: e(), isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(t.navigator.userAgent) } }()); const pt = { name: 'browser', proto: { browser: ct }, static: { browser: ct } }; const ut = { name: 'resize', create: function () { const e = this; F.extend(e, { resize: { resizeHandler: function () { e && !e.destroyed && e.initialized && (e.emit('beforeResize'), e.emit('resize')) }, orientationChangeHandler: function () { e && !e.destroyed && e.initialized && e.emit('orientationchange') } } }) }, on: { init: function () { const e = this; t.addEventListener('resize', e.resize.resizeHandler), t.addEventListener('orientationchange', e.resize.orientationChangeHandler) }, destroy: function () { const e = this; t.removeEventListener('resize', e.resize.resizeHandler), t.removeEventListener('orientationchange', e.resize.orientationChangeHandler) } } }; var ht = { func: t.MutationObserver || t.WebkitMutationObserver, attach: function (e, a) { void 0 === a && (a = {}); const s = this; const i = ht.func; const n = new i(function (e) { if (e.length !== 1) { const a = function () { s.emit('observerUpdate', e[0]) }; t.requestAnimationFrame ? t.requestAnimationFrame(a) : t.setTimeout(a, 0) } else s.emit('observerUpdate', e[0]) }); n.observe(e, { attributes: typeof a.attributes === 'undefined' || a.attributes, childList: typeof a.childList === 'undefined' || a.childList, characterData: typeof a.characterData === 'undefined' || a.characterData }), s.observer.observers.push(n) }, init: function () { const e = this; if (W.observer && e.params.observer) { if (e.params.observeParents) for (let t = e.$el.parents(), a = 0; a < t.length; a += 1)e.observer.attach(t[a]); e.observer.attach(e.$el[0], { childList: e.params.observeSlideChildren }), e.observer.attach(e.$wrapperEl[0], { attributes: !1 }) } }, destroy: function () { const e = this; e.observer.observers.forEach(function (e) { e.disconnect() }), e.observer.observers = [] } }; const ft = { name: 'observer', params: { observer: !1, observeParents: !1, observeSlideChildren: !1 }, create: function () { const e = this; F.extend(e, { observer: { init: ht.init.bind(e), attach: ht.attach.bind(e), destroy: ht.destroy.bind(e), observers: [] } }) }, on: { init: function () { const e = this; e.observer.init() }, destroy: function () { const e = this; e.observer.destroy() } } }; const mt = { update: function (e) { const t = this; const a = t.params; const s = a.slidesPerView; const i = a.slidesPerGroup; const n = a.centeredSlides; const r = t.params.virtual; const o = r.addSlidesBefore; const l = r.addSlidesAfter; const d = t.virtual; const c = d.from; const p = d.to; const u = d.slides; const h = d.slidesGrid; const f = d.renderSlide; const m = d.offset; t.updateActiveIndex(); let v; let g; let b; const w = t.activeIndex || 0; v = t.rtlTranslate ? 'right' : t.isHorizontal() ? 'left' : 'top', n ? (g = Math.floor(s / 2) + i + o, b = Math.floor(s / 2) + i + l) : (g = s + (i - 1) + o, b = i + l); const y = Math.max((w || 0) - b, 0); const x = Math.min((w || 0) + g, u.length - 1); const E = (t.slidesGrid[y] || 0) - (t.slidesGrid[0] || 0); function T () { t.updateSlides(), t.updateProgress(), t.updateSlidesClasses(), t.lazy && t.params.lazy.enabled && t.lazy.load() } if (F.extend(t.virtual, { from: y, to: x, offset: E, slidesGrid: t.slidesGrid }), c === y && p === x && !e) return t.slidesGrid !== h && E !== m && t.slides.css(v, E + 'px'), void t.updateProgress(); if (t.params.virtual.renderExternal) return t.params.virtual.renderExternal.call(t, { offset: E, from: y, to: x, slides: (function () { for (var e = [], t = y; t <= x; t += 1)e.push(u[t]); return e }()) }), void T(); const S = []; const C = []; if (e)t.$wrapperEl.find('.' + t.params.slideClass).remove(); else for (let M = c; M <= p; M += 1)(M < y || M > x) && t.$wrapperEl.find('.' + t.params.slideClass + '[data-swiper-slide-index="' + M + '"]').remove(); for (let $ = 0; $ < u.length; $ += 1)$ >= y && $ <= x && (typeof p === 'undefined' || e ? C.push($) : ($ > p && C.push($), $ < c && S.push($))); C.forEach(function (e) { t.$wrapperEl.append(f(u[e], e)) }), S.sort(function (e, t) { return t - e }).forEach(function (e) { t.$wrapperEl.prepend(f(u[e], e)) }), t.$wrapperEl.children('.swiper-slide').css(v, E + 'px'), T() }, renderSlide: function (e, t) { const a = this; const i = a.params.virtual; if (i.cache && a.virtual.cache[t]) return a.virtual.cache[t]; const n = i.renderSlide ? s(i.renderSlide.call(a, e, t)) : s('<div class="' + a.params.slideClass + '" data-swiper-slide-index="' + t + '">' + e + '</div>'); return n.attr('data-swiper-slide-index') || n.attr('data-swiper-slide-index', t), i.cache && (a.virtual.cache[t] = n), n }, appendSlide: function (e) { const t = this; if (typeof e === 'object' && 'length' in e) for (let a = 0; a < e.length; a += 1)e[a] && t.virtual.slides.push(e[a]); else t.virtual.slides.push(e); t.virtual.update(!0) }, prependSlide: function (e) { const t = this; const a = t.activeIndex; let s = a + 1; let i = 1; if (Array.isArray(e)) { for (let n = 0; n < e.length; n += 1)e[n] && t.virtual.slides.unshift(e[n]); s = a + e.length, i = e.length } else t.virtual.slides.unshift(e); if (t.params.virtual.cache) { const r = t.virtual.cache; const o = {}; Object.keys(r).forEach(function (e) { const t = r[e]; const a = t.attr('data-swiper-slide-index'); a && t.attr('data-swiper-slide-index', parseInt(a, 10) + 1), o[parseInt(e, 10) + i] = t }), t.virtual.cache = o }t.virtual.update(!0), t.slideTo(s, 0) }, removeSlide: function (e) { const t = this; if (typeof e !== 'undefined' && e !== null) { let a = t.activeIndex; if (Array.isArray(e)) for (let s = e.length - 1; s >= 0; s -= 1)t.virtual.slides.splice(e[s], 1), t.params.virtual.cache && delete t.virtual.cache[e[s]], e[s] < a && (a -= 1), a = Math.max(a, 0); else t.virtual.slides.splice(e, 1), t.params.virtual.cache && delete t.virtual.cache[e], e < a && (a -= 1), a = Math.max(a, 0); t.virtual.update(!0), t.slideTo(a, 0) } }, removeAllSlides: function () { const e = this; e.virtual.slides = [], e.params.virtual.cache && (e.virtual.cache = {}), e.virtual.update(!0), e.slideTo(0, 0) } }; const vt = { name: 'virtual', params: { virtual: { enabled: !1, slides: [], cache: !0, renderSlide: null, renderExternal: null, addSlidesBefore: 0, addSlidesAfter: 0 } }, create: function () { const e = this; F.extend(e, { virtual: { update: mt.update.bind(e), appendSlide: mt.appendSlide.bind(e), prependSlide: mt.prependSlide.bind(e), removeSlide: mt.removeSlide.bind(e), removeAllSlides: mt.removeAllSlides.bind(e), renderSlide: mt.renderSlide.bind(e), slides: e.params.virtual.slides, cache: {} } }) }, on: { beforeInit: function () { const e = this; if (e.params.virtual.enabled) { e.classNames.push(e.params.containerModifierClass + 'virtual'); const t = { watchSlidesProgress: !0 }; F.extend(e.params, t), F.extend(e.originalParams, t), e.params.initialSlide || e.virtual.update() } }, setTranslate: function () { const e = this; e.params.virtual.enabled && e.virtual.update() } } }; const gt = { handle: function (a) { const s = this; const i = s.rtlTranslate; let n = a; n.originalEvent && (n = n.originalEvent); const r = n.keyCode || n.charCode; if (!s.allowSlideNext && (s.isHorizontal() && r === 39 || s.isVertical() && r === 40 || r === 34)) return !1; if (!s.allowSlidePrev && (s.isHorizontal() && r === 37 || s.isVertical() && r === 38 || r === 33)) return !1; if (!(n.shiftKey || n.altKey || n.ctrlKey || n.metaKey) && (!e.activeElement || !e.activeElement.nodeName || e.activeElement.nodeName.toLowerCase() !== 'input' && e.activeElement.nodeName.toLowerCase() !== 'textarea')) { if (s.params.keyboard.onlyInViewport && (r === 33 || r === 34 || r === 37 || r === 39 || r === 38 || r === 40)) { let o = !1; if (s.$el.parents('.' + s.params.slideClass).length > 0 && s.$el.parents('.' + s.params.slideActiveClass).length === 0) return; const l = t.innerWidth; const d = t.innerHeight; const c = s.$el.offset(); i && (c.left -= s.$el[0].scrollLeft); for (let p = [[c.left, c.top], [c.left + s.width, c.top], [c.left, c.top + s.height], [c.left + s.width, c.top + s.height]], u = 0; u < p.length; u += 1) { const h = p[u]; h[0] >= 0 && h[0] <= l && h[1] >= 0 && h[1] <= d && (o = !0) } if (!o) return }s.isHorizontal() ? (r !== 33 && r !== 34 && r !== 37 && r !== 39 || (n.preventDefault ? n.preventDefault() : n.returnValue = !1), (r !== 34 && r !== 39 || i) && (r !== 33 && r !== 37 || !i) || s.slideNext(), (r !== 33 && r !== 37 || i) && (r !== 34 && r !== 39 || !i) || s.slidePrev()) : (r !== 33 && r !== 34 && r !== 38 && r !== 40 || (n.preventDefault ? n.preventDefault() : n.returnValue = !1), r !== 34 && r !== 40 || s.slideNext(), r !== 33 && r !== 38 || s.slidePrev()), s.emit('keyPress', r) } }, enable: function () { const t = this; t.keyboard.enabled || (s(e).on('keydown', t.keyboard.handle), t.keyboard.enabled = !0) }, disable: function () { const t = this; t.keyboard.enabled && (s(e).off('keydown', t.keyboard.handle), t.keyboard.enabled = !1) } }; const bt = { name: 'keyboard', params: { keyboard: { enabled: !1, onlyInViewport: !0 } }, create: function () { const e = this; F.extend(e, { keyboard: { enabled: !1, enable: gt.enable.bind(e), disable: gt.disable.bind(e), handle: gt.handle.bind(e) } }) }, on: { init: function () { const e = this; e.params.keyboard.enabled && e.keyboard.enable() }, destroy: function () { const e = this; e.keyboard.enabled && e.keyboard.disable() } } }; function wt () { const t = 'onwheel'; let a = t in e; if (!a) { const s = e.createElement('div'); s.setAttribute(t, 'return;'), a = typeof s[t] === 'function' } return !a && e.implementation && e.implementation.hasFeature && !0 !== e.implementation.hasFeature('', '') && (a = e.implementation.hasFeature('Events.wheel', '3.0')), a } var yt = { lastScrollTime: F.now(), lastEventBeforeSnap: void 0, recentWheelEvents: [], event: function () { return t.navigator.userAgent.indexOf('firefox') > -1 ? 'DOMMouseScroll' : wt() ? 'wheel' : 'mousewheel' }, normalize: function (e) { const t = 10; const a = 40; const s = 800; let i = 0; let n = 0; let r = 0; let o = 0; return 'detail' in e && (n = e.detail), 'wheelDelta' in e && (n = -e.wheelDelta / 120), 'wheelDeltaY' in e && (n = -e.wheelDeltaY / 120), 'wheelDeltaX' in e && (i = -e.wheelDeltaX / 120), 'axis' in e && e.axis === e.HORIZONTAL_AXIS && (i = n, n = 0), r = i * t, o = n * t, 'deltaY' in e && (o = e.deltaY), 'deltaX' in e && (r = e.deltaX), e.shiftKey && !r && (r = o, o = 0), (r || o) && e.deltaMode && (e.deltaMode === 1 ? (r *= a, o *= a) : (r *= s, o *= s)), r && !i && (i = r < 1 ? -1 : 1), o && !n && (n = o < 1 ? -1 : 1), { spinX: i, spinY: n, pixelX: r, pixelY: o } }, handleMouseEnter: function () { const e = this; e.mouseEntered = !0 }, handleMouseLeave: function () { const e = this; e.mouseEntered = !1 }, handle: function (e) { let t = e; const a = this; const i = a.params.mousewheel; a.params.cssMode && t.preventDefault(); let n = a.$el; if (a.params.mousewheel.eventsTarged !== 'container' && (n = s(a.params.mousewheel.eventsTarged)), !a.mouseEntered && !n[0].contains(t.target) && !i.releaseOnEdges) return !0; t.originalEvent && (t = t.originalEvent); let r = 0; const o = a.rtlTranslate ? -1 : 1; const l = yt.normalize(t); if (i.forceToAxis) if (a.isHorizontal()) { if (!(Math.abs(l.pixelX) > Math.abs(l.pixelY))) return !0; r = l.pixelX * o } else { if (!(Math.abs(l.pixelY) > Math.abs(l.pixelX))) return !0; r = l.pixelY } else r = Math.abs(l.pixelX) > Math.abs(l.pixelY) ? -l.pixelX * o : -l.pixelY; if (r === 0) return !0; if (i.invert && (r = -r), a.params.freeMode) { const d = { time: F.now(), delta: Math.abs(r), direction: Math.sign(r) }; const c = a.mousewheel; const p = c.lastEventBeforeSnap; const u = p && d.time < p.time + 500 && d.delta <= p.delta && d.direction === p.direction; if (!u) { a.mousewheel.lastEventBeforeSnap = void 0, a.params.loop && a.loopFix(); let h = a.getTranslate() + r * i.sensitivity; const f = a.isBeginning; const m = a.isEnd; if (h >= a.minTranslate() && (h = a.minTranslate()), h <= a.maxTranslate() && (h = a.maxTranslate()), a.setTransition(0), a.setTranslate(h), a.updateProgress(), a.updateActiveIndex(), a.updateSlidesClasses(), (!f && a.isBeginning || !m && a.isEnd) && a.updateSlidesClasses(), a.params.freeModeSticky) { clearTimeout(a.mousewheel.timeout), a.mousewheel.timeout = void 0; const v = a.mousewheel.recentWheelEvents; v.length >= 15 && v.shift(); const g = v.length ? v[v.length - 1] : void 0; const b = v[0]; if (v.push(d), g && (d.delta > g.delta || d.direction !== g.direction))v.splice(0); else if (v.length >= 15 && d.time - b.time < 500 && b.delta - d.delta >= 1 && d.delta <= 6) { const w = r > 0 ? 0.8 : 0.2; a.mousewheel.lastEventBeforeSnap = d, v.splice(0), a.mousewheel.timeout = F.nextTick(function () { a.slideToClosest(a.params.speed, !0, void 0, w) }, 0) }a.mousewheel.timeout || (a.mousewheel.timeout = F.nextTick(function () { const e = 0.5; a.mousewheel.lastEventBeforeSnap = d, v.splice(0), a.slideToClosest(a.params.speed, !0, void 0, e) }, 500)) } if (u || a.emit('scroll', t), a.params.autoplay && a.params.autoplayDisableOnInteraction && a.autoplay.stop(), h === a.minTranslate() || h === a.maxTranslate()) return !0 } } else { const y = { time: F.now(), delta: Math.abs(r), direction: Math.sign(r), raw: e }; const x = a.mousewheel.recentWheelEvents; x.length >= 2 && x.shift(); const E = x.length ? x[x.length - 1] : void 0; if (x.push(y), E ? (y.direction !== E.direction || y.delta > E.delta) && a.mousewheel.animateSlider(y) : a.mousewheel.animateSlider(y), a.mousewheel.releaseScroll(y)) return !0 } return t.preventDefault ? t.preventDefault() : t.returnValue = !1, !1 }, animateSlider: function (e) { const a = this; return e.delta >= 6 && F.now() - a.mousewheel.lastScrollTime < 60 || (e.direction < 0 ? a.isEnd && !a.params.loop || a.animating || (a.slideNext(), a.emit('scroll', e.raw)) : a.isBeginning && !a.params.loop || a.animating || (a.slidePrev(), a.emit('scroll', e.raw)), a.mousewheel.lastScrollTime = (new t.Date()).getTime(), !1) }, releaseScroll: function (e) { const t = this; const a = t.params.mousewheel; if (e.direction < 0) { if (t.isEnd && !t.params.loop && a.releaseOnEdges) return !0 } else if (t.isBeginning && !t.params.loop && a.releaseOnEdges) return !0; return !1 }, enable: function () { const e = this; const t = yt.event(); if (e.params.cssMode) return e.wrapperEl.removeEventListener(t, e.mousewheel.handle), !0; if (!t) return !1; if (e.mousewheel.enabled) return !1; let a = e.$el; return e.params.mousewheel.eventsTarged !== 'container' && (a = s(e.params.mousewheel.eventsTarged)), a.on('mouseenter', e.mousewheel.handleMouseEnter), a.on('mouseleave', e.mousewheel.handleMouseLeave), a.on(t, e.mousewheel.handle), e.mousewheel.enabled = !0, !0 }, disable: function () { const e = this; const t = yt.event(); if (e.params.cssMode) return e.wrapperEl.addEventListener(t, e.mousewheel.handle), !0; if (!t) return !1; if (!e.mousewheel.enabled) return !1; let a = e.$el; return e.params.mousewheel.eventsTarged !== 'container' && (a = s(e.params.mousewheel.eventsTarged)), a.off(t, e.mousewheel.handle), e.mousewheel.enabled = !1, !0 } }; const xt = { name: 'mousewheel', params: { mousewheel: { enabled: !1, releaseOnEdges: !1, invert: !1, forceToAxis: !1, sensitivity: 1, eventsTarged: 'container' } }, create: function () { const e = this; F.extend(e, { mousewheel: { enabled: !1, enable: yt.enable.bind(e), disable: yt.disable.bind(e), handle: yt.handle.bind(e), handleMouseEnter: yt.handleMouseEnter.bind(e), handleMouseLeave: yt.handleMouseLeave.bind(e), animateSlider: yt.animateSlider.bind(e), releaseScroll: yt.releaseScroll.bind(e), lastScrollTime: F.now(), lastEventBeforeSnap: void 0, recentWheelEvents: [] } }) }, on: { init: function () { const e = this; !e.params.mousewheel.enabled && e.params.cssMode && e.mousewheel.disable(), e.params.mousewheel.enabled && e.mousewheel.enable() }, destroy: function () { const e = this; e.params.cssMode && e.mousewheel.enable(), e.mousewheel.enabled && e.mousewheel.disable() } } }; const Et = { update: function () { const e = this; const t = e.params.navigation; if (!e.params.loop) { const a = e.navigation; const s = a.$nextEl; const i = a.$prevEl; i && i.length > 0 && (e.isBeginning ? i.addClass(t.disabledClass) : i.removeClass(t.disabledClass), i[e.params.watchOverflow && e.isLocked ? 'addClass' : 'removeClass'](t.lockClass)), s && s.length > 0 && (e.isEnd ? s.addClass(t.disabledClass) : s.removeClass(t.disabledClass), s[e.params.watchOverflow && e.isLocked ? 'addClass' : 'removeClass'](t.lockClass)) } }, onPrevClick: function (e) { const t = this; e.preventDefault(), t.isBeginning && !t.params.loop || t.slidePrev() }, onNextClick: function (e) { const t = this; e.preventDefault(), t.isEnd && !t.params.loop || t.slideNext() }, init: function () { let e; let t; const a = this; const i = a.params.navigation; (i.nextEl || i.prevEl) && (i.nextEl && (e = s(i.nextEl), a.params.uniqueNavElements && typeof i.nextEl === 'string' && e.length > 1 && a.$el.find(i.nextEl).length === 1 && (e = a.$el.find(i.nextEl))), i.prevEl && (t = s(i.prevEl), a.params.uniqueNavElements && typeof i.prevEl === 'string' && t.length > 1 && a.$el.find(i.prevEl).length === 1 && (t = a.$el.find(i.prevEl))), e && e.length > 0 && e.on('click', a.navigation.onNextClick), t && t.length > 0 && t.on('click', a.navigation.onPrevClick), F.extend(a.navigation, { $nextEl: e, nextEl: e && e[0], $prevEl: t, prevEl: t && t[0] })) }, destroy: function () { const e = this; const t = e.navigation; const a = t.$nextEl; const s = t.$prevEl; a && a.length && (a.off('click', e.navigation.onNextClick), a.removeClass(e.params.navigation.disabledClass)), s && s.length && (s.off('click', e.navigation.onPrevClick), s.removeClass(e.params.navigation.disabledClass)) } }; const Tt = { name: 'navigation', params: { navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: 'swiper-button-disabled', hiddenClass: 'swiper-button-hidden', lockClass: 'swiper-button-lock' } }, create: function () { const e = this; F.extend(e, { navigation: { init: Et.init.bind(e), update: Et.update.bind(e), destroy: Et.destroy.bind(e), onNextClick: Et.onNextClick.bind(e), onPrevClick: Et.onPrevClick.bind(e) } }) }, on: { init: function () { const e = this; e.navigation.init(), e.navigation.update() }, toEdge: function () { const e = this; e.navigation.update() }, fromEdge: function () { const e = this; e.navigation.update() }, destroy: function () { const e = this; e.navigation.destroy() }, click: function (e) { let t; const a = this; const i = a.navigation; const n = i.$nextEl; const r = i.$prevEl; !a.params.navigation.hideOnClick || s(e.target).is(r) || s(e.target).is(n) || (n ? t = n.hasClass(a.params.navigation.hiddenClass) : r && (t = r.hasClass(a.params.navigation.hiddenClass)), !0 === t ? a.emit('navigationShow', a) : a.emit('navigationHide', a), n && n.toggleClass(a.params.navigation.hiddenClass), r && r.toggleClass(a.params.navigation.hiddenClass)) } } }; const St = { update: function () { const e = this; const t = e.rtl; const a = e.params.pagination; if (a.el && e.pagination.el && e.pagination.$el && e.pagination.$el.length !== 0) { let i; const n = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length; const r = e.pagination.$el; const o = e.params.loop ? Math.ceil((n - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length; if (e.params.loop ? (i = Math.ceil((e.activeIndex - e.loopedSlides) / e.params.slidesPerGroup), i > n - 1 - 2 * e.loopedSlides && (i -= n - 2 * e.loopedSlides), i > o - 1 && (i -= o), i < 0 && e.params.paginationType !== 'bullets' && (i = o + i)) : i = typeof e.snapIndex !== 'undefined' ? e.snapIndex : e.activeIndex || 0, a.type === 'bullets' && e.pagination.bullets && e.pagination.bullets.length > 0) { let l; let d; let c; const p = e.pagination.bullets; if (a.dynamicBullets && (e.pagination.bulletSize = p.eq(0)[e.isHorizontal() ? 'outerWidth' : 'outerHeight'](!0), r.css(e.isHorizontal() ? 'width' : 'height', e.pagination.bulletSize * (a.dynamicMainBullets + 4) + 'px'), a.dynamicMainBullets > 1 && void 0 !== e.previousIndex && (e.pagination.dynamicBulletIndex += i - e.previousIndex, e.pagination.dynamicBulletIndex > a.dynamicMainBullets - 1 ? e.pagination.dynamicBulletIndex = a.dynamicMainBullets - 1 : e.pagination.dynamicBulletIndex < 0 && (e.pagination.dynamicBulletIndex = 0)), l = i - e.pagination.dynamicBulletIndex, d = l + (Math.min(p.length, a.dynamicMainBullets) - 1), c = (d + l) / 2), p.removeClass(a.bulletActiveClass + ' ' + a.bulletActiveClass + '-next ' + a.bulletActiveClass + '-next-next ' + a.bulletActiveClass + '-prev ' + a.bulletActiveClass + '-prev-prev ' + a.bulletActiveClass + '-main'), r.length > 1)p.each(function (e, t) { const n = s(t); const r = n.index(); r === i && n.addClass(a.bulletActiveClass), a.dynamicBullets && (r >= l && r <= d && n.addClass(a.bulletActiveClass + '-main'), r === l && n.prev().addClass(a.bulletActiveClass + '-prev').prev().addClass(a.bulletActiveClass + '-prev-prev'), r === d && n.next().addClass(a.bulletActiveClass + '-next').next().addClass(a.bulletActiveClass + '-next-next')) }); else { const u = p.eq(i); const h = u.index(); if (u.addClass(a.bulletActiveClass), a.dynamicBullets) { for (var f = p.eq(l), m = p.eq(d), v = l; v <= d; v += 1)p.eq(v).addClass(a.bulletActiveClass + '-main'); if (e.params.loop) if (h >= p.length - a.dynamicMainBullets) { for (let g = a.dynamicMainBullets; g >= 0; g -= 1)p.eq(p.length - g).addClass(a.bulletActiveClass + '-main'); p.eq(p.length - a.dynamicMainBullets - 1).addClass(a.bulletActiveClass + '-prev') } else f.prev().addClass(a.bulletActiveClass + '-prev').prev().addClass(a.bulletActiveClass + '-prev-prev'), m.next().addClass(a.bulletActiveClass + '-next').next().addClass(a.bulletActiveClass + '-next-next'); else f.prev().addClass(a.bulletActiveClass + '-prev').prev().addClass(a.bulletActiveClass + '-prev-prev'), m.next().addClass(a.bulletActiveClass + '-next').next().addClass(a.bulletActiveClass + '-next-next') } } if (a.dynamicBullets) { const b = Math.min(p.length, a.dynamicMainBullets + 4); const w = (e.pagination.bulletSize * b - e.pagination.bulletSize) / 2 - c * e.pagination.bulletSize; const y = t ? 'right' : 'left'; p.css(e.isHorizontal() ? y : 'top', w + 'px') } } if (a.type === 'fraction' && (r.find('.' + a.currentClass).text(a.formatFractionCurrent(i + 1)), r.find('.' + a.totalClass).text(a.formatFractionTotal(o))), a.type === 'progressbar') { let x; x = a.progressbarOpposite ? e.isHorizontal() ? 'vertical' : 'horizontal' : e.isHorizontal() ? 'horizontal' : 'vertical'; const E = (i + 1) / o; let T = 1; let S = 1; x === 'horizontal' ? T = E : S = E, r.find('.' + a.progressbarFillClass).transform('translate3d(0,0,0) scaleX(' + T + ') scaleY(' + S + ')').transition(e.params.speed) }a.type === 'custom' && a.renderCustom ? (r.html(a.renderCustom(e, i + 1, o)), e.emit('paginationRender', e, r[0])) : e.emit('paginationUpdate', e, r[0]), r[e.params.watchOverflow && e.isLocked ? 'addClass' : 'removeClass'](a.lockClass) } }, render: function () { const e = this; const t = e.params.pagination; if (t.el && e.pagination.el && e.pagination.$el && e.pagination.$el.length !== 0) { const a = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length; const s = e.pagination.$el; let i = ''; if (t.type === 'bullets') { for (let n = e.params.loop ? Math.ceil((a - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length, r = 0; r < n; r += 1)t.renderBullet ? i += t.renderBullet.call(e, r, t.bulletClass) : i += '<' + t.bulletElement + ' class="' + t.bulletClass + '"></' + t.bulletElement + '>'; s.html(i), e.pagination.bullets = s.find('.' + t.bulletClass) }t.type === 'fraction' && (i = t.renderFraction ? t.renderFraction.call(e, t.currentClass, t.totalClass) : '<span class="' + t.currentClass + '"></span> / <span class="' + t.totalClass + '"></span>', s.html(i)), t.type === 'progressbar' && (i = t.renderProgressbar ? t.renderProgressbar.call(e, t.progressbarFillClass) : '<span class="' + t.progressbarFillClass + '"></span>', s.html(i)), t.type !== 'custom' && e.emit('paginationRender', e.pagination.$el[0]) } }, init: function () { const e = this; const t = e.params.pagination; if (t.el) { let a = s(t.el); a.length !== 0 && (e.params.uniqueNavElements && typeof t.el === 'string' && a.length > 1 && e.$el.find(t.el).length === 1 && (a = e.$el.find(t.el)), t.type === 'bullets' && t.clickable && a.addClass(t.clickableClass), a.addClass(t.modifierClass + t.type), t.type === 'bullets' && t.dynamicBullets && (a.addClass('' + t.modifierClass + t.type + '-dynamic'), e.pagination.dynamicBulletIndex = 0, t.dynamicMainBullets < 1 && (t.dynamicMainBullets = 1)), t.type === 'progressbar' && t.progressbarOpposite && a.addClass(t.progressbarOppositeClass), t.clickable && a.on('click', '.' + t.bulletClass, function (t) { t.preventDefault(); let a = s(this).index() * e.params.slidesPerGroup; e.params.loop && (a += e.loopedSlides), e.slideTo(a) }), F.extend(e.pagination, { $el: a, el: a[0] })) } }, destroy: function () { const e = this; const t = e.params.pagination; if (t.el && e.pagination.el && e.pagination.$el && e.pagination.$el.length !== 0) { const a = e.pagination.$el; a.removeClass(t.hiddenClass), a.removeClass(t.modifierClass + t.type), e.pagination.bullets && e.pagination.bullets.removeClass(t.bulletActiveClass), t.clickable && a.off('click', '.' + t.bulletClass) } } }; const Ct = { name: 'pagination', params: { pagination: { el: null, bulletElement: 'span', clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: 'bullets', dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent: function (e) { return e }, formatFractionTotal: function (e) { return e }, bulletClass: 'swiper-pagination-bullet', bulletActiveClass: 'swiper-pagination-bullet-active', modifierClass: 'swiper-pagination-', currentClass: 'swiper-pagination-current', totalClass: 'swiper-pagination-total', hiddenClass: 'swiper-pagination-hidden', progressbarFillClass: 'swiper-pagination-progressbar-fill', progressbarOppositeClass: 'swiper-pagination-progressbar-opposite', clickableClass: 'swiper-pagination-clickable', lockClass: 'swiper-pagination-lock' } }, create: function () { const e = this; F.extend(e, { pagination: { init: St.init.bind(e), render: St.render.bind(e), update: St.update.bind(e), destroy: St.destroy.bind(e), dynamicBulletIndex: 0 } }) }, on: { init: function () { const e = this; e.pagination.init(), e.pagination.render(), e.pagination.update() }, activeIndexChange: function () { const e = this; e.params.loop ? e.pagination.update() : typeof e.snapIndex === 'undefined' && e.pagination.update() }, snapIndexChange: function () { const e = this; e.params.loop || e.pagination.update() }, slidesLengthChange: function () { const e = this; e.params.loop && (e.pagination.render(), e.pagination.update()) }, snapGridLengthChange: function () { const e = this; e.params.loop || (e.pagination.render(), e.pagination.update()) }, destroy: function () { const e = this; e.pagination.destroy() }, click: function (e) { const t = this; if (t.params.pagination.el && t.params.pagination.hideOnClick && t.pagination.$el.length > 0 && !s(e.target).hasClass(t.params.pagination.bulletClass)) { const a = t.pagination.$el.hasClass(t.params.pagination.hiddenClass); !0 === a ? t.emit('paginationShow', t) : t.emit('paginationHide', t), t.pagination.$el.toggleClass(t.params.pagination.hiddenClass) } } } }; const Mt = { setTranslate: function () { const e = this; if (e.params.scrollbar.el && e.scrollbar.el) { const t = e.scrollbar; const a = e.rtlTranslate; const s = e.progress; const i = t.dragSize; const n = t.trackSize; const r = t.$dragEl; const o = t.$el; const l = e.params.scrollbar; let d = i; let c = (n - i) * s; a ? (c = -c, c > 0 ? (d = i - c, c = 0) : -c + i > n && (d = n + c)) : c < 0 ? (d = i + c, c = 0) : c + i > n && (d = n - c), e.isHorizontal() ? (r.transform('translate3d(' + c + 'px, 0, 0)'), r[0].style.width = d + 'px') : (r.transform('translate3d(0px, ' + c + 'px, 0)'), r[0].style.height = d + 'px'), l.hide && (clearTimeout(e.scrollbar.timeout), o[0].style.opacity = 1, e.scrollbar.timeout = setTimeout(function () { o[0].style.opacity = 0, o.transition(400) }, 1e3)) } }, setTransition: function (e) { const t = this; t.params.scrollbar.el && t.scrollbar.el && t.scrollbar.$dragEl.transition(e) }, updateSize: function () { const e = this; if (e.params.scrollbar.el && e.scrollbar.el) { const t = e.scrollbar; const a = t.$dragEl; const s = t.$el; a[0].style.width = '', a[0].style.height = ''; let i; const n = e.isHorizontal() ? s[0].offsetWidth : s[0].offsetHeight; const r = e.size / e.virtualSize; const o = r * (n / e.size); i = e.params.scrollbar.dragSize === 'auto' ? n * r : parseInt(e.params.scrollbar.dragSize, 10), e.isHorizontal() ? a[0].style.width = i + 'px' : a[0].style.height = i + 'px', s[0].style.display = r >= 1 ? 'none' : '', e.params.scrollbar.hide && (s[0].style.opacity = 0), F.extend(t, { trackSize: n, divider: r, moveDivider: o, dragSize: i }), t.$el[e.params.watchOverflow && e.isLocked ? 'addClass' : 'removeClass'](e.params.scrollbar.lockClass) } }, getPointerPosition: function (e) { const t = this; return t.isHorizontal() ? e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX : e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY }, setDragPosition: function (e) { let t; const a = this; const s = a.scrollbar; const i = a.rtlTranslate; const n = s.$el; const r = s.dragSize; const o = s.trackSize; const l = s.dragStartPos; t = (s.getPointerPosition(e) - n.offset()[a.isHorizontal() ? 'left' : 'top'] - (l !== null ? l : r / 2)) / (o - r), t = Math.max(Math.min(t, 1), 0), i && (t = 1 - t); const d = a.minTranslate() + (a.maxTranslate() - a.minTranslate()) * t; a.updateProgress(d), a.setTranslate(d), a.updateActiveIndex(), a.updateSlidesClasses() }, onDragStart: function (e) { const t = this; const a = t.params.scrollbar; const s = t.scrollbar; const i = t.$wrapperEl; const n = s.$el; const r = s.$dragEl; t.scrollbar.isTouched = !0, t.scrollbar.dragStartPos = e.target === r[0] || e.target === r ? s.getPointerPosition(e) - e.target.getBoundingClientRect()[t.isHorizontal() ? 'left' : 'top'] : null, e.preventDefault(), e.stopPropagation(), i.transition(100), r.transition(100), s.setDragPosition(e), clearTimeout(t.scrollbar.dragTimeout), n.transition(0), a.hide && n.css('opacity', 1), t.params.cssMode && t.$wrapperEl.css('scroll-snap-type', 'none'), t.emit('scrollbarDragStart', e) }, onDragMove: function (e) { const t = this; const a = t.scrollbar; const s = t.$wrapperEl; const i = a.$el; const n = a.$dragEl; t.scrollbar.isTouched && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, a.setDragPosition(e), s.transition(0), i.transition(0), n.transition(0), t.emit('scrollbarDragMove', e)) }, onDragEnd: function (e) { const t = this; const a = t.params.scrollbar; const s = t.scrollbar; const i = t.$wrapperEl; const n = s.$el; t.scrollbar.isTouched && (t.scrollbar.isTouched = !1, t.params.cssMode && (t.$wrapperEl.css('scroll-snap-type', ''), i.transition('')), a.hide && (clearTimeout(t.scrollbar.dragTimeout), t.scrollbar.dragTimeout = F.nextTick(function () { n.css('opacity', 0), n.transition(400) }, 1e3)), t.emit('scrollbarDragEnd', e), a.snapOnRelease && t.slideToClosest()) }, enableDraggable: function () { const t = this; if (t.params.scrollbar.el) { const a = t.scrollbar; const s = t.touchEventsTouch; const i = t.touchEventsDesktop; const n = t.params; const r = a.$el; const o = r[0]; const l = !(!W.passiveListener || !n.passiveListeners) && { passive: !1, capture: !1 }; const d = !(!W.passiveListener || !n.passiveListeners) && { passive: !0, capture: !1 }; W.touch ? (o.addEventListener(s.start, t.scrollbar.onDragStart, l), o.addEventListener(s.move, t.scrollbar.onDragMove, l), o.addEventListener(s.end, t.scrollbar.onDragEnd, d)) : (o.addEventListener(i.start, t.scrollbar.onDragStart, l), e.addEventListener(i.move, t.scrollbar.onDragMove, l), e.addEventListener(i.end, t.scrollbar.onDragEnd, d)) } }, disableDraggable: function () { const t = this; if (t.params.scrollbar.el) { const a = t.scrollbar; const s = t.touchEventsTouch; const i = t.touchEventsDesktop; const n = t.params; const r = a.$el; const o = r[0]; const l = !(!W.passiveListener || !n.passiveListeners) && { passive: !1, capture: !1 }; const d = !(!W.passiveListener || !n.passiveListeners) && { passive: !0, capture: !1 }; W.touch ? (o.removeEventListener(s.start, t.scrollbar.onDragStart, l), o.removeEventListener(s.move, t.scrollbar.onDragMove, l), o.removeEventListener(s.end, t.scrollbar.onDragEnd, d)) : (o.removeEventListener(i.start, t.scrollbar.onDragStart, l), e.removeEventListener(i.move, t.scrollbar.onDragMove, l), e.removeEventListener(i.end, t.scrollbar.onDragEnd, d)) } }, init: function () { const e = this; if (e.params.scrollbar.el) { const t = e.scrollbar; const a = e.$el; const i = e.params.scrollbar; let n = s(i.el); e.params.uniqueNavElements && typeof i.el === 'string' && n.length > 1 && a.find(i.el).length === 1 && (n = a.find(i.el)); let r = n.find('.' + e.params.scrollbar.dragClass); r.length === 0 && (r = s('<div class="' + e.params.scrollbar.dragClass + '"></div>'), n.append(r)), F.extend(t, { $el: n, el: n[0], $dragEl: r, dragEl: r[0] }), i.draggable && t.enableDraggable() } }, destroy: function () { const e = this; e.scrollbar.disableDraggable() } }; const $t = { name: 'scrollbar', params: { scrollbar: { el: null, dragSize: 'auto', hide: !1, draggable: !1, snapOnRelease: !0, lockClass: 'swiper-scrollbar-lock', dragClass: 'swiper-scrollbar-drag' } }, create: function () { const e = this; F.extend(e, { scrollbar: { init: Mt.init.bind(e), destroy: Mt.destroy.bind(e), updateSize: Mt.updateSize.bind(e), setTranslate: Mt.setTranslate.bind(e), setTransition: Mt.setTransition.bind(e), enableDraggable: Mt.enableDraggable.bind(e), disableDraggable: Mt.disableDraggable.bind(e), setDragPosition: Mt.setDragPosition.bind(e), getPointerPosition: Mt.getPointerPosition.bind(e), onDragStart: Mt.onDragStart.bind(e), onDragMove: Mt.onDragMove.bind(e), onDragEnd: Mt.onDragEnd.bind(e), isTouched: !1, timeout: null, dragTimeout: null } }) }, on: { init: function () { const e = this; e.scrollbar.init(), e.scrollbar.updateSize(), e.scrollbar.setTranslate() }, update: function () { const e = this; e.scrollbar.updateSize() }, resize: function () { const e = this; e.scrollbar.updateSize() }, observerUpdate: function () { const e = this; e.scrollbar.updateSize() }, setTranslate: function () { const e = this; e.scrollbar.setTranslate() }, setTransition: function (e) { const t = this; t.scrollbar.setTransition(e) }, destroy: function () { const e = this; e.scrollbar.destroy() } } }; const Pt = { setTransform: function (e, t) { const a = this; const i = a.rtl; const n = s(e); const r = i ? -1 : 1; const o = n.attr('data-swiper-parallax') || '0'; let l = n.attr('data-swiper-parallax-x'); let d = n.attr('data-swiper-parallax-y'); const c = n.attr('data-swiper-parallax-scale'); const p = n.attr('data-swiper-parallax-opacity'); if (l || d ? (l = l || '0', d = d || '0') : a.isHorizontal() ? (l = o, d = '0') : (d = o, l = '0'), l = l.indexOf('%') >= 0 ? parseInt(l, 10) * t * r + '%' : l * t * r + 'px', d = d.indexOf('%') >= 0 ? parseInt(d, 10) * t + '%' : d * t + 'px', typeof p !== 'undefined' && p !== null) { const u = p - (p - 1) * (1 - Math.abs(t)); n[0].style.opacity = u } if (typeof c === 'undefined' || c === null)n.transform('translate3d(' + l + ', ' + d + ', 0px)'); else { const h = c - (c - 1) * (1 - Math.abs(t)); n.transform('translate3d(' + l + ', ' + d + ', 0px) scale(' + h + ')') } }, setTranslate: function () { const e = this; const t = e.$el; const a = e.slides; const i = e.progress; const n = e.snapGrid; t.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(function (t, a) { e.parallax.setTransform(a, i) }), a.each(function (t, a) { let r = a.progress; e.params.slidesPerGroup > 1 && e.params.slidesPerView !== 'auto' && (r += Math.ceil(t / 2) - i * (n.length - 1)), r = Math.min(Math.max(r, -1), 1), s(a).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(function (t, a) { e.parallax.setTransform(a, r) }) }) }, setTransition: function (e) { void 0 === e && (e = this.params.speed); const t = this; const a = t.$el; a.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(function (t, a) { const i = s(a); let n = parseInt(i.attr('data-swiper-parallax-duration'), 10) || e; e === 0 && (n = 0), i.transition(n) }) } }; const kt = { name: 'parallax', params: { parallax: { enabled: !1 } }, create: function () { const e = this; F.extend(e, { parallax: { setTransform: Pt.setTransform.bind(e), setTranslate: Pt.setTranslate.bind(e), setTransition: Pt.setTransition.bind(e) } }) }, on: { beforeInit: function () { const e = this; e.params.parallax.enabled && (e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0) }, init: function () { const e = this; e.params.parallax.enabled && e.parallax.setTranslate() }, setTranslate: function () { const e = this; e.params.parallax.enabled && e.parallax.setTranslate() }, setTransition: function (e) { const t = this; t.params.parallax.enabled && t.parallax.setTransition(e) } } }; var zt = { getDistanceBetweenTouches: function (e) { if (e.targetTouches.length < 2) return 1; const t = e.targetTouches[0].pageX; const a = e.targetTouches[0].pageY; const s = e.targetTouches[1].pageX; const i = e.targetTouches[1].pageY; const n = Math.sqrt(Math.pow(s - t, 2) + Math.pow(i - a, 2)); return n }, onGestureStart: function (e) { const t = this; const a = t.params.zoom; const i = t.zoom; const n = i.gesture; if (i.fakeGestureTouched = !1, i.fakeGestureMoved = !1, !W.gestures) { if (e.type !== 'touchstart' || e.type === 'touchstart' && e.targetTouches.length < 2) return; i.fakeGestureTouched = !0, n.scaleStart = zt.getDistanceBetweenTouches(e) }n.$slideEl && n.$slideEl.length || (n.$slideEl = s(e.target).closest('.swiper-slide'), n.$slideEl.length === 0 && (n.$slideEl = t.slides.eq(t.activeIndex)), n.$imageEl = n.$slideEl.find('img, svg, canvas'), n.$imageWrapEl = n.$imageEl.parent('.' + a.containerClass), n.maxRatio = n.$imageWrapEl.attr('data-swiper-zoom') || a.maxRatio, n.$imageWrapEl.length !== 0) ? (n.$imageEl.transition(0), t.zoom.isScaling = !0) : n.$imageEl = void 0 }, onGestureChange: function (e) { const t = this; const a = t.params.zoom; const s = t.zoom; const i = s.gesture; if (!W.gestures) { if (e.type !== 'touchmove' || e.type === 'touchmove' && e.targetTouches.length < 2) return; s.fakeGestureMoved = !0, i.scaleMove = zt.getDistanceBetweenTouches(e) }i.$imageEl && i.$imageEl.length !== 0 && (W.gestures ? s.scale = e.scale * s.currentScale : s.scale = i.scaleMove / i.scaleStart * s.currentScale, s.scale > i.maxRatio && (s.scale = i.maxRatio - 1 + Math.pow(s.scale - i.maxRatio + 1, 0.5)), s.scale < a.minRatio && (s.scale = a.minRatio + 1 - Math.pow(a.minRatio - s.scale + 1, 0.5)), i.$imageEl.transform('translate3d(0,0,0) scale(' + s.scale + ')')) }, onGestureEnd: function (e) { const t = this; const a = t.params.zoom; const s = t.zoom; const i = s.gesture; if (!W.gestures) { if (!s.fakeGestureTouched || !s.fakeGestureMoved) return; if (e.type !== 'touchend' || e.type === 'touchend' && e.changedTouches.length < 2 && !Ae.android) return; s.fakeGestureTouched = !1, s.fakeGestureMoved = !1 }i.$imageEl && i.$imageEl.length !== 0 && (s.scale = Math.max(Math.min(s.scale, i.maxRatio), a.minRatio), i.$imageEl.transition(t.params.speed).transform('translate3d(0,0,0) scale(' + s.scale + ')'), s.currentScale = s.scale, s.isScaling = !1, s.scale === 1 && (i.$slideEl = void 0)) }, onTouchStart: function (e) { const t = this; const a = t.zoom; const s = a.gesture; const i = a.image; s.$imageEl && s.$imageEl.length !== 0 && (i.isTouched || (Ae.android && e.preventDefault(), i.isTouched = !0, i.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX, i.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY)) }, onTouchMove: function (e) { const t = this; const a = t.zoom; const s = a.gesture; const i = a.image; const n = a.velocity; if (s.$imageEl && s.$imageEl.length !== 0 && (t.allowClick = !1, i.isTouched && s.$slideEl)) { i.isMoved || (i.width = s.$imageEl[0].offsetWidth, i.height = s.$imageEl[0].offsetHeight, i.startX = F.getTranslate(s.$imageWrapEl[0], 'x') || 0, i.startY = F.getTranslate(s.$imageWrapEl[0], 'y') || 0, s.slideWidth = s.$slideEl[0].offsetWidth, s.slideHeight = s.$slideEl[0].offsetHeight, s.$imageWrapEl.transition(0), t.rtl && (i.startX = -i.startX, i.startY = -i.startY)); const r = i.width * a.scale; const o = i.height * a.scale; if (!(r < s.slideWidth && o < s.slideHeight)) { if (i.minX = Math.min(s.slideWidth / 2 - r / 2, 0), i.maxX = -i.minX, i.minY = Math.min(s.slideHeight / 2 - o / 2, 0), i.maxY = -i.minY, i.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX, i.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY, !i.isMoved && !a.isScaling) { if (t.isHorizontal() && (Math.floor(i.minX) === Math.floor(i.startX) && i.touchesCurrent.x < i.touchesStart.x || Math.floor(i.maxX) === Math.floor(i.startX) && i.touchesCurrent.x > i.touchesStart.x)) return void (i.isTouched = !1); if (!t.isHorizontal() && (Math.floor(i.minY) === Math.floor(i.startY) && i.touchesCurrent.y < i.touchesStart.y || Math.floor(i.maxY) === Math.floor(i.startY) && i.touchesCurrent.y > i.touchesStart.y)) return void (i.isTouched = !1) }e.preventDefault(), e.stopPropagation(), i.isMoved = !0, i.currentX = i.touchesCurrent.x - i.touchesStart.x + i.startX, i.currentY = i.touchesCurrent.y - i.touchesStart.y + i.startY, i.currentX < i.minX && (i.currentX = i.minX + 1 - Math.pow(i.minX - i.currentX + 1, 0.8)), i.currentX > i.maxX && (i.currentX = i.maxX - 1 + Math.pow(i.currentX - i.maxX + 1, 0.8)), i.currentY < i.minY && (i.currentY = i.minY + 1 - Math.pow(i.minY - i.currentY + 1, 0.8)), i.currentY > i.maxY && (i.currentY = i.maxY - 1 + Math.pow(i.currentY - i.maxY + 1, 0.8)), n.prevPositionX || (n.prevPositionX = i.touchesCurrent.x), n.prevPositionY || (n.prevPositionY = i.touchesCurrent.y), n.prevTime || (n.prevTime = Date.now()), n.x = (i.touchesCurrent.x - n.prevPositionX) / (Date.now() - n.prevTime) / 2, n.y = (i.touchesCurrent.y - n.prevPositionY) / (Date.now() - n.prevTime) / 2, Math.abs(i.touchesCurrent.x - n.prevPositionX) < 2 && (n.x = 0), Math.abs(i.touchesCurrent.y - n.prevPositionY) < 2 && (n.y = 0), n.prevPositionX = i.touchesCurrent.x, n.prevPositionY = i.touchesCurrent.y, n.prevTime = Date.now(), s.$imageWrapEl.transform('translate3d(' + i.currentX + 'px, ' + i.currentY + 'px,0)') } } }, onTouchEnd: function () { const e = this; const t = e.zoom; const a = t.gesture; const s = t.image; const i = t.velocity; if (a.$imageEl && a.$imageEl.length !== 0) { if (!s.isTouched || !s.isMoved) return s.isTouched = !1, void (s.isMoved = !1); s.isTouched = !1, s.isMoved = !1; let n = 300; let r = 300; const o = i.x * n; const l = s.currentX + o; const d = i.y * r; const c = s.currentY + d; i.x !== 0 && (n = Math.abs((l - s.currentX) / i.x)), i.y !== 0 && (r = Math.abs((c - s.currentY) / i.y)); const p = Math.max(n, r); s.currentX = l, s.currentY = c; const u = s.width * t.scale; const h = s.height * t.scale; s.minX = Math.min(a.slideWidth / 2 - u / 2, 0), s.maxX = -s.minX, s.minY = Math.min(a.slideHeight / 2 - h / 2, 0), s.maxY = -s.minY, s.currentX = Math.max(Math.min(s.currentX, s.maxX), s.minX), s.currentY = Math.max(Math.min(s.currentY, s.maxY), s.minY), a.$imageWrapEl.transition(p).transform('translate3d(' + s.currentX + 'px, ' + s.currentY + 'px,0)') } }, onTransitionEnd: function () { const e = this; const t = e.zoom; const a = t.gesture; a.$slideEl && e.previousIndex !== e.activeIndex && (a.$imageEl.transform('translate3d(0,0,0) scale(1)'), a.$imageWrapEl.transform('translate3d(0,0,0)'), t.scale = 1, t.currentScale = 1, a.$slideEl = void 0, a.$imageEl = void 0, a.$imageWrapEl = void 0) }, toggle: function (e) { const t = this; const a = t.zoom; a.scale && a.scale !== 1 ? a.out() : a.in(e) }, in: function (e) { let t; let a; let i; let n; let r; let o; let l; let d; let c; let p; let u; let h; let f; let m; let v; let g; let b; let w; const y = this; const x = y.zoom; const E = y.params.zoom; const T = x.gesture; const S = x.image; (T.$slideEl || (T.$slideEl = y.clickedSlide ? s(y.clickedSlide) : y.slides.eq(y.activeIndex), T.$imageEl = T.$slideEl.find('img, svg, canvas'), T.$imageWrapEl = T.$imageEl.parent('.' + E.containerClass)), T.$imageEl && T.$imageEl.length !== 0) && (T.$slideEl.addClass('' + E.zoomedSlideClass), typeof S.touchesStart.x === 'undefined' && e ? (t = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX, a = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY) : (t = S.touchesStart.x, a = S.touchesStart.y), x.scale = T.$imageWrapEl.attr('data-swiper-zoom') || E.maxRatio, x.currentScale = T.$imageWrapEl.attr('data-swiper-zoom') || E.maxRatio, e ? (b = T.$slideEl[0].offsetWidth, w = T.$slideEl[0].offsetHeight, i = T.$slideEl.offset().left, n = T.$slideEl.offset().top, r = i + b / 2 - t, o = n + w / 2 - a, c = T.$imageEl[0].offsetWidth, p = T.$imageEl[0].offsetHeight, u = c * x.scale, h = p * x.scale, f = Math.min(b / 2 - u / 2, 0), m = Math.min(w / 2 - h / 2, 0), v = -f, g = -m, l = r * x.scale, d = o * x.scale, l < f && (l = f), l > v && (l = v), d < m && (d = m), d > g && (d = g)) : (l = 0, d = 0), T.$imageWrapEl.transition(300).transform('translate3d(' + l + 'px, ' + d + 'px,0)'), T.$imageEl.transition(300).transform('translate3d(0,0,0) scale(' + x.scale + ')')) }, out: function () { const e = this; const t = e.zoom; const a = e.params.zoom; const i = t.gesture; i.$slideEl || (i.$slideEl = e.clickedSlide ? s(e.clickedSlide) : e.slides.eq(e.activeIndex), i.$imageEl = i.$slideEl.find('img, svg, canvas'), i.$imageWrapEl = i.$imageEl.parent('.' + a.containerClass)), i.$imageEl && i.$imageEl.length !== 0 && (t.scale = 1, t.currentScale = 1, i.$imageWrapEl.transition(300).transform('translate3d(0,0,0)'), i.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)'), i.$slideEl.removeClass('' + a.zoomedSlideClass), i.$slideEl = void 0) }, enable: function () { const e = this; const t = e.zoom; if (!t.enabled) { t.enabled = !0; const a = !(e.touchEvents.start !== 'touchstart' || !W.passiveListener || !e.params.passiveListeners) && { passive: !0, capture: !1 }; const s = !W.passiveListener || { passive: !1, capture: !0 }; W.gestures ? (e.$wrapperEl.on('gesturestart', '.swiper-slide', t.onGestureStart, a), e.$wrapperEl.on('gesturechange', '.swiper-slide', t.onGestureChange, a), e.$wrapperEl.on('gestureend', '.swiper-slide', t.onGestureEnd, a)) : e.touchEvents.start === 'touchstart' && (e.$wrapperEl.on(e.touchEvents.start, '.swiper-slide', t.onGestureStart, a), e.$wrapperEl.on(e.touchEvents.move, '.swiper-slide', t.onGestureChange, s), e.$wrapperEl.on(e.touchEvents.end, '.swiper-slide', t.onGestureEnd, a), e.touchEvents.cancel && e.$wrapperEl.on(e.touchEvents.cancel, '.swiper-slide', t.onGestureEnd, a)), e.$wrapperEl.on(e.touchEvents.move, '.' + e.params.zoom.containerClass, t.onTouchMove, s) } }, disable: function () { const e = this; const t = e.zoom; if (t.enabled) { e.zoom.enabled = !1; const a = !(e.touchEvents.start !== 'touchstart' || !W.passiveListener || !e.params.passiveListeners) && { passive: !0, capture: !1 }; const s = !W.passiveListener || { passive: !1, capture: !0 }; W.gestures ? (e.$wrapperEl.off('gesturestart', '.swiper-slide', t.onGestureStart, a), e.$wrapperEl.off('gesturechange', '.swiper-slide', t.onGestureChange, a), e.$wrapperEl.off('gestureend', '.swiper-slide', t.onGestureEnd, a)) : e.touchEvents.start === 'touchstart' && (e.$wrapperEl.off(e.touchEvents.start, '.swiper-slide', t.onGestureStart, a), e.$wrapperEl.off(e.touchEvents.move, '.swiper-slide', t.onGestureChange, s), e.$wrapperEl.off(e.touchEvents.end, '.swiper-slide', t.onGestureEnd, a), e.touchEvents.cancel && e.$wrapperEl.off(e.touchEvents.cancel, '.swiper-slide', t.onGestureEnd, a)), e.$wrapperEl.off(e.touchEvents.move, '.' + e.params.zoom.containerClass, t.onTouchMove, s) } } }; const Lt = { name: 'zoom', params: { zoom: { enabled: !1, maxRatio: 3, minRatio: 1, toggle: !0, containerClass: 'swiper-zoom-container', zoomedSlideClass: 'swiper-slide-zoomed' } }, create: function () { const e = this; const t = { enabled: !1, scale: 1, currentScale: 1, isScaling: !1, gesture: { $slideEl: void 0, slideWidth: void 0, slideHeight: void 0, $imageEl: void 0, $imageWrapEl: void 0, maxRatio: 3 }, image: { isTouched: void 0, isMoved: void 0, currentX: void 0, currentY: void 0, minX: void 0, minY: void 0, maxX: void 0, maxY: void 0, width: void 0, height: void 0, startX: void 0, startY: void 0, touchesStart: {}, touchesCurrent: {} }, velocity: { x: void 0, y: void 0, prevPositionX: void 0, prevPositionY: void 0, prevTime: void 0 } }; 'onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out'.split(' ').forEach(function (a) { t[a] = zt[a].bind(e) }), F.extend(e, { zoom: t }); let a = 1; Object.defineProperty(e.zoom, 'scale', { get: function () { return a }, set: function (t) { if (a !== t) { const s = e.zoom.gesture.$imageEl ? e.zoom.gesture.$imageEl[0] : void 0; const i = e.zoom.gesture.$slideEl ? e.zoom.gesture.$slideEl[0] : void 0; e.emit('zoomChange', t, s, i) }a = t } }) }, on: { init: function () { const e = this; e.params.zoom.enabled && e.zoom.enable() }, destroy: function () { const e = this; e.zoom.disable() }, touchStart: function (e) { const t = this; t.zoom.enabled && t.zoom.onTouchStart(e) }, touchEnd: function (e) { const t = this; t.zoom.enabled && t.zoom.onTouchEnd(e) }, doubleTap: function (e) { const t = this; t.params.zoom.enabled && t.zoom.enabled && t.params.zoom.toggle && t.zoom.toggle(e) }, transitionEnd: function () { const e = this; e.zoom.enabled && e.params.zoom.enabled && e.zoom.onTransitionEnd() }, slideChange: function () { const e = this; e.zoom.enabled && e.params.zoom.enabled && e.params.cssMode && e.zoom.onTransitionEnd() } } }; const It = { loadInSlide: function (e, t) { void 0 === t && (t = !0); const a = this; const i = a.params.lazy; if (typeof e !== 'undefined' && a.slides.length !== 0) { const n = a.virtual && a.params.virtual.enabled; const r = n ? a.$wrapperEl.children('.' + a.params.slideClass + '[data-swiper-slide-index="' + e + '"]') : a.slides.eq(e); let o = r.find('.' + i.elementClass + ':not(.' + i.loadedClass + '):not(.' + i.loadingClass + ')'); !r.hasClass(i.elementClass) || r.hasClass(i.loadedClass) || r.hasClass(i.loadingClass) || (o = o.add(r[0])), o.length !== 0 && o.each(function (e, n) { const o = s(n); o.addClass(i.loadingClass); const l = o.attr('data-background'); const d = o.attr('data-src'); const c = o.attr('data-srcset'); const p = o.attr('data-sizes'); a.loadImage(o[0], d || l, c, p, !1, function () { if (typeof a !== 'undefined' && a !== null && a && (!a || a.params) && !a.destroyed) { if (l ? (o.css('background-image', 'url("' + l + '")'), o.removeAttr('data-background')) : (c && (o.attr('srcset', c), o.removeAttr('data-srcset')), p && (o.attr('sizes', p), o.removeAttr('data-sizes')), d && (o.attr('src', d), o.removeAttr('data-src'))), o.addClass(i.loadedClass).removeClass(i.loadingClass), r.find('.' + i.preloaderClass).remove(), a.params.loop && t) { const e = r.attr('data-swiper-slide-index'); if (r.hasClass(a.params.slideDuplicateClass)) { const s = a.$wrapperEl.children('[data-swiper-slide-index="' + e + '"]:not(.' + a.params.slideDuplicateClass + ')'); a.lazy.loadInSlide(s.index(), !1) } else { const n = a.$wrapperEl.children('.' + a.params.slideDuplicateClass + '[data-swiper-slide-index="' + e + '"]'); a.lazy.loadInSlide(n.index(), !1) } }a.emit('lazyImageReady', r[0], o[0]) } }), a.emit('lazyImageLoad', r[0], o[0]) }) } }, load: function () { const e = this; const t = e.$wrapperEl; const a = e.params; const i = e.slides; const n = e.activeIndex; const r = e.virtual && a.virtual.enabled; const o = a.lazy; let l = a.slidesPerView; function d (e) { if (r) { if (t.children('.' + a.slideClass + '[data-swiper-slide-index="' + e + '"]').length) return !0 } else if (i[e]) return !0; return !1 } function c (e) { return r ? s(e).attr('data-swiper-slide-index') : s(e).index() } if (l === 'auto' && (l = 0), e.lazy.initialImageLoaded || (e.lazy.initialImageLoaded = !0), e.params.watchSlidesVisibility)t.children('.' + a.slideVisibleClass).each(function (t, a) { const i = r ? s(a).attr('data-swiper-slide-index') : s(a).index(); e.lazy.loadInSlide(i) }); else if (l > 1) for (let p = n; p < n + l; p += 1)d(p) && e.lazy.loadInSlide(p); else e.lazy.loadInSlide(n); if (o.loadPrevNext) if (l > 1 || o.loadPrevNextAmount && o.loadPrevNextAmount > 1) { for (var u = o.loadPrevNextAmount, h = l, f = Math.min(n + h + Math.max(u, h), i.length), m = Math.max(n - Math.max(h, u), 0), v = n + l; v < f; v += 1)d(v) && e.lazy.loadInSlide(v); for (let g = m; g < n; g += 1)d(g) && e.lazy.loadInSlide(g) } else { const b = t.children('.' + a.slideNextClass); b.length > 0 && e.lazy.loadInSlide(c(b)); const w = t.children('.' + a.slidePrevClass); w.length > 0 && e.lazy.loadInSlide(c(w)) } } }; const Ot = { name: 'lazy', params: { lazy: { enabled: !1, loadPrevNext: !1, loadPrevNextAmount: 1, loadOnTransitionStart: !1, elementClass: 'swiper-lazy', loadingClass: 'swiper-lazy-loading', loadedClass: 'swiper-lazy-loaded', preloaderClass: 'swiper-lazy-preloader' } }, create: function () { const e = this; F.extend(e, { lazy: { initialImageLoaded: !1, load: It.load.bind(e), loadInSlide: It.loadInSlide.bind(e) } }) }, on: { beforeInit: function () { const e = this; e.params.lazy.enabled && e.params.preloadImages && (e.params.preloadImages = !1) }, init: function () { const e = this; e.params.lazy.enabled && !e.params.loop && e.params.initialSlide === 0 && e.lazy.load() }, scroll: function () { const e = this; e.params.freeMode && !e.params.freeModeSticky && e.lazy.load() }, resize: function () { const e = this; e.params.lazy.enabled && e.lazy.load() }, scrollbarDragMove: function () { const e = this; e.params.lazy.enabled && e.lazy.load() }, transitionStart: function () { const e = this; e.params.lazy.enabled && (e.params.lazy.loadOnTransitionStart || !e.params.lazy.loadOnTransitionStart && !e.lazy.initialImageLoaded) && e.lazy.load() }, transitionEnd: function () { const e = this; e.params.lazy.enabled && !e.params.lazy.loadOnTransitionStart && e.lazy.load() }, slideChange: function () { const e = this; e.params.lazy.enabled && e.params.cssMode && e.lazy.load() } } }; var Dt = { LinearSpline: function (e, t) { let a; let s; const i = (function () { let e, t, a; return function (s, i) { t = -1, e = s.length; while (e - t > 1)a = e + t >> 1, s[a] <= i ? t = a : e = a; return e } }()); return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function (e) { return e ? (s = i(this.x, e), a = s - 1, (e - this.x[a]) * (this.y[s] - this.y[a]) / (this.x[s] - this.x[a]) + this.y[a]) : 0 }, this }, getInterpolateFunction: function (e) { const t = this; t.controller.spline || (t.controller.spline = t.params.loop ? new Dt.LinearSpline(t.slidesGrid, e.slidesGrid) : new Dt.LinearSpline(t.snapGrid, e.snapGrid)) }, setTranslate: function (e, t) { let a; let s; const i = this; const n = i.controller.control; function r (e) { const t = i.rtlTranslate ? -i.translate : i.translate; i.params.controller.by === 'slide' && (i.controller.getInterpolateFunction(e), s = -i.controller.spline.interpolate(-t)), s && i.params.controller.by !== 'container' || (a = (e.maxTranslate() - e.minTranslate()) / (i.maxTranslate() - i.minTranslate()), s = (t - i.minTranslate()) * a + e.minTranslate()), i.params.controller.inverse && (s = e.maxTranslate() - s), e.updateProgress(s), e.setTranslate(s, i), e.updateActiveIndex(), e.updateSlidesClasses() } if (Array.isArray(n)) for (let o = 0; o < n.length; o += 1)n[o] !== t && n[o] instanceof ot && r(n[o]); else n instanceof ot && t !== n && r(n) }, setTransition: function (e, t) { let a; const s = this; const i = s.controller.control; function n (t) { t.setTransition(e, s), e !== 0 && (t.transitionStart(), t.params.autoHeight && F.nextTick(function () { t.updateAutoHeight() }), t.$wrapperEl.transitionEnd(function () { i && (t.params.loop && s.params.controller.by === 'slide' && t.loopFix(), t.transitionEnd()) })) } if (Array.isArray(i)) for (a = 0; a < i.length; a += 1)i[a] !== t && i[a] instanceof ot && n(i[a]); else i instanceof ot && t !== i && n(i) } }; const At = { name: 'controller', params: { controller: { control: void 0, inverse: !1, by: 'slide' } }, create: function () { const e = this; F.extend(e, { controller: { control: e.params.controller.control, getInterpolateFunction: Dt.getInterpolateFunction.bind(e), setTranslate: Dt.setTranslate.bind(e), setTransition: Dt.setTransition.bind(e) } }) }, on: { update: function () { const e = this; e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline) }, resize: function () { const e = this; e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline) }, observerUpdate: function () { const e = this; e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline) }, setTranslate: function (e, t) { const a = this; a.controller.control && a.controller.setTranslate(e, t) }, setTransition: function (e, t) { const a = this; a.controller.control && a.controller.setTransition(e, t) } } }; const Gt = { makeElFocusable: function (e) { return e.attr('tabIndex', '0'), e }, addElRole: function (e, t) { return e.attr('role', t), e }, addElLabel: function (e, t) { return e.attr('aria-label', t), e }, disableEl: function (e) { return e.attr('aria-disabled', !0), e }, enableEl: function (e) { return e.attr('aria-disabled', !1), e }, onEnterKey: function (e) { const t = this; const a = t.params.a11y; if (e.keyCode === 13) { const i = s(e.target); t.navigation && t.navigation.$nextEl && i.is(t.navigation.$nextEl) && (t.isEnd && !t.params.loop || t.slideNext(), t.isEnd ? t.a11y.notify(a.lastSlideMessage) : t.a11y.notify(a.nextSlideMessage)), t.navigation && t.navigation.$prevEl && i.is(t.navigation.$prevEl) && (t.isBeginning && !t.params.loop || t.slidePrev(), t.isBeginning ? t.a11y.notify(a.firstSlideMessage) : t.a11y.notify(a.prevSlideMessage)), t.pagination && i.is('.' + t.params.pagination.bulletClass) && i[0].click() } }, notify: function (e) { const t = this; const a = t.a11y.liveRegion; a.length !== 0 && (a.html(''), a.html(e)) }, updateNavigation: function () { const e = this; if (!e.params.loop && e.navigation) { const t = e.navigation; const a = t.$nextEl; const s = t.$prevEl; s && s.length > 0 && (e.isBeginning ? e.a11y.disableEl(s) : e.a11y.enableEl(s)), a && a.length > 0 && (e.isEnd ? e.a11y.disableEl(a) : e.a11y.enableEl(a)) } }, updatePagination: function () { const e = this; const t = e.params.a11y; e.pagination && e.params.pagination.clickable && e.pagination.bullets && e.pagination.bullets.length && e.pagination.bullets.each(function (a, i) { const n = s(i); e.a11y.makeElFocusable(n), e.a11y.addElRole(n, 'button'), e.a11y.addElLabel(n, t.paginationBulletMessage.replace(/{{index}}/, n.index() + 1)) }) }, init: function () { const e = this; e.$el.append(e.a11y.liveRegion); let t; let a; const s = e.params.a11y; e.navigation && e.navigation.$nextEl && (t = e.navigation.$nextEl), e.navigation && e.navigation.$prevEl && (a = e.navigation.$prevEl), t && (e.a11y.makeElFocusable(t), e.a11y.addElRole(t, 'button'), e.a11y.addElLabel(t, s.nextSlideMessage), t.on('keydown', e.a11y.onEnterKey)), a && (e.a11y.makeElFocusable(a), e.a11y.addElRole(a, 'button'), e.a11y.addElLabel(a, s.prevSlideMessage), a.on('keydown', e.a11y.onEnterKey)), e.pagination && e.params.pagination.clickable && e.pagination.bullets && e.pagination.bullets.length && e.pagination.$el.on('keydown', '.' + e.params.pagination.bulletClass, e.a11y.onEnterKey) }, destroy: function () { let e; let t; const a = this; a.a11y.liveRegion && a.a11y.liveRegion.length > 0 && a.a11y.liveRegion.remove(), a.navigation && a.navigation.$nextEl && (e = a.navigation.$nextEl), a.navigation && a.navigation.$prevEl && (t = a.navigation.$prevEl), e && e.off('keydown', a.a11y.onEnterKey), t && t.off('keydown', a.a11y.onEnterKey), a.pagination && a.params.pagination.clickable && a.pagination.bullets && a.pagination.bullets.length && a.pagination.$el.off('keydown', '.' + a.params.pagination.bulletClass, a.a11y.onEnterKey) } }; const Bt = { name: 'a11y', params: { a11y: { enabled: !0, notificationClass: 'swiper-notification', prevSlideMessage: 'Previous slide', nextSlideMessage: 'Next slide', firstSlideMessage: 'This is the first slide', lastSlideMessage: 'This is the last slide', paginationBulletMessage: 'Go to slide {{index}}' } }, create: function () { const e = this; F.extend(e, { a11y: { liveRegion: s('<span class="' + e.params.a11y.notificationClass + '" aria-live="assertive" aria-atomic="true"></span>') } }), Object.keys(Gt).forEach(function (t) { e.a11y[t] = Gt[t].bind(e) }) }, on: { init: function () { const e = this; e.params.a11y.enabled && (e.a11y.init(), e.a11y.updateNavigation()) }, toEdge: function () { const e = this; e.params.a11y.enabled && e.a11y.updateNavigation() }, fromEdge: function () { const e = this; e.params.a11y.enabled && e.a11y.updateNavigation() }, paginationUpdate: function () { const e = this; e.params.a11y.enabled && e.a11y.updatePagination() }, destroy: function () { const e = this; e.params.a11y.enabled && e.a11y.destroy() } } }; var Nt = { init: function () { const e = this; if (e.params.history) { if (!t.history || !t.history.pushState) return e.params.history.enabled = !1, void (e.params.hashNavigation.enabled = !0); const a = e.history; a.initialized = !0, a.paths = Nt.getPathValues(), (a.paths.key || a.paths.value) && (a.scrollToSlide(0, a.paths.value, e.params.runCallbacksOnInit), e.params.history.replaceState || t.addEventListener('popstate', e.history.setHistoryPopState)) } }, destroy: function () { const e = this; e.params.history.replaceState || t.removeEventListener('popstate', e.history.setHistoryPopState) }, setHistoryPopState: function () { const e = this; e.history.paths = Nt.getPathValues(), e.history.scrollToSlide(e.params.speed, e.history.paths.value, !1) }, getPathValues: function () { const e = t.location.pathname.slice(1).split('/').filter(function (e) { return e !== '' }); const a = e.length; const s = e[a - 2]; const i = e[a - 1]; return { key: s, value: i } }, setHistory: function (e, a) { const s = this; if (s.history.initialized && s.params.history.enabled) { const i = s.slides.eq(a); let n = Nt.slugify(i.attr('data-history')); t.location.pathname.includes(e) || (n = e + '/' + n); const r = t.history.state; r && r.value === n || (s.params.history.replaceState ? t.history.replaceState({ value: n }, null, n) : t.history.pushState({ value: n }, null, n)) } }, slugify: function (e) { return e.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '') }, scrollToSlide: function (e, t, a) { const s = this; if (t) for (let i = 0, n = s.slides.length; i < n; i += 1) { const r = s.slides.eq(i); const o = Nt.slugify(r.attr('data-history')); if (o === t && !r.hasClass(s.params.slideDuplicateClass)) { const l = r.index(); s.slideTo(l, e, a) } } else s.slideTo(0, e, a) } }; const Ht = { name: 'history', params: { history: { enabled: !1, replaceState: !1, key: 'slides' } }, create: function () { const e = this; F.extend(e, { history: { init: Nt.init.bind(e), setHistory: Nt.setHistory.bind(e), setHistoryPopState: Nt.setHistoryPopState.bind(e), scrollToSlide: Nt.scrollToSlide.bind(e), destroy: Nt.destroy.bind(e) } }) }, on: { init: function () { const e = this; e.params.history.enabled && e.history.init() }, destroy: function () { const e = this; e.params.history.enabled && e.history.destroy() }, transitionEnd: function () { const e = this; e.history.initialized && e.history.setHistory(e.params.history.key, e.activeIndex) }, slideChange: function () { const e = this; e.history.initialized && e.params.cssMode && e.history.setHistory(e.params.history.key, e.activeIndex) } } }; const Xt = { onHashCange: function () { const t = this; const a = e.location.hash.replace('#', ''); const s = t.slides.eq(t.activeIndex).attr('data-hash'); if (a !== s) { const i = t.$wrapperEl.children('.' + t.params.slideClass + '[data-hash="' + a + '"]').index(); if (typeof i === 'undefined') return; t.slideTo(i) } }, setHash: function () { const a = this; if (a.hashNavigation.initialized && a.params.hashNavigation.enabled) if (a.params.hashNavigation.replaceState && t.history && t.history.replaceState)t.history.replaceState(null, null, '#' + a.slides.eq(a.activeIndex).attr('data-hash') || !1); else { const s = a.slides.eq(a.activeIndex); const i = s.attr('data-hash') || s.attr('data-history'); e.location.hash = i || '' } }, init: function () { const a = this; if (!(!a.params.hashNavigation.enabled || a.params.history && a.params.history.enabled)) { a.hashNavigation.initialized = !0; const i = e.location.hash.replace('#', ''); if (i) for (let n = 0, r = 0, o = a.slides.length; r < o; r += 1) { const l = a.slides.eq(r); const d = l.attr('data-hash') || l.attr('data-history'); if (d === i && !l.hasClass(a.params.slideDuplicateClass)) { const c = l.index(); a.slideTo(c, n, a.params.runCallbacksOnInit, !0) } }a.params.hashNavigation.watchState && s(t).on('hashchange', a.hashNavigation.onHashCange) } }, destroy: function () { const e = this; e.params.hashNavigation.watchState && s(t).off('hashchange', e.hashNavigation.onHashCange) } }; const Vt = { name: 'hash-navigation', params: { hashNavigation: { enabled: !1, replaceState: !1, watchState: !1 } }, create: function () { const e = this; F.extend(e, { hashNavigation: { initialized: !1, init: Xt.init.bind(e), destroy: Xt.destroy.bind(e), setHash: Xt.setHash.bind(e), onHashCange: Xt.onHashCange.bind(e) } }) }, on: { init: function () { const e = this; e.params.hashNavigation.enabled && e.hashNavigation.init() }, destroy: function () { const e = this; e.params.hashNavigation.enabled && e.hashNavigation.destroy() }, transitionEnd: function () { const e = this; e.hashNavigation.initialized && e.hashNavigation.setHash() }, slideChange: function () { const e = this; e.hashNavigation.initialized && e.params.cssMode && e.hashNavigation.setHash() } } }; const Yt = { run: function () { const e = this; const t = e.slides.eq(e.activeIndex); let a = e.params.autoplay.delay; t.attr('data-swiper-autoplay') && (a = t.attr('data-swiper-autoplay') || e.params.autoplay.delay), clearTimeout(e.autoplay.timeout), e.autoplay.timeout = F.nextTick(function () { e.params.autoplay.reverseDirection ? e.params.loop ? (e.loopFix(), e.slidePrev(e.params.speed, !0, !0), e.emit('autoplay')) : e.isBeginning ? e.params.autoplay.stopOnLastSlide ? e.autoplay.stop() : (e.slideTo(e.slides.length - 1, e.params.speed, !0, !0), e.emit('autoplay')) : (e.slidePrev(e.params.speed, !0, !0), e.emit('autoplay')) : e.params.loop ? (e.loopFix(), e.slideNext(e.params.speed, !0, !0), e.emit('autoplay')) : e.isEnd ? e.params.autoplay.stopOnLastSlide ? e.autoplay.stop() : (e.slideTo(0, e.params.speed, !0, !0), e.emit('autoplay')) : (e.slideNext(e.params.speed, !0, !0), e.emit('autoplay')), e.params.cssMode && e.autoplay.running && e.autoplay.run() }, a) }, start: function () { const e = this; return typeof e.autoplay.timeout === 'undefined' && (!e.autoplay.running && (e.autoplay.running = !0, e.emit('autoplayStart'), e.autoplay.run(), !0)) }, stop: function () { const e = this; return !!e.autoplay.running && (typeof e.autoplay.timeout !== 'undefined' && (e.autoplay.timeout && (clearTimeout(e.autoplay.timeout), e.autoplay.timeout = void 0), e.autoplay.running = !1, e.emit('autoplayStop'), !0)) }, pause: function (e) { const t = this; t.autoplay.running && (t.autoplay.paused || (t.autoplay.timeout && clearTimeout(t.autoplay.timeout), t.autoplay.paused = !0, e !== 0 && t.params.autoplay.waitForTransition ? (t.$wrapperEl[0].addEventListener('transitionend', t.autoplay.onTransitionEnd), t.$wrapperEl[0].addEventListener('webkitTransitionEnd', t.autoplay.onTransitionEnd)) : (t.autoplay.paused = !1, t.autoplay.run()))) } }; const Rt = { name: 'autoplay', params: { autoplay: { enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !0, stopOnLastSlide: !1, reverseDirection: !1 } }, create: function () { const e = this; F.extend(e, { autoplay: { running: !1, paused: !1, run: Yt.run.bind(e), start: Yt.start.bind(e), stop: Yt.stop.bind(e), pause: Yt.pause.bind(e), onVisibilityChange: function () { document.visibilityState === 'hidden' && e.autoplay.running && e.autoplay.pause(), document.visibilityState === 'visible' && e.autoplay.paused && (e.autoplay.run(), e.autoplay.paused = !1) }, onTransitionEnd: function (t) { e && !e.destroyed && e.$wrapperEl && t.target === this && (e.$wrapperEl[0].removeEventListener('transitionend', e.autoplay.onTransitionEnd), e.$wrapperEl[0].removeEventListener('webkitTransitionEnd', e.autoplay.onTransitionEnd), e.autoplay.paused = !1, e.autoplay.running ? e.autoplay.run() : e.autoplay.stop()) } } }) }, on: { init: function () { const e = this; e.params.autoplay.enabled && (e.autoplay.start(), document.addEventListener('visibilitychange', e.autoplay.onVisibilityChange)) }, beforeTransitionStart: function (e, t) { const a = this; a.autoplay.running && (t || !a.params.autoplay.disableOnInteraction ? a.autoplay.pause(e) : a.autoplay.stop()) }, sliderFirstMove: function () { const e = this; e.autoplay.running && (e.params.autoplay.disableOnInteraction ? e.autoplay.stop() : e.autoplay.pause()) }, touchEnd: function () { const e = this; e.params.cssMode && e.autoplay.paused && !e.params.autoplay.disableOnInteraction && e.autoplay.run() }, destroy: function () { const e = this; e.autoplay.running && e.autoplay.stop(), document.removeEventListener('visibilitychange', e.autoplay.onVisibilityChange) } } }; const Ft = { setTranslate: function () { for (let e = this, t = e.slides, a = 0; a < t.length; a += 1) { const s = e.slides.eq(a); const i = s[0].swiperSlideOffset; let n = -i; e.params.virtualTranslate || (n -= e.translate); let r = 0; e.isHorizontal() || (r = n, n = 0); const o = e.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(s[0].progress), 0) : 1 + Math.min(Math.max(s[0].progress, -1), 0); s.css({ opacity: o }).transform('translate3d(' + n + 'px, ' + r + 'px, 0px)') } }, setTransition: function (e) { const t = this; const a = t.slides; const s = t.$wrapperEl; if (a.transition(e), t.params.virtualTranslate && e !== 0) { let i = !1; a.transitionEnd(function () { if (!i && t && !t.destroyed) { i = !0, t.animating = !1; for (let e = ['webkitTransitionEnd', 'transitionend'], a = 0; a < e.length; a += 1)s.trigger(e[a]) } }) } } }; const Wt = { name: 'effect-fade', params: { fadeEffect: { crossFade: !1 } }, create: function () { const e = this; F.extend(e, { fadeEffect: { setTranslate: Ft.setTranslate.bind(e), setTransition: Ft.setTransition.bind(e) } }) }, on: { beforeInit: function () { const e = this; if (e.params.effect === 'fade') { e.classNames.push(e.params.containerModifierClass + 'fade'); const t = { slidesPerView: 1, slidesPerColumn: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !0 }; F.extend(e.params, t), F.extend(e.originalParams, t) } }, setTranslate: function () { const e = this; e.params.effect === 'fade' && e.fadeEffect.setTranslate() }, setTransition: function (e) { const t = this; t.params.effect === 'fade' && t.fadeEffect.setTransition(e) } } }; const jt = { setTranslate: function () { let e; const t = this; const a = t.$el; const i = t.$wrapperEl; const n = t.slides; const r = t.width; const o = t.height; const l = t.rtlTranslate; const d = t.size; const c = t.params.cubeEffect; const p = t.isHorizontal(); const u = t.virtual && t.params.virtual.enabled; let h = 0; c.shadow && (p ? (e = i.find('.swiper-cube-shadow'), e.length === 0 && (e = s('<div class="swiper-cube-shadow"></div>'), i.append(e)), e.css({ height: r + 'px' })) : (e = a.find('.swiper-cube-shadow'), e.length === 0 && (e = s('<div class="swiper-cube-shadow"></div>'), a.append(e)))); for (let f = 0; f < n.length; f += 1) { const m = n.eq(f); let v = f; u && (v = parseInt(m.attr('data-swiper-slide-index'), 10)); let g = 90 * v; let b = Math.floor(g / 360); l && (g = -g, b = Math.floor(-g / 360)); const w = Math.max(Math.min(m[0].progress, 1), -1); let y = 0; let x = 0; let E = 0; v % 4 === 0 ? (y = 4 * -b * d, E = 0) : (v - 1) % 4 === 0 ? (y = 0, E = 4 * -b * d) : (v - 2) % 4 === 0 ? (y = d + 4 * b * d, E = d) : (v - 3) % 4 === 0 && (y = -d, E = 3 * d + 4 * d * b), l && (y = -y), p || (x = y, y = 0); const T = 'rotateX(' + (p ? 0 : -g) + 'deg) rotateY(' + (p ? g : 0) + 'deg) translate3d(' + y + 'px, ' + x + 'px, ' + E + 'px)'; if (w <= 1 && w > -1 && (h = 90 * v + 90 * w, l && (h = 90 * -v - 90 * w)), m.transform(T), c.slideShadows) { let S = p ? m.find('.swiper-slide-shadow-left') : m.find('.swiper-slide-shadow-top'); let C = p ? m.find('.swiper-slide-shadow-right') : m.find('.swiper-slide-shadow-bottom'); S.length === 0 && (S = s('<div class="swiper-slide-shadow-' + (p ? 'left' : 'top') + '"></div>'), m.append(S)), C.length === 0 && (C = s('<div class="swiper-slide-shadow-' + (p ? 'right' : 'bottom') + '"></div>'), m.append(C)), S.length && (S[0].style.opacity = Math.max(-w, 0)), C.length && (C[0].style.opacity = Math.max(w, 0)) } } if (i.css({ '-webkit-transform-origin': '50% 50% -' + d / 2 + 'px', '-moz-transform-origin': '50% 50% -' + d / 2 + 'px', '-ms-transform-origin': '50% 50% -' + d / 2 + 'px', 'transform-origin': '50% 50% -' + d / 2 + 'px' }), c.shadow) if (p)e.transform('translate3d(0px, ' + (r / 2 + c.shadowOffset) + 'px, ' + -r / 2 + 'px) rotateX(90deg) rotateZ(0deg) scale(' + c.shadowScale + ')'); else { const M = Math.abs(h) - 90 * Math.floor(Math.abs(h) / 90); const $ = 1.5 - (Math.sin(2 * M * Math.PI / 360) / 2 + Math.cos(2 * M * Math.PI / 360) / 2); const P = c.shadowScale; const k = c.shadowScale / $; const z = c.shadowOffset; e.transform('scale3d(' + P + ', 1, ' + k + ') translate3d(0px, ' + (o / 2 + z) + 'px, ' + -o / 2 / k + 'px) rotateX(-90deg)') } const L = ct.isSafari || ct.isUiWebView ? -d / 2 : 0; i.transform('translate3d(0px,0,' + L + 'px) rotateX(' + (t.isHorizontal() ? 0 : h) + 'deg) rotateY(' + (t.isHorizontal() ? -h : 0) + 'deg)') }, setTransition: function (e) { const t = this; const a = t.$el; const s = t.slides; s.transition(e).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(e), t.params.cubeEffect.shadow && !t.isHorizontal() && a.find('.swiper-cube-shadow').transition(e) } }; const qt = { name: 'effect-cube', params: { cubeEffect: { slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: 0.94 } }, create: function () { const e = this; F.extend(e, { cubeEffect: { setTranslate: jt.setTranslate.bind(e), setTransition: jt.setTransition.bind(e) } }) }, on: { beforeInit: function () { const e = this; if (e.params.effect === 'cube') { e.classNames.push(e.params.containerModifierClass + 'cube'), e.classNames.push(e.params.containerModifierClass + '3d'); const t = { slidesPerView: 1, slidesPerColumn: 1, slidesPerGroup: 1, watchSlidesProgress: !0, resistanceRatio: 0, spaceBetween: 0, centeredSlides: !1, virtualTranslate: !0 }; F.extend(e.params, t), F.extend(e.originalParams, t) } }, setTranslate: function () { const e = this; e.params.effect === 'cube' && e.cubeEffect.setTranslate() }, setTransition: function (e) { const t = this; t.params.effect === 'cube' && t.cubeEffect.setTransition(e) } } }; const _t = { setTranslate: function () { for (let e = this, t = e.slides, a = e.rtlTranslate, i = 0; i < t.length; i += 1) { const n = t.eq(i); let r = n[0].progress; e.params.flipEffect.limitRotation && (r = Math.max(Math.min(n[0].progress, 1), -1)); const o = n[0].swiperSlideOffset; const l = -180 * r; let d = l; let c = 0; let p = -o; let u = 0; if (e.isHorizontal() ? a && (d = -d) : (u = p, p = 0, c = -d, d = 0), n[0].style.zIndex = -Math.abs(Math.round(r)) + t.length, e.params.flipEffect.slideShadows) { let h = e.isHorizontal() ? n.find('.swiper-slide-shadow-left') : n.find('.swiper-slide-shadow-top'); let f = e.isHorizontal() ? n.find('.swiper-slide-shadow-right') : n.find('.swiper-slide-shadow-bottom'); h.length === 0 && (h = s('<div class="swiper-slide-shadow-' + (e.isHorizontal() ? 'left' : 'top') + '"></div>'), n.append(h)), f.length === 0 && (f = s('<div class="swiper-slide-shadow-' + (e.isHorizontal() ? 'right' : 'bottom') + '"></div>'), n.append(f)), h.length && (h[0].style.opacity = Math.max(-r, 0)), f.length && (f[0].style.opacity = Math.max(r, 0)) }n.transform('translate3d(' + p + 'px, ' + u + 'px, 0px) rotateX(' + c + 'deg) rotateY(' + d + 'deg)') } }, setTransition: function (e) { const t = this; const a = t.slides; const s = t.activeIndex; const i = t.$wrapperEl; if (a.transition(e).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(e), t.params.virtualTranslate && e !== 0) { let n = !1; a.eq(s).transitionEnd(function () { if (!n && t && !t.destroyed) { n = !0, t.animating = !1; for (let e = ['webkitTransitionEnd', 'transitionend'], a = 0; a < e.length; a += 1)i.trigger(e[a]) } }) } } }; const Ut = { name: 'effect-flip', params: { flipEffect: { slideShadows: !0, limitRotation: !0 } }, create: function () { const e = this; F.extend(e, { flipEffect: { setTranslate: _t.setTranslate.bind(e), setTransition: _t.setTransition.bind(e) } }) }, on: { beforeInit: function () { const e = this; if (e.params.effect === 'flip') { e.classNames.push(e.params.containerModifierClass + 'flip'), e.classNames.push(e.params.containerModifierClass + '3d'); const t = { slidesPerView: 1, slidesPerColumn: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !0 }; F.extend(e.params, t), F.extend(e.originalParams, t) } }, setTranslate: function () { const e = this; e.params.effect === 'flip' && e.flipEffect.setTranslate() }, setTransition: function (e) { const t = this; t.params.effect === 'flip' && t.flipEffect.setTransition(e) } } }; const Kt = { setTranslate: function () { for (var e = this, t = e.width, a = e.height, i = e.slides, n = e.$wrapperEl, r = e.slidesSizesGrid, o = e.params.coverflowEffect, l = e.isHorizontal(), d = e.translate, c = l ? t / 2 - d : a / 2 - d, p = l ? o.rotate : -o.rotate, u = o.depth, h = 0, f = i.length; h < f; h += 1) { const m = i.eq(h); const v = r[h]; const g = m[0].swiperSlideOffset; const b = (c - g - v / 2) / v * o.modifier; let w = l ? p * b : 0; let y = l ? 0 : p * b; let x = -u * Math.abs(b); let E = l ? 0 : o.stretch * b; let T = l ? o.stretch * b : 0; Math.abs(T) < 0.001 && (T = 0), Math.abs(E) < 0.001 && (E = 0), Math.abs(x) < 0.001 && (x = 0), Math.abs(w) < 0.001 && (w = 0), Math.abs(y) < 0.001 && (y = 0); const S = 'translate3d(' + T + 'px,' + E + 'px,' + x + 'px)  rotateX(' + y + 'deg) rotateY(' + w + 'deg)'; if (m.transform(S), m[0].style.zIndex = 1 - Math.abs(Math.round(b)), o.slideShadows) { let C = l ? m.find('.swiper-slide-shadow-left') : m.find('.swiper-slide-shadow-top'); let M = l ? m.find('.swiper-slide-shadow-right') : m.find('.swiper-slide-shadow-bottom'); C.length === 0 && (C = s('<div class="swiper-slide-shadow-' + (l ? 'left' : 'top') + '"></div>'), m.append(C)), M.length === 0 && (M = s('<div class="swiper-slide-shadow-' + (l ? 'right' : 'bottom') + '"></div>'), m.append(M)), C.length && (C[0].style.opacity = b > 0 ? b : 0), M.length && (M[0].style.opacity = -b > 0 ? -b : 0) } } if (W.pointerEvents || W.prefixedPointerEvents) { const $ = n[0].style; $.perspectiveOrigin = c + 'px 50%' } }, setTransition: function (e) { const t = this; t.slides.transition(e).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(e) } }; const Zt = { name: 'effect-coverflow', params: { coverflowEffect: { rotate: 50, stretch: 0, depth: 100, modifier: 1, slideShadows: !0 } }, create: function () { const e = this; F.extend(e, { coverflowEffect: { setTranslate: Kt.setTranslate.bind(e), setTransition: Kt.setTransition.bind(e) } }) }, on: { beforeInit: function () { const e = this; e.params.effect === 'coverflow' && (e.classNames.push(e.params.containerModifierClass + 'coverflow'), e.classNames.push(e.params.containerModifierClass + '3d'), e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0) }, setTranslate: function () { const e = this; e.params.effect === 'coverflow' && e.coverflowEffect.setTranslate() }, setTransition: function (e) { const t = this; t.params.effect === 'coverflow' && t.coverflowEffect.setTransition(e) } } }; const Qt = { init: function () { const e = this; const t = e.params; const a = t.thumbs; const s = e.constructor; a.swiper instanceof s ? (e.thumbs.swiper = a.swiper, F.extend(e.thumbs.swiper.originalParams, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), F.extend(e.thumbs.swiper.params, { watchSlidesProgress: !0, slideToClickedSlide: !1 })) : F.isObject(a.swiper) && (e.thumbs.swiper = new s(F.extend({}, a.swiper, { watchSlidesVisibility: !0, watchSlidesProgress: !0, slideToClickedSlide: !1 })), e.thumbs.swiperCreated = !0), e.thumbs.swiper.$el.addClass(e.params.thumbs.thumbsContainerClass), e.thumbs.swiper.on('tap', e.thumbs.onThumbClick) }, onThumbClick: function () { const e = this; const t = e.thumbs.swiper; if (t) { const a = t.clickedIndex; const i = t.clickedSlide; if ((!i || !s(i).hasClass(e.params.thumbs.slideThumbActiveClass)) && typeof a !== 'undefined' && a !== null) { let n; if (n = t.params.loop ? parseInt(s(t.clickedSlide).attr('data-swiper-slide-index'), 10) : a, e.params.loop) { let r = e.activeIndex; e.slides.eq(r).hasClass(e.params.slideDuplicateClass) && (e.loopFix(), e._clientLeft = e.$wrapperEl[0].clientLeft, r = e.activeIndex); const o = e.slides.eq(r).prevAll('[data-swiper-slide-index="' + n + '"]').eq(0).index(); const l = e.slides.eq(r).nextAll('[data-swiper-slide-index="' + n + '"]').eq(0).index(); n = typeof o === 'undefined' ? l : typeof l === 'undefined' ? o : l - r < r - o ? l : o }e.slideTo(n) } } }, update: function (e) { const t = this; const a = t.thumbs.swiper; if (a) { const s = a.params.slidesPerView === 'auto' ? a.slidesPerViewDynamic() : a.params.slidesPerView; if (t.realIndex !== a.realIndex) { let i; let n = a.activeIndex; if (a.params.loop) { a.slides.eq(n).hasClass(a.params.slideDuplicateClass) && (a.loopFix(), a._clientLeft = a.$wrapperEl[0].clientLeft, n = a.activeIndex); const r = a.slides.eq(n).prevAll('[data-swiper-slide-index="' + t.realIndex + '"]').eq(0).index(); const o = a.slides.eq(n).nextAll('[data-swiper-slide-index="' + t.realIndex + '"]').eq(0).index(); i = typeof r === 'undefined' ? o : typeof o === 'undefined' ? r : o - n === n - r ? n : o - n < n - r ? o : r } else i = t.realIndex; a.visibleSlidesIndexes && a.visibleSlidesIndexes.indexOf(i) < 0 && (a.params.centeredSlides ? i = i > n ? i - Math.floor(s / 2) + 1 : i + Math.floor(s / 2) - 1 : i > n && (i = i - s + 1), a.slideTo(i, e ? 0 : void 0)) } let l = 1; const d = t.params.thumbs.slideThumbActiveClass; if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (l = t.params.slidesPerView), t.params.thumbs.multipleActiveThumbs || (l = 1), l = Math.floor(l), a.slides.removeClass(d), a.params.loop || a.params.virtual && a.params.virtual.enabled) for (let c = 0; c < l; c += 1)a.$wrapperEl.children('[data-swiper-slide-index="' + (t.realIndex + c) + '"]').addClass(d); else for (let p = 0; p < l; p += 1)a.slides.eq(t.realIndex + p).addClass(d) } } }; const Jt = { name: 'thumbs', params: { thumbs: { multipleActiveThumbs: !0, swiper: null, slideThumbActiveClass: 'swiper-slide-thumb-active', thumbsContainerClass: 'swiper-container-thumbs' } }, create: function () { const e = this; F.extend(e, { thumbs: { swiper: null, init: Qt.init.bind(e), update: Qt.update.bind(e), onThumbClick: Qt.onThumbClick.bind(e) } }) }, on: { beforeInit: function () { const e = this; const t = e.params; const a = t.thumbs; a && a.swiper && (e.thumbs.init(), e.thumbs.update(!0)) }, slideChange: function () { const e = this; e.thumbs.swiper && e.thumbs.update() }, update: function () { const e = this; e.thumbs.swiper && e.thumbs.update() }, resize: function () { const e = this; e.thumbs.swiper && e.thumbs.update() }, observerUpdate: function () { const e = this; e.thumbs.swiper && e.thumbs.update() }, setTransition: function (e) { const t = this; const a = t.thumbs.swiper; a && a.setTransition(e) }, beforeDestroy: function () { const e = this; const t = e.thumbs.swiper; t && e.thumbs.swiperCreated && t && t.destroy() } } }; const ea = [lt, dt, pt, ut, ft, vt, bt, xt, Tt, Ct, $t, kt, Lt, Ot, At, Bt, Ht, Vt, Rt, Wt, qt, Ut, Zt, Jt]; return typeof ot.use === 'undefined' && (ot.use = ot.Class.use, ot.installModule = ot.Class.installModule), ot.use(ea), ot }) }, '0366': function (e, t, a) { const s = a('1c0b'); e.exports = function (e, t, a) { if (s(e), void 0 === t) return e; switch (a) { case 0:return function () { return e.call(t) }; case 1:return function (a) { return e.call(t, a) }; case 2:return function (a, s) { return e.call(t, a, s) }; case 3:return function (a, s, i) { return e.call(t, a, s, i) } } return function () { return e.apply(t, arguments) } } }, '06cf': function (e, t, a) { const s = a('83ab'); const i = a('d1e7'); const n = a('5c6c'); const r = a('fc6a'); const o = a('c04e'); const l = a('5135'); const d = a('0cfb'); const c = Object.getOwnPropertyDescriptor; t.f = s ? c : function (e, t) { if (e = r(e), t = o(t, !0), d) try { return c(e, t) } catch (a) {} if (l(e, t)) return n(!i.f.call(e, t), e[t]) } }, '0cfb': function (e, t, a) { const s = a('83ab'); const i = a('d039'); const n = a('cc12'); e.exports = !s && !i(function () { return Object.defineProperty(n('div'), 'a', { get: function () { return 7 } }).a != 7 }) }, '14c3': function (e, t, a) { const s = a('c6b6'); const i = a('9263'); e.exports = function (e, t) { const a = e.exec; if (typeof a === 'function') { const n = a.call(e, t); if (typeof n !== 'object') throw TypeError('RegExp exec method returned something other than an Object or null'); return n } if (s(e) !== 'RegExp') throw TypeError('RegExp#exec called on incompatible receiver'); return i.call(e, t) } }, '17c2': function (e, t, a) { 'use strict'; const s = a('b727').forEach; const i = a('a640'); const n = a('ae40'); const r = i('forEach'); const o = n('forEach'); e.exports = r && o ? [].forEach : function (e) { return s(this, e, arguments.length > 1 ? arguments[1] : void 0) } }, '1c0b': function (e, t) { e.exports = function (e) { if (typeof e !== 'function') throw TypeError(String(e) + ' is not a function'); return e } }, '1d80': function (e, t) { e.exports = function (e) { if (void 0 == e) throw TypeError("Can't call method on " + e); return e } }, '1dde': function (e, t, a) { const s = a('d039'); const i = a('b622'); const n = a('2d00'); const r = i('species'); e.exports = function (e) { return n >= 51 || !s(function () { const t = []; const a = t.constructor = {}; return a[r] = function () { return { foo: 1 } }, t[e](Boolean).foo !== 1 }) } }, '23cb': function (e, t, a) { const s = a('a691'); const i = Math.max; const n = Math.min; e.exports = function (e, t) { const a = s(e); return a < 0 ? i(a + t, 0) : n(a, t) } }, '23e7': function (e, t, a) { const s = a('da84'); const i = a('06cf').f; const n = a('9112'); const r = a('6eeb'); const o = a('ce4e'); const l = a('e893'); const d = a('94ca'); e.exports = function (e, t) { let a; let c; let p; let u; let h; let f; const m = e.target; const v = e.global; const g = e.stat; if (c = v ? s : g ? s[m] || o(m, {}) : (s[m] || {}).prototype, c) for (p in t) { if (h = t[p], e.noTargetGet ? (f = i(c, p), u = f && f.value) : u = c[p], a = d(v ? p : m + (g ? '.' : '#') + p, e.forced), !a && void 0 !== u) { if (typeof h === typeof u) continue; l(h, u) }(e.sham || u && u.sham) && n(h, 'sham', !0), r(c, p, h, e) } } }, '241c': function (e, t, a) { const s = a('ca84'); const i = a('7839'); const n = i.concat('length', 'prototype'); t.f = Object.getOwnPropertyNames || function (e) { return s(e, n) } }, '2d00': function (e, t, a) { let s; let i; const n = a('da84'); const r = a('342f'); const o = n.process; const l = o && o.versions; const d = l && l.v8; d ? (s = d.split('.'), i = s[0] + s[1]) : r && (s = r.match(/Edge\/(\d+)/), (!s || s[1] >= 74) && (s = r.match(/Chrome\/(\d+)/), s && (i = s[1]))), e.exports = i && +i }, '342f': function (e, t, a) { const s = a('d066'); e.exports = s('navigator', 'userAgent') || '' }, 4160: function (e, t, a) { 'use strict'; const s = a('23e7'); const i = a('17c2'); s({ target: 'Array', proto: !0, forced: [].forEach != i }, { forEach: i }) }, '428f': function (e, t, a) { const s = a('da84'); e.exports = s }, '44ad': function (e, t, a) { const s = a('d039'); const i = a('c6b6'); const n = ''.split; e.exports = s(function () { return !Object('z').propertyIsEnumerable(0) }) ? function (e) { return i(e) == 'String' ? n.call(e, '') : Object(e) } : Object }, 4930: function (e, t, a) { const s = a('d039'); e.exports = !!Object.getOwnPropertySymbols && !s(function () { return !String(Symbol()) }) }, '4d64': function (e, t, a) { const s = a('fc6a'); const i = a('50c4'); const n = a('23cb'); const r = function (e) { return function (t, a, r) { let o; const l = s(t); const d = i(l.length); let c = n(r, d); if (e && a != a) { while (d > c) if (o = l[c++], o != o) return !0 } else for (;d > c; c++) if ((e || c in l) && l[c] === a) return e || c || 0; return !e && -1 } }; e.exports = { includes: r(!0), indexOf: r(!1) } }, '50c4': function (e, t, a) { const s = a('a691'); const i = Math.min; e.exports = function (e) { return e > 0 ? i(s(e), 9007199254740991) : 0 } }, 5135: function (e, t) { const a = {}.hasOwnProperty; e.exports = function (e, t) { return a.call(e, t) } }, 5319: function (e, t, a) { 'use strict'; const s = a('d784'); const i = a('825a'); const n = a('7b0b'); const r = a('50c4'); const o = a('a691'); const l = a('1d80'); const d = a('8aa5'); const c = a('14c3'); const p = Math.max; const u = Math.min; const h = Math.floor; const f = /\$([$&'`]|\d\d?|<[^>]*>)/g; const m = /\$([$&'`]|\d\d?)/g; const v = function (e) { return void 0 === e ? e : String(e) }; s('replace', 2, function (e, t, a, s) { const g = s.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE; const b = s.REPLACE_KEEPS_$0; const w = g ? '$' : '$0'; return [function (a, s) { const i = l(this); const n = void 0 == a ? void 0 : a[e]; return void 0 !== n ? n.call(a, i, s) : t.call(String(i), a, s) }, function (e, s) { if (!g && b || typeof s === 'string' && s.indexOf(w) === -1) { const n = a(t, e, this, s); if (n.done) return n.value } const l = i(e); const h = String(this); const f = typeof s === 'function'; f || (s = String(s)); const m = l.global; if (m) { var x = l.unicode; l.lastIndex = 0 } const E = []; while (1) { var T = c(l, h); if (T === null) break; if (E.push(T), !m) break; const S = String(T[0]); S === '' && (l.lastIndex = d(h, r(l.lastIndex), x)) } for (var C = '', M = 0, $ = 0; $ < E.length; $++) { T = E[$]; for (var P = String(T[0]), k = p(u(o(T.index), h.length), 0), z = [], L = 1; L < T.length; L++)z.push(v(T[L])); const I = T.groups; if (f) { const O = [P].concat(z, k, h); void 0 !== I && O.push(I); var D = String(s.apply(void 0, O)) } else D = y(P, h, k, z, I, s); k >= M && (C += h.slice(M, k) + D, M = k + P.length) } return C + h.slice(M) }]; function y (e, a, s, i, r, o) { const l = s + e.length; const d = i.length; let c = m; return void 0 !== r && (r = n(r), c = f), t.call(o, c, function (t, n) { let o; switch (n.charAt(0)) { case '$':return '$'; case '&':return e; case '`':return a.slice(0, s); case "'":return a.slice(l); case '<':o = r[n.slice(1, -1)]; break; default:var c = +n; if (c === 0) return t; if (c > d) { const p = h(c / 10); return p === 0 ? t : p <= d ? void 0 === i[p - 1] ? n.charAt(1) : i[p - 1] + n.charAt(1) : t }o = i[c - 1] } return void 0 === o ? '' : o }) } }) }, 5692: function (e, t, a) { const s = a('c430'); const i = a('c6cd'); (e.exports = function (e, t) { return i[e] || (i[e] = void 0 !== t ? t : {}) })('versions', []).push({ version: '3.6.4', mode: s ? 'pure' : 'global', copyright: '© 2020 Denis Pushkarev (zloirock.ru)' }) }, '56ef': function (e, t, a) { const s = a('d066'); const i = a('241c'); const n = a('7418'); const r = a('825a'); e.exports = s('Reflect', 'ownKeys') || function (e) { const t = i.f(r(e)); const a = n.f; return a ? t.concat(a(e)) : t } }, '5c6c': function (e, t) { e.exports = function (e, t) { return { enumerable: !(1 & e), configurable: !(2 & e), writable: !(4 & e), value: t } } }, '60da': function (e, t, a) { 'use strict'; const s = a('83ab'); const i = a('d039'); const n = a('df75'); const r = a('7418'); const o = a('d1e7'); const l = a('7b0b'); const d = a('44ad'); const c = Object.assign; const p = Object.defineProperty; e.exports = !c || i(function () { if (s && c({ b: 1 }, c(p({}, 'a', { enumerable: !0, get: function () { p(this, 'b', { value: 3, enumerable: !1 }) } }), { b: 2 })).b !== 1) return !0; const e = {}; const t = {}; const a = Symbol(); const i = 'abcdefghijklmnopqrst'; return e[a] = 7, i.split('').forEach(function (e) { t[e] = e }), c({}, e)[a] != 7 || n(c({}, t)).join('') != i }) ? function (e, t) { const a = l(e); const i = arguments.length; let c = 1; const p = r.f; const u = o.f; while (i > c) { var h; const f = d(arguments[c++]); const m = p ? n(f).concat(p(f)) : n(f); const v = m.length; let g = 0; while (v > g)h = m[g++], s && !u.call(f, h) || (a[h] = f[h]) } return a } : c }, 6547: function (e, t, a) { const s = a('a691'); const i = a('1d80'); const n = function (e) { return function (t, a) { let n; let r; const o = String(i(t)); const l = s(a); const d = o.length; return l < 0 || l >= d ? e ? '' : void 0 : (n = o.charCodeAt(l), n < 55296 || n > 56319 || l + 1 === d || (r = o.charCodeAt(l + 1)) < 56320 || r > 57343 ? e ? o.charAt(l) : n : e ? o.slice(l, l + 2) : r - 56320 + (n - 55296 << 10) + 65536) } }; e.exports = { codeAt: n(!1), charAt: n(!0) } }, '65f0': function (e, t, a) { const s = a('861d'); const i = a('e8b5'); const n = a('b622'); const r = n('species'); e.exports = function (e, t) { let a; return i(e) && (a = e.constructor, typeof a !== 'function' || a !== Array && !i(a.prototype) ? s(a) && (a = a[r], a === null && (a = void 0)) : a = void 0), new (void 0 === a ? Array : a)(t === 0 ? 0 : t) } }, '69f3': function (e, t, a) { let s; let i; let n; const r = a('7f9a'); const o = a('da84'); const l = a('861d'); const d = a('9112'); const c = a('5135'); const p = a('f772'); const u = a('d012'); const h = o.WeakMap; const f = function (e) { return n(e) ? i(e) : s(e, {}) }; const m = function (e) { return function (t) { let a; if (!l(t) || (a = i(t)).type !== e) throw TypeError('Incompatible receiver, ' + e + ' required'); return a } }; if (r) { const v = new h(); const g = v.get; const b = v.has; const w = v.set; s = function (e, t) { return w.call(v, e, t), t }, i = function (e) { return g.call(v, e) || {} }, n = function (e) { return b.call(v, e) } } else { const y = p('state'); u[y] = !0, s = function (e, t) { return d(e, y, t), t }, i = function (e) { return c(e, y) ? e[y] : {} }, n = function (e) { return c(e, y) } }e.exports = { set: s, get: i, has: n, enforce: f, getterFor: m } }, '6eeb': function (e, t, a) { const s = a('da84'); const i = a('9112'); const n = a('5135'); const r = a('ce4e'); const o = a('8925'); const l = a('69f3'); const d = l.get; const c = l.enforce; const p = String(String).split('String'); (e.exports = function (e, t, a, o) { const l = !!o && !!o.unsafe; let d = !!o && !!o.enumerable; const u = !!o && !!o.noTargetGet; typeof a === 'function' && (typeof t !== 'string' || n(a, 'name') || i(a, 'name', t), c(a).source = p.join(typeof t === 'string' ? t : '')), e !== s ? (l ? !u && e[t] && (d = !0) : delete e[t], d ? e[t] = a : i(e, t, a)) : d ? e[t] = a : r(t, a) })(Function.prototype, 'toString', function () { return typeof this === 'function' && d(this).source || o(this) }) }, 7418: function (e, t) { t.f = Object.getOwnPropertySymbols }, 7839: function (e, t) { e.exports = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'] }, '7b0b': function (e, t, a) { const s = a('1d80'); e.exports = function (e) { return Object(s(e)) } }, '7f9a': function (e, t, a) { const s = a('da84'); const i = a('8925'); const n = s.WeakMap; e.exports = typeof n === 'function' && /native code/.test(i(n)) }, '825a': function (e, t, a) { const s = a('861d'); e.exports = function (e) { if (!s(e)) throw TypeError(String(e) + ' is not an object'); return e } }, '83ab': function (e, t, a) { const s = a('d039'); e.exports = !s(function () { return Object.defineProperty({}, 1, { get: function () { return 7 } })[1] != 7 }) }, 8418: function (e, t, a) { 'use strict'; const s = a('c04e'); const i = a('9bf2'); const n = a('5c6c'); e.exports = function (e, t, a) { const r = s(t); r in e ? i.f(e, r, n(0, a)) : e[r] = a } }, '861d': function (e, t) { e.exports = function (e) { return typeof e === 'object' ? e !== null : typeof e === 'function' } }, 8925: function (e, t, a) { const s = a('c6cd'); const i = Function.toString; typeof s.inspectSource !== 'function' && (s.inspectSource = function (e) { return i.call(e) }), e.exports = s.inspectSource }, '8aa5': function (e, t, a) { 'use strict'; const s = a('6547').charAt; e.exports = function (e, t, a) { return t + (a ? s(e, t).length : 1) } }, '90e3': function (e, t) { let a = 0; const s = Math.random(); e.exports = function (e) { return 'Symbol(' + String(void 0 === e ? '' : e) + ')_' + (++a + s).toString(36) } }, 9112: function (e, t, a) { const s = a('83ab'); const i = a('9bf2'); const n = a('5c6c'); e.exports = s ? function (e, t, a) { return i.f(e, t, n(1, a)) } : function (e, t, a) { return e[t] = a, e } }, 9263: function (e, t, a) { 'use strict'; const s = a('ad6d'); const i = a('9f7f'); const n = RegExp.prototype.exec; const r = String.prototype.replace; let o = n; const l = (function () { const e = /a/; const t = /b*/g; return n.call(e, 'a'), n.call(t, 'a'), e.lastIndex !== 0 || t.lastIndex !== 0 }()); const d = i.UNSUPPORTED_Y || i.BROKEN_CARET; const c = void 0 !== /()??/.exec('')[1]; const p = l || c || d; p && (o = function (e) { let t; let a; let i; let o; const p = this; const u = d && p.sticky; let h = s.call(p); let f = p.source; let m = 0; let v = e; return u && (h = h.replace('y', ''), h.indexOf('g') === -1 && (h += 'g'), v = String(e).slice(p.lastIndex), p.lastIndex > 0 && (!p.multiline || p.multiline && e[p.lastIndex - 1] !== '\n') && (f = '(?: ' + f + ')', v = ' ' + v, m++), a = new RegExp('^(?:' + f + ')', h)), c && (a = new RegExp('^' + f + '$(?!\\s)', h)), l && (t = p.lastIndex), i = n.call(u ? a : p, v), u ? i ? (i.input = i.input.slice(m), i[0] = i[0].slice(m), i.index = p.lastIndex, p.lastIndex += i[0].length) : p.lastIndex = 0 : l && i && (p.lastIndex = p.global ? i.index + i[0].length : t), c && i && i.length > 1 && r.call(i[0], a, function () { for (o = 1; o < arguments.length - 2; o++) void 0 === arguments[o] && (i[o] = void 0) }), i }), e.exports = o }, '94ca': function (e, t, a) { const s = a('d039'); const i = /#|\.prototype\./; const n = function (e, t) { const a = o[r(e)]; return a == d || a != l && (typeof t === 'function' ? s(t) : !!t) }; var r = n.normalize = function (e) { return String(e).replace(i, '.').toLowerCase() }; var o = n.data = {}; var l = n.NATIVE = 'N'; var d = n.POLYFILL = 'P'; e.exports = n }, '99af': function (e, t, a) { 'use strict'; const s = a('23e7'); const i = a('d039'); const n = a('e8b5'); const r = a('861d'); const o = a('7b0b'); const l = a('50c4'); const d = a('8418'); const c = a('65f0'); const p = a('1dde'); const u = a('b622'); const h = a('2d00'); const f = u('isConcatSpreadable'); const m = 9007199254740991; const v = 'Maximum allowed index exceeded'; const g = h >= 51 || !i(function () { const e = []; return e[f] = !1, e.concat()[0] !== e }); const b = p('concat'); const w = function (e) { if (!r(e)) return !1; const t = e[f]; return void 0 !== t ? !!t : n(e) }; const y = !g || !b; s({ target: 'Array', proto: !0, forced: y }, { concat: function (e) { let t; let a; let s; let i; let n; const r = o(this); const p = c(r, 0); let u = 0; for (t = -1, s = arguments.length; t < s; t++) if (n = t === -1 ? r : arguments[t], w(n)) { if (i = l(n.length), u + i > m) throw TypeError(v); for (a = 0; a < i; a++, u++)a in n && d(p, u, n[a]) } else { if (u >= m) throw TypeError(v); d(p, u++, n) } return p.length = u, p } }) }, '9bf2': function (e, t, a) { const s = a('83ab'); const i = a('0cfb'); const n = a('825a'); const r = a('c04e'); const o = Object.defineProperty; t.f = s ? o : function (e, t, a) { if (n(e), t = r(t, !0), n(a), i) try { return o(e, t, a) } catch (s) {} if ('get' in a || 'set' in a) throw TypeError('Accessors not supported'); return 'value' in a && (e[t] = a.value), e } }, '9f7f': function (e, t, a) { 'use strict'; const s = a('d039'); function i (e, t) { return RegExp(e, t) }t.UNSUPPORTED_Y = s(function () { const e = i('a', 'y'); return e.lastIndex = 2, e.exec('abcd') != null }), t.BROKEN_CARET = s(function () { const e = i('^r', 'gy'); return e.lastIndex = 2, e.exec('str') != null }) }, a640: function (e, t, a) { 'use strict'; const s = a('d039'); e.exports = function (e, t) { const a = [][e]; return !!a && s(function () { a.call(null, t || function () { throw 1 }, 1) }) } }, a691: function (e, t) { const a = Math.ceil; const s = Math.floor; e.exports = function (e) { return isNaN(e = +e) ? 0 : (e > 0 ? s : a)(e) } }, ac1f: function (e, t, a) { 'use strict'; const s = a('23e7'); const i = a('9263'); s({ target: 'RegExp', proto: !0, forced: /./.exec !== i }, { exec: i }) }, ad6d: function (e, t, a) { 'use strict'; const s = a('825a'); e.exports = function () { const e = s(this); let t = ''; return e.global && (t += 'g'), e.ignoreCase && (t += 'i'), e.multiline && (t += 'm'), e.dotAll && (t += 's'), e.unicode && (t += 'u'), e.sticky && (t += 'y'), t } }, ae40: function (e, t, a) { const s = a('83ab'); const i = a('d039'); const n = a('5135'); const r = Object.defineProperty; const o = {}; const l = function (e) { throw e }; e.exports = function (e, t) { if (n(o, e)) return o[e]; t || (t = {}); const a = [][e]; const d = !!n(t, 'ACCESSORS') && t.ACCESSORS; const c = n(t, 0) ? t[0] : l; const p = n(t, 1) ? t[1] : void 0; return o[e] = !!a && !i(function () { if (d && !s) return !0; const e = { length: -1 }; d ? r(e, 1, { enumerable: !0, get: l }) : e[1] = 1, a.call(e, c, p) }) } }, b0c0: function (e, t, a) { const s = a('83ab'); const i = a('9bf2').f; const n = Function.prototype; const r = n.toString; const o = /^\s*function ([^ (]*)/; const l = 'name'; !s || l in n || i(n, l, { configurable: !0, get: function () { try { return r.call(this).match(o)[1] } catch (e) { return '' } } }) }, b622: function (e, t, a) { const s = a('da84'); const i = a('5692'); const n = a('5135'); const r = a('90e3'); const o = a('4930'); const l = a('fdbf'); const d = i('wks'); const c = s.Symbol; const p = l ? c : c && c.withoutSetter || r; e.exports = function (e) { return n(d, e) || (o && n(c, e) ? d[e] = c[e] : d[e] = p('Symbol.' + e)), d[e] } }, b727: function (e, t, a) { const s = a('0366'); const i = a('44ad'); const n = a('7b0b'); const r = a('50c4'); const o = a('65f0'); const l = [].push; const d = function (e) { const t = e == 1; const a = e == 2; const d = e == 3; const c = e == 4; const p = e == 6; const u = e == 5 || p; return function (h, f, m, v) { for (var g, b, w = n(h), y = i(w), x = s(f, m, 3), E = r(y.length), T = 0, S = v || o, C = t ? S(h, E) : a ? S(h, 0) : void 0; E > T; T++) if ((u || T in y) && (g = y[T], b = x(g, T, w), e)) if (t)C[T] = b; else if (b) switch (e) { case 3:return !0; case 5:return g; case 6:return T; case 2:l.call(C, g) } else if (c) return !1; return p ? -1 : d || c ? c : C } }; e.exports = { forEach: d(0), map: d(1), filter: d(2), some: d(3), every: d(4), find: d(5), findIndex: d(6) } }, c04e: function (e, t, a) { const s = a('861d'); e.exports = function (e, t) { if (!s(e)) return e; let a, i; if (t && typeof (a = e.toString) === 'function' && !s(i = a.call(e))) return i; if (typeof (a = e.valueOf) === 'function' && !s(i = a.call(e))) return i; if (!t && typeof (a = e.toString) === 'function' && !s(i = a.call(e))) return i; throw TypeError("Can't convert object to primitive value") } }, c430: function (e, t) { e.exports = !1 }, c6b6: function (e, t) { const a = {}.toString; e.exports = function (e) { return a.call(e).slice(8, -1) } }, c6cd: function (e, t, a) { const s = a('da84'); const i = a('ce4e'); const n = '__core-js_shared__'; const r = s[n] || i(n, {}); e.exports = r }, c8ba: function (e, t) { let a; a = (function () { return this }()); try { a = a || new Function('return this')() } catch (s) { typeof window === 'object' && (a = window) }e.exports = a }, ca84: function (e, t, a) { const s = a('5135'); const i = a('fc6a'); const n = a('4d64').indexOf; const r = a('d012'); e.exports = function (e, t) { let a; const o = i(e); let l = 0; const d = []; for (a in o)!s(r, a) && s(o, a) && d.push(a); while (t.length > l)s(o, a = t[l++]) && (~n(d, a) || d.push(a)); return d } }, cc12: function (e, t, a) { const s = a('da84'); const i = a('861d'); const n = s.document; const r = i(n) && i(n.createElement); e.exports = function (e) { return r ? n.createElement(e) : {} } }, cca6: function (e, t, a) { const s = a('23e7'); const i = a('60da'); s({ target: 'Object', stat: !0, forced: Object.assign !== i }, { assign: i }) }, ce4e: function (e, t, a) { const s = a('da84'); const i = a('9112'); e.exports = function (e, t) { try { i(s, e, t) } catch (a) { s[e] = t } return t } }, d012: function (e, t) { e.exports = {} }, d039: function (e, t) { e.exports = function (e) { try { return !!e() } catch (t) { return !0 } } }, d066: function (e, t, a) { const s = a('428f'); const i = a('da84'); const n = function (e) { return typeof e === 'function' ? e : void 0 }; e.exports = function (e, t) { return arguments.length < 2 ? n(s[e]) || n(i[e]) : s[e] && s[e][t] || i[e] && i[e][t] } }, d1e7: function (e, t, a) { 'use strict'; const s = {}.propertyIsEnumerable; const i = Object.getOwnPropertyDescriptor; const n = i && !s.call({ 1: 2 }, 1); t.f = n ? function (e) { const t = i(this, e); return !!t && t.enumerable } : s }, d784: function (e, t, a) { 'use strict'; a('ac1f'); const s = a('6eeb'); const i = a('d039'); const n = a('b622'); const r = a('9263'); const o = a('9112'); const l = n('species'); const d = !i(function () { const e = /./; return e.exec = function () { const e = []; return e.groups = { a: '7' }, e }, ''.replace(e, '$<a>') !== '7' }); const c = (function () { return 'a'.replace(/./, '$0') === '$0' }()); const p = n('replace'); const u = (function () { return !!/./[p] && /./[p]('a', '$0') === '' }()); const h = !i(function () { const e = /(?:)/; const t = e.exec; e.exec = function () { return t.apply(this, arguments) }; const a = 'ab'.split(e); return a.length !== 2 || a[0] !== 'a' || a[1] !== 'b' }); e.exports = function (e, t, a, p) { const f = n(e); const m = !i(function () { const t = {}; return t[f] = function () { return 7 }, ''[e](t) != 7 }); const v = m && !i(function () { let t = !1; let a = /a/; return e === 'split' && (a = {}, a.constructor = {}, a.constructor[l] = function () { return a }, a.flags = '', a[f] = /./[f]), a.exec = function () { return t = !0, null }, a[f](''), !t }); if (!m || !v || e === 'replace' && (!d || !c || u) || e === 'split' && !h) { const g = /./[f]; const b = a(f, ''[e], function (e, t, a, s, i) { return t.exec === r ? m && !i ? { done: !0, value: g.call(t, a, s) } : { done: !0, value: e.call(a, t, s) } : { done: !1 } }, { REPLACE_KEEPS_$0: c, REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: u }); const w = b[0]; const y = b[1]; s(String.prototype, e, w), s(RegExp.prototype, f, t == 2 ? function (e, t) { return y.call(e, this, t) } : function (e) { return y.call(e, this) }) }p && o(RegExp.prototype[f], 'sham', !0) } }, da84: function (e, t, a) { (function (t) { const a = function (e) { return e && e.Math == Math && e }; e.exports = a(typeof globalThis === 'object' && globalThis) || a(typeof window === 'object' && window) || a(typeof self === 'object' && self) || a(typeof t === 'object' && t) || Function('return this')() }).call(this, a('c8ba')) }, df75: function (e, t, a) { const s = a('ca84'); const i = a('7839'); e.exports = Object.keys || function (e) { return s(e, i) } }, e893: function (e, t, a) { const s = a('5135'); const i = a('56ef'); const n = a('06cf'); const r = a('9bf2'); e.exports = function (e, t) { for (let a = i(t), o = r.f, l = n.f, d = 0; d < a.length; d++) { const c = a[d]; s(e, c) || o(e, c, l(t, c)) } } }, e8b5: function (e, t, a) { const s = a('c6b6'); e.exports = Array.isArray || function (e) { return s(e) == 'Array' } }, f6fd: function (e, t) { (function (e) { const t = 'currentScript'; const a = e.getElementsByTagName('script'); t in e || Object.defineProperty(e, t, { get: function () { try { throw new Error() } catch (s) { let e; const t = (/.*at [^\(]*\((.*):.+:.+\)$/gi.exec(s.stack) || [!1])[1]; for (e in a) if (a[e].src == t || a[e].readyState == 'interactive') return a[e]; return null } } }) })(document) }, f772: function (e, t, a) { const s = a('5692'); const i = a('90e3'); const n = s('keys'); e.exports = function (e) { return n[e] || (n[e] = i(e)) } }, fb15: function (e, t, a) { 'use strict'; let s; (a.r(t), typeof window !== 'undefined') && (a('f6fd'), (s = window.document.currentScript) && (s = s.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)) && (a.p = s[1])); a('b0c0'); const i = typeof document === 'undefined' ? { body: {}, addEventListener: function () {}, removeEventListener: function () {}, activeElement: { blur: function () {}, nodeName: '' }, querySelector: function () { return null }, querySelectorAll: function () { return [] }, getElementById: function () { return null }, createEvent: function () { return { initEvent: function () {} } }, createElement: function () { return { children: [], childNodes: [], style: {}, setAttribute: function () {}, getElementsByTagName: function () { return [] } } }, location: { hash: '' } } : document; const n = typeof window === 'undefined' ? { document: i, navigator: { userAgent: '' }, location: {}, history: {}, CustomEvent: function () { return this }, addEventListener: function () {}, removeEventListener: function () {}, getComputedStyle: function () { return { getPropertyValue: function () { return '' } } }, Image: function () {}, Date: function () {}, screen: {}, setTimeout: function () {}, clearTimeout: function () {} } : window; class r {constructor (e) { const t = this; for (let a = 0; a < e.length; a += 1)t[a] = e[a]; return t.length = e.length, this }} function o (e, t) { const a = []; let s = 0; if (e && !t && e instanceof r) return e; if (e) if (typeof e === 'string') { let n, r; const o = e.trim(); if (o.indexOf('<') >= 0 && o.indexOf('>') >= 0) { let e = 'div'; for (o.indexOf('<li') === 0 && (e = 'ul'), o.indexOf('<tr') === 0 && (e = 'tbody'), o.indexOf('<td') !== 0 && o.indexOf('<th') !== 0 || (e = 'tr'), o.indexOf('<tbody') === 0 && (e = 'table'), o.indexOf('<option') === 0 && (e = 'select'), r = i.createElement(e), r.innerHTML = o, s = 0; s < r.childNodes.length; s += 1)a.push(r.childNodes[s]) } else for (n = t || e[0] !== '#' || e.match(/[ .<>:~]/) ? (t || i).querySelectorAll(e.trim()) : [i.getElementById(e.trim().split('#')[1])], s = 0; s < n.length; s += 1)n[s] && a.push(n[s]) } else if (e.nodeType || e === n || e === i)a.push(e); else if (e.length > 0 && e[0].nodeType) for (s = 0; s < e.length; s += 1)a.push(e[s]); return new r(a) } function l (e) { const t = []; for (let a = 0; a < e.length; a += 1)t.indexOf(e[a]) === -1 && t.push(e[a]); return t } function d (e) { if (typeof e === 'undefined') return this; const t = e.split(' '); for (let a = 0; a < t.length; a += 1) for (let e = 0; e < this.length; e += 1) typeof this[e] !== 'undefined' && typeof this[e].classList !== 'undefined' && this[e].classList.add(t[a]); return this } function c (e) { const t = e.split(' '); for (let a = 0; a < t.length; a += 1) for (let e = 0; e < this.length; e += 1) typeof this[e] !== 'undefined' && typeof this[e].classList !== 'undefined' && this[e].classList.remove(t[a]); return this } function p (e) { return !!this[0] && this[0].classList.contains(e) } function u (e) { const t = e.split(' '); for (let a = 0; a < t.length; a += 1) for (let e = 0; e < this.length; e += 1) typeof this[e] !== 'undefined' && typeof this[e].classList !== 'undefined' && this[e].classList.toggle(t[a]); return this } function h (e, t) { if (arguments.length === 1 && typeof e === 'string') return this[0] ? this[0].getAttribute(e) : void 0; for (let a = 0; a < this.length; a += 1) if (arguments.length === 2) this[a].setAttribute(e, t); else for (const t in e) this[a][t] = e[t], this[a].setAttribute(t, e[t]); return this } function f (e) { for (let t = 0; t < this.length; t += 1) this[t].removeAttribute(e); return this } function m (e, t) { let a; if (typeof t !== 'undefined') { for (let s = 0; s < this.length; s += 1)a = this[s], a.dom7ElementDataStorage || (a.dom7ElementDataStorage = {}), a.dom7ElementDataStorage[e] = t; return this } if (a = this[0], a) { if (a.dom7ElementDataStorage && e in a.dom7ElementDataStorage) return a.dom7ElementDataStorage[e]; const t = a.getAttribute(`data-${e}`); return t || void 0 } } function v (e) { for (let t = 0; t < this.length; t += 1) { const a = this[t].style; a.webkitTransform = e, a.transform = e } return this } function g (e) { typeof e !== 'string' && (e = `${e}ms`); for (let t = 0; t < this.length; t += 1) { const a = this[t].style; a.webkitTransitionDuration = e, a.transitionDuration = e } return this } function b (...e) { let [t, a, s, i] = e; function n (e) { const t = e.target; if (!t) return; const i = e.target.dom7EventData || []; if (i.indexOf(e) < 0 && i.unshift(e), o(t).is(a))s.apply(t, i); else { const e = o(t).parents(); for (let t = 0; t < e.length; t += 1)o(e[t]).is(a) && s.apply(e[t], i) } } function r (e) { const t = e && e.target && e.target.dom7EventData || []; t.indexOf(e) < 0 && t.unshift(e), s.apply(this, t) } typeof e[1] === 'function' && ([t, s, i] = e, a = void 0), i || (i = !1); const l = t.split(' '); let d; for (let o = 0; o < this.length; o += 1) { const e = this[o]; if (a) for (d = 0; d < l.length; d += 1) { const t = l[d]; e.dom7LiveListeners || (e.dom7LiveListeners = {}), e.dom7LiveListeners[t] || (e.dom7LiveListeners[t] = []), e.dom7LiveListeners[t].push({ listener: s, proxyListener: n }), e.addEventListener(t, n, i) } else for (d = 0; d < l.length; d += 1) { const t = l[d]; e.dom7Listeners || (e.dom7Listeners = {}), e.dom7Listeners[t] || (e.dom7Listeners[t] = []), e.dom7Listeners[t].push({ listener: s, proxyListener: r }), e.addEventListener(t, r, i) } } return this } function w (...e) { let [t, a, s, i] = e; typeof e[1] === 'function' && ([t, s, i] = e, a = void 0), i || (i = !1); const n = t.split(' '); for (let r = 0; r < n.length; r += 1) { const e = n[r]; for (let t = 0; t < this.length; t += 1) { const n = this[t]; let r; if (!a && n.dom7Listeners ? r = n.dom7Listeners[e] : a && n.dom7LiveListeners && (r = n.dom7LiveListeners[e]), r && r.length) for (let t = r.length - 1; t >= 0; t -= 1) { const a = r[t]; s && a.listener === s ? (n.removeEventListener(e, a.proxyListener, i), r.splice(t, 1)) : s && a.listener && a.listener.dom7proxy && a.listener.dom7proxy === s ? (n.removeEventListener(e, a.proxyListener, i), r.splice(t, 1)) : s || (n.removeEventListener(e, a.proxyListener, i), r.splice(t, 1)) } } } return this } function y (...e) { const t = e[0].split(' '); const a = e[1]; for (let r = 0; r < t.length; r += 1) { const o = t[r]; for (let t = 0; t < this.length; t += 1) { const r = this[t]; let l; try { l = new n.CustomEvent(o, { detail: a, bubbles: !0, cancelable: !0 }) } catch (s) { l = i.createEvent('Event'), l.initEvent(o, !0, !0), l.detail = a }r.dom7EventData = e.filter((e, t) => t > 0), r.dispatchEvent(l), r.dom7EventData = [], delete r.dom7EventData } } return this } function x (e) { const t = ['webkitTransitionEnd', 'transitionend']; const a = this; let s; function i (n) { if (n.target === this) for (e.call(this, n), s = 0; s < t.length; s += 1)a.off(t[s], i) } if (e) for (s = 0; s < t.length; s += 1)a.on(t[s], i); return this } function E (e) { if (this.length > 0) { if (e) { const e = this.styles(); return this[0].offsetWidth + parseFloat(e.getPropertyValue('margin-right')) + parseFloat(e.getPropertyValue('margin-left')) } return this[0].offsetWidth } return null } function T (e) { if (this.length > 0) { if (e) { const e = this.styles(); return this[0].offsetHeight + parseFloat(e.getPropertyValue('margin-top')) + parseFloat(e.getPropertyValue('margin-bottom')) } return this[0].offsetHeight } return null } function S () { if (this.length > 0) { const e = this[0]; const t = e.getBoundingClientRect(); const a = i.body; const s = e.clientTop || a.clientTop || 0; const r = e.clientLeft || a.clientLeft || 0; const o = e === n ? n.scrollY : e.scrollTop; const l = e === n ? n.scrollX : e.scrollLeft; return { top: t.top + o - s, left: t.left + l - r } } return null } function C () { return this[0] ? n.getComputedStyle(this[0], null) : {} } function M (e, t) { let a; if (arguments.length === 1) { if (typeof e !== 'string') { for (a = 0; a < this.length; a += 1) for (const t in e) this[a].style[t] = e[t]; return this } if (this[0]) return n.getComputedStyle(this[0], null).getPropertyValue(e) } if (arguments.length === 2 && typeof e === 'string') { for (a = 0; a < this.length; a += 1) this[a].style[e] = t; return this } return this } function $ (e) { if (!e) return this; for (let t = 0; t < this.length; t += 1) if (!1 === e.call(this[t], t, this[t])) return this; return this } function P (e) { const t = []; const a = this; for (let s = 0; s < a.length; s += 1)e.call(a[s], s, a[s]) && t.push(a[s]); return new r(t) } function k (e) { if (typeof e === 'undefined') return this[0] ? this[0].innerHTML : void 0; for (let t = 0; t < this.length; t += 1) this[t].innerHTML = e; return this } function z (e) { if (typeof e === 'undefined') return this[0] ? this[0].textContent.trim() : null; for (let t = 0; t < this.length; t += 1) this[t].textContent = e; return this } function L (e) { const t = this[0]; let a, s; if (!t || typeof e === 'undefined') return !1; if (typeof e === 'string') { if (t.matches) return t.matches(e); if (t.webkitMatchesSelector) return t.webkitMatchesSelector(e); if (t.msMatchesSelector) return t.msMatchesSelector(e); for (a = o(e), s = 0; s < a.length; s += 1) if (a[s] === t) return !0; return !1 } if (e === i) return t === i; if (e === n) return t === n; if (e.nodeType || e instanceof r) { for (a = e.nodeType ? [e] : e, s = 0; s < a.length; s += 1) if (a[s] === t) return !0; return !1 } return !1 } function I () { let e; let t = this[0]; if (t) { e = 0; while ((t = t.previousSibling) !== null)t.nodeType === 1 && (e += 1); return e } } function O (e) { if (typeof e === 'undefined') return this; const t = this.length; let a; return e > t - 1 ? new r([]) : e < 0 ? (a = t + e, new r(a < 0 ? [] : [this[a]])) : new r([this[e]]) } function D (...e) { let t; for (let a = 0; a < e.length; a += 1) { t = e[a]; for (let e = 0; e < this.length; e += 1) if (typeof t === 'string') { const a = i.createElement('div'); a.innerHTML = t; while (a.firstChild) this[e].appendChild(a.firstChild) } else if (t instanceof r) for (let a = 0; a < t.length; a += 1) this[e].appendChild(t[a]); else this[e].appendChild(t) } return this } function A (e) { let t, a; for (t = 0; t < this.length; t += 1) if (typeof e === 'string') { const s = i.createElement('div'); for (s.innerHTML = e, a = s.childNodes.length - 1; a >= 0; a -= 1) this[t].insertBefore(s.childNodes[a], this[t].childNodes[0]) } else if (e instanceof r) for (a = 0; a < e.length; a += 1) this[t].insertBefore(e[a], this[t].childNodes[0]); else this[t].insertBefore(e, this[t].childNodes[0]); return this } function G (e) { return this.length > 0 ? e ? this[0].nextElementSibling && o(this[0].nextElementSibling).is(e) ? new r([this[0].nextElementSibling]) : new r([]) : this[0].nextElementSibling ? new r([this[0].nextElementSibling]) : new r([]) : new r([]) } function B (e) { const t = []; let a = this[0]; if (!a) return new r([]); while (a.nextElementSibling) { const s = a.nextElementSibling; e ? o(s).is(e) && t.push(s) : t.push(s), a = s } return new r(t) } function N (e) { if (this.length > 0) { const t = this[0]; return e ? t.previousElementSibling && o(t.previousElementSibling).is(e) ? new r([t.previousElementSibling]) : new r([]) : t.previousElementSibling ? new r([t.previousElementSibling]) : new r([]) } return new r([]) } function H (e) { const t = []; let a = this[0]; if (!a) return new r([]); while (a.previousElementSibling) { const s = a.previousElementSibling; e ? o(s).is(e) && t.push(s) : t.push(s), a = s } return new r(t) } function X (e) { const t = []; for (let a = 0; a < this.length; a += 1) this[a].parentNode !== null && (e ? o(this[a].parentNode).is(e) && t.push(this[a].parentNode) : t.push(this[a].parentNode)); return o(l(t)) } function V (e) { const t = []; for (let a = 0; a < this.length; a += 1) { let s = this[a].parentNode; while (s)e ? o(s).is(e) && t.push(s) : t.push(s), s = s.parentNode } return o(l(t)) } function Y (e) { let t = this; return typeof e === 'undefined' ? new r([]) : (t.is(e) || (t = t.parents(e).eq(0)), t) } function R (e) { const t = []; for (let a = 0; a < this.length; a += 1) { const s = this[a].querySelectorAll(e); for (let e = 0; e < s.length; e += 1)t.push(s[e]) } return new r(t) } function F (e) { const t = []; for (let a = 0; a < this.length; a += 1) { const s = this[a].childNodes; for (let a = 0; a < s.length; a += 1)e ? s[a].nodeType === 1 && o(s[a]).is(e) && t.push(s[a]) : s[a].nodeType === 1 && t.push(s[a]) } return new r(l(t)) } function W () { for (let e = 0; e < this.length; e += 1) this[e].parentNode && this[e].parentNode.removeChild(this[e]); return this } function j (...e) { const t = this; let a, s; for (a = 0; a < e.length; a += 1) { const i = o(e[a]); for (s = 0; s < i.length; s += 1)t[t.length] = i[s], t.length += 1 } return t }o.fn = r.prototype, o.Class = r, o.Dom7 = r; 'resize scroll'.split(' '); const q = { addClass: d, removeClass: c, hasClass: p, toggleClass: u, attr: h, removeAttr: f, data: m, transform: v, transition: g, on: b, off: w, trigger: y, transitionEnd: x, outerWidth: E, outerHeight: T, offset: S, css: M, each: $, html: k, text: z, is: L, index: I, eq: O, append: D, prepend: A, next: G, nextAll: B, prev: N, prevAll: H, parent: X, parents: V, closest: Y, find: R, children: F, filter: P, remove: W, add: j, styles: C }; Object.keys(q).forEach(e => { o.fn[e] = o.fn[e] || q[e] }); const _ = { deleteProps (e) { const t = e; Object.keys(t).forEach(e => { try { t[e] = null } catch (a) {} try { delete t[e] } catch (a) {} }) }, nextTick (e, t = 0) { return setTimeout(e, t) }, now () { return Date.now() }, getTranslate (e, t = 'x') { let a, s, i; const r = n.getComputedStyle(e, null); return n.WebKitCSSMatrix ? (s = r.transform || r.webkitTransform, s.split(',').length > 6 && (s = s.split(', ').map(e => e.replace(',', '.')).join(', ')), i = new n.WebKitCSSMatrix(s === 'none' ? '' : s)) : (i = r.MozTransform || r.OTransform || r.MsTransform || r.msTransform || r.transform || r.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,'), a = i.toString().split(',')), t === 'x' && (s = n.WebKitCSSMatrix ? i.m41 : a.length === 16 ? parseFloat(a[12]) : parseFloat(a[4])), t === 'y' && (s = n.WebKitCSSMatrix ? i.m42 : a.length === 16 ? parseFloat(a[13]) : parseFloat(a[5])), s || 0 }, parseUrlQuery (e) { const t = {}; let a; let s; let i; let r; let o = e || n.location.href; if (typeof o === 'string' && o.length) for (o = o.indexOf('?') > -1 ? o.replace(/\S*\?/, '') : '', s = o.split('&').filter(e => e !== ''), r = s.length, a = 0; a < r; a += 1)i = s[a].replace(/#\S+/g, '').split('='), t[decodeURIComponent(i[0])] = typeof i[1] === 'undefined' ? void 0 : decodeURIComponent(i[1]) || ''; return t }, isObject (e) { return typeof e === 'object' && e !== null && e.constructor && e.constructor === Object }, extend (...e) { const t = Object(e[0]); for (let a = 1; a < e.length; a += 1) { const s = e[a]; if (void 0 !== s && s !== null) { const e = Object.keys(Object(s)); for (let a = 0, i = e.length; a < i; a += 1) { const i = e[a]; const n = Object.getOwnPropertyDescriptor(s, i); void 0 !== n && n.enumerable && (_.isObject(t[i]) && _.isObject(s[i]) ? _.extend(t[i], s[i]) : !_.isObject(t[i]) && _.isObject(s[i]) ? (t[i] = {}, _.extend(t[i], s[i])) : t[i] = s[i]) } } } return t } }; const U = (function () { return { touch: n.Modernizr && !0 === n.Modernizr.touch || (function () { return !!(n.navigator.maxTouchPoints > 0 || 'ontouchstart' in n || n.DocumentTouch && i instanceof n.DocumentTouch) }()), pointerEvents: !!n.PointerEvent && 'maxTouchPoints' in n.navigator && n.navigator.maxTouchPoints > 0, observer: (function () { return 'MutationObserver' in n || 'WebkitMutationObserver' in n }()), passiveListener: (function () { let e = !1; try { const t = Object.defineProperty({}, 'passive', { get () { e = !0 } }); n.addEventListener('testPassiveListener', null, t) } catch (t) {} return e }()), gestures: (function () { return 'ongesturestart' in n }()) } }()); class K {constructor (e = {}) { const t = this; t.params = e, t.eventsListeners = {}, t.params && t.params.on && Object.keys(t.params.on).forEach(e => { t.on(e, t.params.on[e]) }) }on (e, t, a) { const s = this; if (typeof t !== 'function') return s; const i = a ? 'unshift' : 'push'; return e.split(' ').forEach(e => { s.eventsListeners[e] || (s.eventsListeners[e] = []), s.eventsListeners[e][i](t) }), s }once (e, t, a) { const s = this; if (typeof t !== 'function') return s; function i (...a) { s.off(e, i), i.f7proxy && delete i.f7proxy, t.apply(s, a) } return i.f7proxy = t, s.on(e, i, a) }off (e, t) { const a = this; return a.eventsListeners ? (e.split(' ').forEach(e => { typeof t === 'undefined' ? a.eventsListeners[e] = [] : a.eventsListeners[e] && a.eventsListeners[e].length && a.eventsListeners[e].forEach((s, i) => { (s === t || s.f7proxy && s.f7proxy === t) && a.eventsListeners[e].splice(i, 1) }) }), a) : a }emit (...e) { const t = this; if (!t.eventsListeners) return t; let a, s, i; typeof e[0] === 'string' || Array.isArray(e[0]) ? (a = e[0], s = e.slice(1, e.length), i = t) : (a = e[0].events, s = e[0].data, i = e[0].context || t); const n = Array.isArray(a) ? a : a.split(' '); return n.forEach(e => { if (t.eventsListeners && t.eventsListeners[e]) { const a = []; t.eventsListeners[e].forEach(e => { a.push(e) }), a.forEach(e => { e.apply(i, s) }) } }), t }useModulesParams (e) { const t = this; t.modules && Object.keys(t.modules).forEach(a => { const s = t.modules[a]; s.params && _.extend(e, s.params) }) }useModules (e = {}) { const t = this; t.modules && Object.keys(t.modules).forEach(a => { const s = t.modules[a]; const i = e[a] || {}; s.instance && Object.keys(s.instance).forEach(e => { const a = s.instance[e]; t[e] = typeof a === 'function' ? a.bind(t) : a }), s.on && t.on && Object.keys(s.on).forEach(e => { t.on(e, s.on[e]) }), s.create && s.create.bind(t)(i) }) } static set components (e) { const t = this; t.use && t.use(e) } static installModule (e, ...t) { const a = this; a.prototype.modules || (a.prototype.modules = {}); const s = e.name || `${Object.keys(a.prototype.modules).length}_${_.now()}`; return a.prototype.modules[s] = e, e.proto && Object.keys(e.proto).forEach(t => { a.prototype[t] = e.proto[t] }), e.static && Object.keys(e.static).forEach(t => { a[t] = e.static[t] }), e.install && e.install.apply(a, t), a } static use (e, ...t) { const a = this; return Array.isArray(e) ? (e.forEach(e => a.installModule(e)), a) : a.installModule(e, ...t) }} function Z () { const e = this; let t, a; const s = e.$el; t = typeof e.params.width !== 'undefined' ? e.params.width : s[0].clientWidth, a = typeof e.params.height !== 'undefined' ? e.params.height : s[0].clientHeight, t === 0 && e.isHorizontal() || a === 0 && e.isVertical() || (t = t - parseInt(s.css('padding-left'), 10) - parseInt(s.css('padding-right'), 10), a = a - parseInt(s.css('padding-top'), 10) - parseInt(s.css('padding-bottom'), 10), _.extend(e, { width: t, height: a, size: e.isHorizontal() ? t : a })) } function Q () { const e = this; const t = e.params; const { $wrapperEl: a, size: s, rtlTranslate: i, wrongRTL: r } = e; const o = e.virtual && t.virtual.enabled; const l = o ? e.virtual.slides.length : e.slides.length; const d = a.children(`.${e.params.slideClass}`); const c = o ? e.virtual.slides.length : d.length; let p = []; const u = []; const h = []; function f (e) { return !t.cssMode || e !== d.length - 1 } let m = t.slidesOffsetBefore; typeof m === 'function' && (m = t.slidesOffsetBefore.call(e)); let v = t.slidesOffsetAfter; typeof v === 'function' && (v = t.slidesOffsetAfter.call(e)); const g = e.snapGrid.length; const b = e.snapGrid.length; let w; let y; let x = t.spaceBetween; let E = -m; let T = 0; let S = 0; if (typeof s === 'undefined') return; typeof x === 'string' && x.indexOf('%') >= 0 && (x = parseFloat(x.replace('%', '')) / 100 * s), e.virtualSize = -x, i ? d.css({ marginLeft: '', marginTop: '' }) : d.css({ marginRight: '', marginBottom: '' }), t.slidesPerColumn > 1 && (w = Math.floor(c / t.slidesPerColumn) === c / e.params.slidesPerColumn ? c : Math.ceil(c / t.slidesPerColumn) * t.slidesPerColumn, t.slidesPerView !== 'auto' && t.slidesPerColumnFill === 'row' && (w = Math.max(w, t.slidesPerView * t.slidesPerColumn))); const C = t.slidesPerColumn; const M = w / C; const $ = Math.floor(c / t.slidesPerColumn); for (let k = 0; k < c; k += 1) { y = 0; const a = d.eq(k); if (t.slidesPerColumn > 1) { let s, i, n; if (t.slidesPerColumnFill === 'row' && t.slidesPerGroup > 1) { const e = Math.floor(k / (t.slidesPerGroup * t.slidesPerColumn)); const r = k - t.slidesPerColumn * t.slidesPerGroup * e; const o = e === 0 ? t.slidesPerGroup : Math.min(Math.ceil((c - e * C * t.slidesPerGroup) / C), t.slidesPerGroup); n = Math.floor(r / o), i = r - n * o + e * t.slidesPerGroup, s = i + n * w / C, a.css({ '-webkit-box-ordinal-group': s, '-moz-box-ordinal-group': s, '-ms-flex-order': s, '-webkit-order': s, order: s }) } else t.slidesPerColumnFill === 'column' ? (i = Math.floor(k / C), n = k - i * C, (i > $ || i === $ && n === C - 1) && (n += 1, n >= C && (n = 0, i += 1))) : (n = Math.floor(k / M), i = k - n * M); a.css(`margin-${e.isHorizontal() ? 'top' : 'left'}`, n !== 0 && t.spaceBetween && `${t.spaceBetween}px`) } if (a.css('display') !== 'none') { if (t.slidesPerView === 'auto') { const s = n.getComputedStyle(a[0], null); const i = a[0].style.transform; const r = a[0].style.webkitTransform; if (i && (a[0].style.transform = 'none'), r && (a[0].style.webkitTransform = 'none'), t.roundLengths)y = e.isHorizontal() ? a.outerWidth(!0) : a.outerHeight(!0); else if (e.isHorizontal()) { const e = parseFloat(s.getPropertyValue('width')); const t = parseFloat(s.getPropertyValue('padding-left')); const a = parseFloat(s.getPropertyValue('padding-right')); const i = parseFloat(s.getPropertyValue('margin-left')); const n = parseFloat(s.getPropertyValue('margin-right')); const r = s.getPropertyValue('box-sizing'); y = r && r === 'border-box' ? e + i + n : e + t + a + i + n } else { const e = parseFloat(s.getPropertyValue('height')); const t = parseFloat(s.getPropertyValue('padding-top')); const a = parseFloat(s.getPropertyValue('padding-bottom')); const i = parseFloat(s.getPropertyValue('margin-top')); const n = parseFloat(s.getPropertyValue('margin-bottom')); const r = s.getPropertyValue('box-sizing'); y = r && r === 'border-box' ? e + i + n : e + t + a + i + n }i && (a[0].style.transform = i), r && (a[0].style.webkitTransform = r), t.roundLengths && (y = Math.floor(y)) } else y = (s - (t.slidesPerView - 1) * x) / t.slidesPerView, t.roundLengths && (y = Math.floor(y)), d[k] && (e.isHorizontal() ? d[k].style.width = `${y}px` : d[k].style.height = `${y}px`); d[k] && (d[k].swiperSlideSize = y), h.push(y), t.centeredSlides ? (E = E + y / 2 + T / 2 + x, T === 0 && k !== 0 && (E = E - s / 2 - x), k === 0 && (E = E - s / 2 - x), Math.abs(E) < 0.001 && (E = 0), t.roundLengths && (E = Math.floor(E)), S % t.slidesPerGroup === 0 && p.push(E), u.push(E)) : (t.roundLengths && (E = Math.floor(E)), (S - Math.min(e.params.slidesPerGroupSkip, S)) % e.params.slidesPerGroup === 0 && p.push(E), u.push(E), E = E + y + x), e.virtualSize += y + x, T = y, S += 1 } } let P; if (e.virtualSize = Math.max(e.virtualSize, s) + v, i && r && (t.effect === 'slide' || t.effect === 'coverflow') && a.css({ width: `${e.virtualSize + t.spaceBetween}px` }), t.setWrapperSize && (e.isHorizontal() ? a.css({ width: `${e.virtualSize + t.spaceBetween}px` }) : a.css({ height: `${e.virtualSize + t.spaceBetween}px` })), t.slidesPerColumn > 1 && (e.virtualSize = (y + t.spaceBetween) * w, e.virtualSize = Math.ceil(e.virtualSize / t.slidesPerColumn) - t.spaceBetween, e.isHorizontal() ? a.css({ width: `${e.virtualSize + t.spaceBetween}px` }) : a.css({ height: `${e.virtualSize + t.spaceBetween}px` }), t.centeredSlides)) { P = []; for (let a = 0; a < p.length; a += 1) { let s = p[a]; t.roundLengths && (s = Math.floor(s)), p[a] < e.virtualSize + p[0] && P.push(s) }p = P } if (!t.centeredSlides) { P = []; for (let a = 0; a < p.length; a += 1) { let i = p[a]; t.roundLengths && (i = Math.floor(i)), p[a] <= e.virtualSize - s && P.push(i) }p = P, Math.floor(e.virtualSize - s) - Math.floor(p[p.length - 1]) > 1 && p.push(e.virtualSize - s) } if (p.length === 0 && (p = [0]), t.spaceBetween !== 0 && (e.isHorizontal() ? i ? d.filter(f).css({ marginLeft: `${x}px` }) : d.filter(f).css({ marginRight: `${x}px` }) : d.filter(f).css({ marginBottom: `${x}px` })), t.centeredSlides && t.centeredSlidesBounds) { let e = 0; h.forEach(a => { e += a + (t.spaceBetween ? t.spaceBetween : 0) }), e -= t.spaceBetween; const a = e - s; p = p.map(e => e < 0 ? -m : e > a ? a + v : e) } if (t.centerInsufficientSlides) { let e = 0; if (h.forEach(a => { e += a + (t.spaceBetween ? t.spaceBetween : 0) }), e -= t.spaceBetween, e < s) { const t = (s - e) / 2; p.forEach((e, a) => { p[a] = e - t }), u.forEach((e, a) => { u[a] = e + t }) } }_.extend(e, { slides: d, snapGrid: p, slidesGrid: u, slidesSizesGrid: h }), c !== l && e.emit('slidesLengthChange'), p.length !== g && (e.params.watchOverflow && e.checkOverflow(), e.emit('snapGridLengthChange')), u.length !== b && e.emit('slidesGridLengthChange'), (t.watchSlidesProgress || t.watchSlidesVisibility) && e.updateSlidesOffset() } function J (e) { const t = this; const a = []; let s; let i = 0; if (typeof e === 'number' ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed), t.params.slidesPerView !== 'auto' && t.params.slidesPerView > 1) for (s = 0; s < Math.ceil(t.params.slidesPerView); s += 1) { const e = t.activeIndex + s; if (e > t.slides.length) break; a.push(t.slides.eq(e)[0]) } else a.push(t.slides.eq(t.activeIndex)[0]); for (s = 0; s < a.length; s += 1) if (typeof a[s] !== 'undefined') { const e = a[s].offsetHeight; i = e > i ? e : i }i && t.$wrapperEl.css('height', `${i}px`) } function ee () { const e = this; const t = e.slides; for (let a = 0; a < t.length; a += 1)t[a].swiperSlideOffset = e.isHorizontal() ? t[a].offsetLeft : t[a].offsetTop } function te (e = this && this.translate || 0) { const t = this; const a = t.params; const { slides: s, rtlTranslate: i } = t; if (s.length === 0) return; typeof s[0].swiperSlideOffset === 'undefined' && t.updateSlidesOffset(); let n = -e; i && (n = e), s.removeClass(a.slideVisibleClass), t.visibleSlidesIndexes = [], t.visibleSlides = []; for (let r = 0; r < s.length; r += 1) { const e = s[r]; const o = (n + (a.centeredSlides ? t.minTranslate() : 0) - e.swiperSlideOffset) / (e.swiperSlideSize + a.spaceBetween); if (a.watchSlidesVisibility) { const i = -(n - e.swiperSlideOffset); const o = i + t.slidesSizesGrid[r]; const l = i >= 0 && i < t.size - 1 || o > 1 && o <= t.size || i <= 0 && o >= t.size; l && (t.visibleSlides.push(e), t.visibleSlidesIndexes.push(r), s.eq(r).addClass(a.slideVisibleClass)) }e.progress = i ? -o : o }t.visibleSlides = o(t.visibleSlides) } function ae (e) { const t = this; if (typeof e === 'undefined') { const a = t.rtlTranslate ? -1 : 1; e = t && t.translate && t.translate * a || 0 } const a = t.params; const s = t.maxTranslate() - t.minTranslate(); let { progress: i, isBeginning: n, isEnd: r } = t; const o = n; const l = r; s === 0 ? (i = 0, n = !0, r = !0) : (i = (e - t.minTranslate()) / s, n = i <= 0, r = i >= 1), _.extend(t, { progress: i, isBeginning: n, isEnd: r }), (a.watchSlidesProgress || a.watchSlidesVisibility) && t.updateSlidesProgress(e), n && !o && t.emit('reachBeginning toEdge'), r && !l && t.emit('reachEnd toEdge'), (o && !n || l && !r) && t.emit('fromEdge'), t.emit('progress', i) } function se () { const e = this; const { slides: t, params: a, $wrapperEl: s, activeIndex: i, realIndex: n } = e; const r = e.virtual && a.virtual.enabled; let o; t.removeClass(`${a.slideActiveClass} ${a.slideNextClass} ${a.slidePrevClass} ${a.slideDuplicateActiveClass} ${a.slideDuplicateNextClass} ${a.slideDuplicatePrevClass}`), o = r ? e.$wrapperEl.find(`.${a.slideClass}[data-swiper-slide-index="${i}"]`) : t.eq(i), o.addClass(a.slideActiveClass), a.loop && (o.hasClass(a.slideDuplicateClass) ? s.children(`.${a.slideClass}:not(.${a.slideDuplicateClass})[data-swiper-slide-index="${n}"]`).addClass(a.slideDuplicateActiveClass) : s.children(`.${a.slideClass}.${a.slideDuplicateClass}[data-swiper-slide-index="${n}"]`).addClass(a.slideDuplicateActiveClass)); let l = o.nextAll(`.${a.slideClass}`).eq(0).addClass(a.slideNextClass); a.loop && l.length === 0 && (l = t.eq(0), l.addClass(a.slideNextClass)); let d = o.prevAll(`.${a.slideClass}`).eq(0).addClass(a.slidePrevClass); a.loop && d.length === 0 && (d = t.eq(-1), d.addClass(a.slidePrevClass)), a.loop && (l.hasClass(a.slideDuplicateClass) ? s.children(`.${a.slideClass}:not(.${a.slideDuplicateClass})[data-swiper-slide-index="${l.attr('data-swiper-slide-index')}"]`).addClass(a.slideDuplicateNextClass) : s.children(`.${a.slideClass}.${a.slideDuplicateClass}[data-swiper-slide-index="${l.attr('data-swiper-slide-index')}"]`).addClass(a.slideDuplicateNextClass), d.hasClass(a.slideDuplicateClass) ? s.children(`.${a.slideClass}:not(.${a.slideDuplicateClass})[data-swiper-slide-index="${d.attr('data-swiper-slide-index')}"]`).addClass(a.slideDuplicatePrevClass) : s.children(`.${a.slideClass}.${a.slideDuplicateClass}[data-swiper-slide-index="${d.attr('data-swiper-slide-index')}"]`).addClass(a.slideDuplicatePrevClass)) } function ie (e) { const t = this; const a = t.rtlTranslate ? t.translate : -t.translate; const { slidesGrid: s, snapGrid: i, params: n, activeIndex: r, realIndex: o, snapIndex: l } = t; let d; let c = e; if (typeof c === 'undefined') { for (let e = 0; e < s.length; e += 1) typeof s[e + 1] !== 'undefined' ? a >= s[e] && a < s[e + 1] - (s[e + 1] - s[e]) / 2 ? c = e : a >= s[e] && a < s[e + 1] && (c = e + 1) : a >= s[e] && (c = e); n.normalizeSlideIndex && (c < 0 || typeof c === 'undefined') && (c = 0) } if (i.indexOf(a) >= 0)d = i.indexOf(a); else { const e = Math.min(n.slidesPerGroupSkip, c); d = e + Math.floor((c - e) / n.slidesPerGroup) } if (d >= i.length && (d = i.length - 1), c === r) return void (d !== l && (t.snapIndex = d, t.emit('snapIndexChange'))); const p = parseInt(t.slides.eq(c).attr('data-swiper-slide-index') || c, 10); _.extend(t, { snapIndex: d, realIndex: p, previousIndex: r, activeIndex: c }), t.emit('activeIndexChange'), t.emit('snapIndexChange'), o !== p && t.emit('realIndexChange'), (t.initialized || t.runCallbacksOnInit) && t.emit('slideChange') } function ne (e) { const t = this; const a = t.params; const s = o(e.target).closest(`.${a.slideClass}`)[0]; let i = !1; if (s) for (let n = 0; n < t.slides.length; n += 1)t.slides[n] === s && (i = !0); if (!s || !i) return t.clickedSlide = void 0, void (t.clickedIndex = void 0); t.clickedSlide = s, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(o(s).attr('data-swiper-slide-index'), 10) : t.clickedIndex = o(s).index(), a.slideToClickedSlide && void 0 !== t.clickedIndex && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide() } const re = { updateSize: Z, updateSlides: Q, updateAutoHeight: J, updateSlidesOffset: ee, updateSlidesProgress: te, updateProgress: ae, updateSlidesClasses: se, updateActiveIndex: ie, updateClickedSlide: ne }; function oe (e = (this.isHorizontal() ? 'x' : 'y')) { const t = this; const { params: a, rtlTranslate: s, translate: i, $wrapperEl: n } = t; if (a.virtualTranslate) return s ? -i : i; if (a.cssMode) return i; let r = _.getTranslate(n[0], e); return s && (r = -r), r || 0 } function le (e, t) { const a = this; const { rtlTranslate: s, params: i, $wrapperEl: n, wrapperEl: r, progress: o } = a; let l = 0; let d = 0; const c = 0; let p; a.isHorizontal() ? l = s ? -e : e : d = e, i.roundLengths && (l = Math.floor(l), d = Math.floor(d)), i.cssMode ? r[a.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = a.isHorizontal() ? -l : -d : i.virtualTranslate || n.transform(`translate3d(${l}px, ${d}px, ${c}px)`), a.previousTranslate = a.translate, a.translate = a.isHorizontal() ? l : d; const u = a.maxTranslate() - a.minTranslate(); p = u === 0 ? 0 : (e - a.minTranslate()) / u, p !== o && a.updateProgress(e), a.emit('setTranslate', a.translate, t) } function de () { return -this.snapGrid[0] } function ce () { return -this.snapGrid[this.snapGrid.length - 1] } function pe (e = 0, t = this.params.speed, a = !0, s = !0, i) { const n = this; const { params: r, wrapperEl: o } = n; if (n.animating && r.preventInteractionOnTransition) return !1; const l = n.minTranslate(); const d = n.maxTranslate(); let c; if (c = s && e > l ? l : s && e < d ? d : e, n.updateProgress(c), r.cssMode) { const e = n.isHorizontal(); return t === 0 ? o[e ? 'scrollLeft' : 'scrollTop'] = -c : o.scrollTo ? o.scrollTo({ [e ? 'left' : 'top']: -c, behavior: 'smooth' }) : o[e ? 'scrollLeft' : 'scrollTop'] = -c, !0 } return t === 0 ? (n.setTransition(0), n.setTranslate(c), a && (n.emit('beforeTransitionStart', t, i), n.emit('transitionEnd'))) : (n.setTransition(t), n.setTranslate(c), a && (n.emit('beforeTransitionStart', t, i), n.emit('transitionStart')), n.animating || (n.animating = !0, n.onTranslateToWrapperTransitionEnd || (n.onTranslateToWrapperTransitionEnd = function (e) { n && !n.destroyed && e.target === this && (n.$wrapperEl[0].removeEventListener('transitionend', n.onTranslateToWrapperTransitionEnd), n.$wrapperEl[0].removeEventListener('webkitTransitionEnd', n.onTranslateToWrapperTransitionEnd), n.onTranslateToWrapperTransitionEnd = null, delete n.onTranslateToWrapperTransitionEnd, a && n.emit('transitionEnd')) }), n.$wrapperEl[0].addEventListener('transitionend', n.onTranslateToWrapperTransitionEnd), n.$wrapperEl[0].addEventListener('webkitTransitionEnd', n.onTranslateToWrapperTransitionEnd))), !0 } const ue = { getTranslate: oe, setTranslate: le, minTranslate: de, maxTranslate: ce, translateTo: pe }; function he (e, t) { const a = this; a.params.cssMode || a.$wrapperEl.transition(e), a.emit('setTransition', e, t) } function fe (e = !0, t) { const a = this; const { activeIndex: s, params: i, previousIndex: n } = a; if (i.cssMode) return; i.autoHeight && a.updateAutoHeight(); let r = t; if (r || (r = s > n ? 'next' : s < n ? 'prev' : 'reset'), a.emit('transitionStart'), e && s !== n) { if (r === 'reset') return void a.emit('slideResetTransitionStart'); a.emit('slideChangeTransitionStart'), r === 'next' ? a.emit('slideNextTransitionStart') : a.emit('slidePrevTransitionStart') } } function me (e = !0, t) { const a = this; const { activeIndex: s, previousIndex: i, params: n } = a; if (a.animating = !1, n.cssMode) return; a.setTransition(0); let r = t; if (r || (r = s > i ? 'next' : s < i ? 'prev' : 'reset'), a.emit('transitionEnd'), e && s !== i) { if (r === 'reset') return void a.emit('slideResetTransitionEnd'); a.emit('slideChangeTransitionEnd'), r === 'next' ? a.emit('slideNextTransitionEnd') : a.emit('slidePrevTransitionEnd') } } const ve = { setTransition: he, transitionStart: fe, transitionEnd: me }; function ge (e = 0, t = this.params.speed, a = !0, s) { const i = this; let n = e; n < 0 && (n = 0); const { params: r, snapGrid: o, slidesGrid: l, previousIndex: d, activeIndex: c, rtlTranslate: p, wrapperEl: u } = i; if (i.animating && r.preventInteractionOnTransition) return !1; const h = Math.min(i.params.slidesPerGroupSkip, n); let f = h + Math.floor((n - h) / i.params.slidesPerGroup); f >= o.length && (f = o.length - 1), (c || r.initialSlide || 0) === (d || 0) && a && i.emit('beforeSlideChangeStart'); const m = -o[f]; if (i.updateProgress(m), r.normalizeSlideIndex) for (let g = 0; g < l.length; g += 1)-Math.floor(100 * m) >= Math.floor(100 * l[g]) && (n = g); if (i.initialized && n !== c) { if (!i.allowSlideNext && m < i.translate && m < i.minTranslate()) return !1; if (!i.allowSlidePrev && m > i.translate && m > i.maxTranslate() && (c || 0) !== n) return !1 } let v; if (v = n > c ? 'next' : n < c ? 'prev' : 'reset', p && -m === i.translate || !p && m === i.translate) return i.updateActiveIndex(n), r.autoHeight && i.updateAutoHeight(), i.updateSlidesClasses(), r.effect !== 'slide' && i.setTranslate(m), v !== 'reset' && (i.transitionStart(a, v), i.transitionEnd(a, v)), !1; if (r.cssMode) { const e = i.isHorizontal(); return t === 0 ? u[e ? 'scrollLeft' : 'scrollTop'] = -m : u.scrollTo ? u.scrollTo({ [e ? 'left' : 'top']: -m, behavior: 'smooth' }) : u[e ? 'scrollLeft' : 'scrollTop'] = -m, !0 } return t === 0 ? (i.setTransition(0), i.setTranslate(m), i.updateActiveIndex(n), i.updateSlidesClasses(), i.emit('beforeTransitionStart', t, s), i.transitionStart(a, v), i.transitionEnd(a, v)) : (i.setTransition(t), i.setTranslate(m), i.updateActiveIndex(n), i.updateSlidesClasses(), i.emit('beforeTransitionStart', t, s), i.transitionStart(a, v), i.animating || (i.animating = !0, i.onSlideToWrapperTransitionEnd || (i.onSlideToWrapperTransitionEnd = function (e) { i && !i.destroyed && e.target === this && (i.$wrapperEl[0].removeEventListener('transitionend', i.onSlideToWrapperTransitionEnd), i.$wrapperEl[0].removeEventListener('webkitTransitionEnd', i.onSlideToWrapperTransitionEnd), i.onSlideToWrapperTransitionEnd = null, delete i.onSlideToWrapperTransitionEnd, i.transitionEnd(a, v)) }), i.$wrapperEl[0].addEventListener('transitionend', i.onSlideToWrapperTransitionEnd), i.$wrapperEl[0].addEventListener('webkitTransitionEnd', i.onSlideToWrapperTransitionEnd))), !0 } function be (e = 0, t = this.params.speed, a = !0, s) { const i = this; let n = e; return i.params.loop && (n += i.loopedSlides), i.slideTo(n, t, a, s) } function we (e = this.params.speed, t = !0, a) { const s = this; const { params: i, animating: n } = s; const r = s.activeIndex < i.slidesPerGroupSkip ? 1 : i.slidesPerGroup; if (i.loop) { if (n) return !1; s.loopFix(), s._clientLeft = s.$wrapperEl[0].clientLeft } return s.slideTo(s.activeIndex + r, e, t, a) } function ye (e = this.params.speed, t = !0, a) { const s = this; const { params: i, animating: n, snapGrid: r, slidesGrid: o, rtlTranslate: l } = s; if (i.loop) { if (n) return !1; s.loopFix(), s._clientLeft = s.$wrapperEl[0].clientLeft } const d = l ? s.translate : -s.translate; function c (e) { return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e) } const p = c(d); const u = r.map(e => c(e)); o.map(e => c(e)), r[u.indexOf(p)]; let h; let f = r[u.indexOf(p) - 1]; return typeof f === 'undefined' && i.cssMode && r.forEach(e => { !f && p >= e && (f = e) }), typeof f !== 'undefined' && (h = o.indexOf(f), h < 0 && (h = s.activeIndex - 1)), s.slideTo(h, e, t, a) } function xe (e = this.params.speed, t = !0, a) { const s = this; return s.slideTo(s.activeIndex, e, t, a) } function Ee (e = this.params.speed, t = !0, a, s = 0.5) { const i = this; let n = i.activeIndex; const r = Math.min(i.params.slidesPerGroupSkip, n); const o = r + Math.floor((n - r) / i.params.slidesPerGroup); const l = i.rtlTranslate ? i.translate : -i.translate; if (l >= i.snapGrid[o]) { const e = i.snapGrid[o]; const t = i.snapGrid[o + 1]; l - e > (t - e) * s && (n += i.params.slidesPerGroup) } else { const e = i.snapGrid[o - 1]; const t = i.snapGrid[o]; l - e <= (t - e) * s && (n -= i.params.slidesPerGroup) } return n = Math.max(n, 0), n = Math.min(n, i.slidesGrid.length - 1), i.slideTo(n, e, t, a) } function Te () { const e = this; const { params: t, $wrapperEl: a } = e; const s = t.slidesPerView === 'auto' ? e.slidesPerViewDynamic() : t.slidesPerView; let i; let n = e.clickedIndex; if (t.loop) { if (e.animating) return; i = parseInt(o(e.clickedSlide).attr('data-swiper-slide-index'), 10), t.centeredSlides ? n < e.loopedSlides - s / 2 || n > e.slides.length - e.loopedSlides + s / 2 ? (e.loopFix(), n = a.children(`.${t.slideClass}[data-swiper-slide-index="${i}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), _.nextTick(() => { e.slideTo(n) })) : e.slideTo(n) : n > e.slides.length - s ? (e.loopFix(), n = a.children(`.${t.slideClass}[data-swiper-slide-index="${i}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), _.nextTick(() => { e.slideTo(n) })) : e.slideTo(n) } else e.slideTo(n) } const Se = { slideTo: ge, slideToLoop: be, slideNext: we, slidePrev: ye, slideReset: xe, slideToClosest: Ee, slideToClickedSlide: Te }; function Ce () { const e = this; const { params: t, $wrapperEl: a } = e; a.children(`.${t.slideClass}.${t.slideDuplicateClass}`).remove(); let s = a.children(`.${t.slideClass}`); if (t.loopFillGroupWithBlank) { const e = t.slidesPerGroup - s.length % t.slidesPerGroup; if (e !== t.slidesPerGroup) { for (let s = 0; s < e; s += 1) { const e = o(i.createElement('div')).addClass(`${t.slideClass} ${t.slideBlankClass}`); a.append(e) }s = a.children(`.${t.slideClass}`) } }t.slidesPerView !== 'auto' || t.loopedSlides || (t.loopedSlides = s.length), e.loopedSlides = Math.ceil(parseFloat(t.loopedSlides || t.slidesPerView, 10)), e.loopedSlides += t.loopAdditionalSlides, e.loopedSlides > s.length && (e.loopedSlides = s.length); const n = []; const r = []; s.each((t, a) => { const i = o(a); t < e.loopedSlides && r.push(a), t < s.length && t >= s.length - e.loopedSlides && n.push(a), i.attr('data-swiper-slide-index', t) }); for (let i = 0; i < r.length; i += 1)a.append(o(r[i].cloneNode(!0)).addClass(t.slideDuplicateClass)); for (let i = n.length - 1; i >= 0; i -= 1)a.prepend(o(n[i].cloneNode(!0)).addClass(t.slideDuplicateClass)) } function Me () { const e = this; e.emit('beforeLoopFix'); const { activeIndex: t, slides: a, loopedSlides: s, allowSlidePrev: i, allowSlideNext: n, snapGrid: r, rtlTranslate: o } = e; let l; e.allowSlidePrev = !0, e.allowSlideNext = !0; const d = -r[t]; const c = d - e.getTranslate(); if (t < s) { l = a.length - 3 * s + t, l += s; const i = e.slideTo(l, 0, !1, !0); i && c !== 0 && e.setTranslate((o ? -e.translate : e.translate) - c) } else if (t >= a.length - s) { l = -a.length + t + s, l += s; const i = e.slideTo(l, 0, !1, !0); i && c !== 0 && e.setTranslate((o ? -e.translate : e.translate) - c) }e.allowSlidePrev = i, e.allowSlideNext = n, e.emit('loopFix') } function $e () { const e = this; const { $wrapperEl: t, params: a, slides: s } = e; t.children(`.${a.slideClass}.${a.slideDuplicateClass},.${a.slideClass}.${a.slideBlankClass}`).remove(), s.removeAttr('data-swiper-slide-index') } const Pe = { loopCreate: Ce, loopFix: Me, loopDestroy: $e }; function ke (e) { const t = this; if (U.touch || !t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return; const a = t.el; a.style.cursor = 'move', a.style.cursor = e ? '-webkit-grabbing' : '-webkit-grab', a.style.cursor = e ? '-moz-grabbin' : '-moz-grab', a.style.cursor = e ? 'grabbing' : 'grab' } function ze () { const e = this; U.touch || e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.el.style.cursor = '') } const Le = { setGrabCursor: ke, unsetGrabCursor: ze }; function Ie (e) { const t = this; const { $wrapperEl: a, params: s } = t; if (s.loop && t.loopDestroy(), typeof e === 'object' && 'length' in e) for (let i = 0; i < e.length; i += 1)e[i] && a.append(e[i]); else a.append(e); s.loop && t.loopCreate(), s.observer && U.observer || t.update() } function Oe (e) { const t = this; const { params: a, $wrapperEl: s, activeIndex: i } = t; a.loop && t.loopDestroy(); let n = i + 1; if (typeof e === 'object' && 'length' in e) { for (let t = 0; t < e.length; t += 1)e[t] && s.prepend(e[t]); n = i + e.length } else s.prepend(e); a.loop && t.loopCreate(), a.observer && U.observer || t.update(), t.slideTo(n, 0, !1) } function De (e, t) { const a = this; const { $wrapperEl: s, params: i, activeIndex: n } = a; let r = n; i.loop && (r -= a.loopedSlides, a.loopDestroy(), a.slides = s.children(`.${i.slideClass}`)); const o = a.slides.length; if (e <= 0) return void a.prependSlide(t); if (e >= o) return void a.appendSlide(t); let l = r > e ? r + 1 : r; const d = []; for (let c = o - 1; c >= e; c -= 1) { const e = a.slides.eq(c); e.remove(), d.unshift(e) } if (typeof t === 'object' && 'length' in t) { for (let e = 0; e < t.length; e += 1)t[e] && s.append(t[e]); l = r > e ? r + t.length : r } else s.append(t); for (let c = 0; c < d.length; c += 1)s.append(d[c]); i.loop && a.loopCreate(), i.observer && U.observer || a.update(), i.loop ? a.slideTo(l + a.loopedSlides, 0, !1) : a.slideTo(l, 0, !1) } function Ae (e) { const t = this; const { params: a, $wrapperEl: s, activeIndex: i } = t; let n = i; a.loop && (n -= t.loopedSlides, t.loopDestroy(), t.slides = s.children(`.${a.slideClass}`)); let r; let o = n; if (typeof e === 'object' && 'length' in e) { for (let a = 0; a < e.length; a += 1)r = e[a], t.slides[r] && t.slides.eq(r).remove(), r < o && (o -= 1); o = Math.max(o, 0) } else r = e, t.slides[r] && t.slides.eq(r).remove(), r < o && (o -= 1), o = Math.max(o, 0); a.loop && t.loopCreate(), a.observer && U.observer || t.update(), a.loop ? t.slideTo(o + t.loopedSlides, 0, !1) : t.slideTo(o, 0, !1) } function Ge () { const e = this; const t = []; for (let a = 0; a < e.slides.length; a += 1)t.push(a); e.removeSlide(t) } const Be = { appendSlide: Ie, prependSlide: Oe, addSlide: De, removeSlide: Ae, removeAllSlides: Ge }; const Ne = (function () { const e = n.navigator.platform; const t = n.navigator.userAgent; const a = { ios: !1, android: !1, androidChrome: !1, desktop: !1, iphone: !1, ipod: !1, ipad: !1, edge: !1, ie: !1, firefox: !1, macos: !1, windows: !1, cordova: !(!n.cordova && !n.phonegap), phonegap: !(!n.cordova && !n.phonegap), electron: !1 }; const s = n.screen.width; const i = n.screen.height; const r = t.match(/(Android);?[\s\/]+([\d.]+)?/); let o = t.match(/(iPad).*OS\s([\d_]+)/); const l = t.match(/(iPod)(.*OS\s([\d_]+))?/); const d = !o && t.match(/(iPhone\sOS|iOS)\s([\d_]+)/); const c = t.indexOf('MSIE ') >= 0 || t.indexOf('Trident/') >= 0; const p = t.indexOf('Edge/') >= 0; const u = t.indexOf('Gecko/') >= 0 && t.indexOf('Firefox/') >= 0; const h = e === 'Win32'; const f = t.toLowerCase().indexOf('electron') >= 0; let m = e === 'MacIntel'; return !o && m && U.touch && (s === 1024 && i === 1366 || s === 834 && i === 1194 || s === 834 && i === 1112 || s === 768 && i === 1024) && (o = t.match(/(Version)\/([\d.]+)/), m = !1), a.ie = c, a.edge = p, a.firefox = u, r && !h && (a.os = 'android', a.osVersion = r[2], a.android = !0, a.androidChrome = t.toLowerCase().indexOf('chrome') >= 0), (o || d || l) && (a.os = 'ios', a.ios = !0), d && !l && (a.osVersion = d[2].replace(/_/g, '.'), a.iphone = !0), o && (a.osVersion = o[2].replace(/_/g, '.'), a.ipad = !0), l && (a.osVersion = l[3] ? l[3].replace(/_/g, '.') : null, a.ipod = !0), a.ios && a.osVersion && t.indexOf('Version/') >= 0 && a.osVersion.split('.')[0] === '10' && (a.osVersion = t.toLowerCase().split('version/')[1].split(' ')[0]), a.webView = !(!(d || o || l) || !t.match(/.*AppleWebKit(?!.*Safari)/i) && !n.navigator.standalone) || n.matchMedia && n.matchMedia('(display-mode: standalone)').matches, a.webview = a.webView, a.standalone = a.webView, a.desktop = !(a.ios || a.android) || f, a.desktop && (a.electron = f, a.macos = m, a.windows = h, a.macos && (a.os = 'macos'), a.windows && (a.os = 'windows')), a.pixelRatio = n.devicePixelRatio || 1, a }()); function He (e) { const t = this; const a = t.touchEventsData; const { params: s, touches: r } = t; if (t.animating && s.preventInteractionOnTransition) return; let l = e; l.originalEvent && (l = l.originalEvent); const d = o(l.target); if (s.touchEventsTarget === 'wrapper' && !d.closest(t.wrapperEl).length) return; if (a.isTouchEvent = l.type === 'touchstart', !a.isTouchEvent && 'which' in l && l.which === 3) return; if (!a.isTouchEvent && 'button' in l && l.button > 0) return; if (a.isTouched && a.isMoved) return; if (s.noSwiping && d.closest(s.noSwipingSelector ? s.noSwipingSelector : `.${s.noSwipingClass}`)[0]) return void (t.allowClick = !0); if (s.swipeHandler && !d.closest(s.swipeHandler)[0]) return; r.currentX = l.type === 'touchstart' ? l.targetTouches[0].pageX : l.pageX, r.currentY = l.type === 'touchstart' ? l.targetTouches[0].pageY : l.pageY; const c = r.currentX; const p = r.currentY; const u = s.edgeSwipeDetection || s.iOSEdgeSwipeDetection; const h = s.edgeSwipeThreshold || s.iOSEdgeSwipeThreshold; if (!u || !(c <= h || c >= n.screen.width - h)) { if (_.extend(a, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), r.startX = c, r.startY = p, a.touchStartTime = _.now(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, s.threshold > 0 && (a.allowThresholdMove = !1), l.type !== 'touchstart') { let e = !0; d.is(a.formElements) && (e = !1), i.activeElement && o(i.activeElement).is(a.formElements) && i.activeElement !== d[0] && i.activeElement.blur(); const n = e && t.allowTouchMove && s.touchStartPreventDefault; (s.touchStartForcePreventDefault || n) && l.preventDefault() }t.emit('touchStart', l) } } function Xe (e) { const t = this; const a = t.touchEventsData; const { params: s, touches: n, rtlTranslate: r } = t; let l = e; if (l.originalEvent && (l = l.originalEvent), !a.isTouched) return void (a.startMoving && a.isScrolling && t.emit('touchMoveOpposite', l)); if (a.isTouchEvent && l.type === 'mousemove') return; const d = l.type === 'touchmove' && l.targetTouches && (l.targetTouches[0] || l.changedTouches[0]); const c = l.type === 'touchmove' ? d.pageX : l.pageX; const p = l.type === 'touchmove' ? d.pageY : l.pageY; if (l.preventedByNestedSwiper) return n.startX = c, void (n.startY = p); if (!t.allowTouchMove) return t.allowClick = !1, void (a.isTouched && (_.extend(n, { startX: c, startY: p, currentX: c, currentY: p }), a.touchStartTime = _.now())); if (a.isTouchEvent && s.touchReleaseOnEdges && !s.loop) if (t.isVertical()) { if (p < n.startY && t.translate <= t.maxTranslate() || p > n.startY && t.translate >= t.minTranslate()) return a.isTouched = !1, void (a.isMoved = !1) } else if (c < n.startX && t.translate <= t.maxTranslate() || c > n.startX && t.translate >= t.minTranslate()) return; if (a.isTouchEvent && i.activeElement && l.target === i.activeElement && o(l.target).is(a.formElements)) return a.isMoved = !0, void (t.allowClick = !1); if (a.allowTouchCallbacks && t.emit('touchMove', l), l.targetTouches && l.targetTouches.length > 1) return; n.currentX = c, n.currentY = p; const u = n.currentX - n.startX; const h = n.currentY - n.startY; if (t.params.threshold && Math.sqrt(u ** 2 + h ** 2) < t.params.threshold) return; if (typeof a.isScrolling === 'undefined') { let e; t.isHorizontal() && n.currentY === n.startY || t.isVertical() && n.currentX === n.startX ? a.isScrolling = !1 : u * u + h * h >= 25 && (e = 180 * Math.atan2(Math.abs(h), Math.abs(u)) / Math.PI, a.isScrolling = t.isHorizontal() ? e > s.touchAngle : 90 - e > s.touchAngle) } if (a.isScrolling && t.emit('touchMoveOpposite', l), typeof a.startMoving === 'undefined' && (n.currentX === n.startX && n.currentY === n.startY || (a.startMoving = !0)), a.isScrolling) return void (a.isTouched = !1); if (!a.startMoving) return; t.allowClick = !1, s.cssMode || l.preventDefault(), s.touchMoveStopPropagation && !s.nested && l.stopPropagation(), a.isMoved || (s.loop && t.loopFix(), a.startTranslate = t.getTranslate(), t.setTransition(0), t.animating && t.$wrapperEl.trigger('webkitTransitionEnd transitionend'), a.allowMomentumBounce = !1, !s.grabCursor || !0 !== t.allowSlideNext && !0 !== t.allowSlidePrev || t.setGrabCursor(!0), t.emit('sliderFirstMove', l)), t.emit('sliderMove', l), a.isMoved = !0; let f = t.isHorizontal() ? u : h; n.diff = f, f *= s.touchRatio, r && (f = -f), t.swipeDirection = f > 0 ? 'prev' : 'next', a.currentTranslate = f + a.startTranslate; let m = !0; let v = s.resistanceRatio; if (s.touchReleaseOnEdges && (v = 0), f > 0 && a.currentTranslate > t.minTranslate() ? (m = !1, s.resistance && (a.currentTranslate = t.minTranslate() - 1 + (-t.minTranslate() + a.startTranslate + f) ** v)) : f < 0 && a.currentTranslate < t.maxTranslate() && (m = !1, s.resistance && (a.currentTranslate = t.maxTranslate() + 1 - (t.maxTranslate() - a.startTranslate - f) ** v)), m && (l.preventedByNestedSwiper = !0), !t.allowSlideNext && t.swipeDirection === 'next' && a.currentTranslate < a.startTranslate && (a.currentTranslate = a.startTranslate), !t.allowSlidePrev && t.swipeDirection === 'prev' && a.currentTranslate > a.startTranslate && (a.currentTranslate = a.startTranslate), s.threshold > 0) { if (!(Math.abs(f) > s.threshold || a.allowThresholdMove)) return void (a.currentTranslate = a.startTranslate); if (!a.allowThresholdMove) return a.allowThresholdMove = !0, n.startX = n.currentX, n.startY = n.currentY, a.currentTranslate = a.startTranslate, void (n.diff = t.isHorizontal() ? n.currentX - n.startX : n.currentY - n.startY) }s.followFinger && !s.cssMode && ((s.freeMode || s.watchSlidesProgress || s.watchSlidesVisibility) && (t.updateActiveIndex(), t.updateSlidesClasses()), s.freeMode && (a.velocities.length === 0 && a.velocities.push({ position: n[t.isHorizontal() ? 'startX' : 'startY'], time: a.touchStartTime }), a.velocities.push({ position: n[t.isHorizontal() ? 'currentX' : 'currentY'], time: _.now() })), t.updateProgress(a.currentTranslate), t.setTranslate(a.currentTranslate)) } function Ve (e) { const t = this; const a = t.touchEventsData; const { params: s, touches: i, rtlTranslate: n, $wrapperEl: r, slidesGrid: o, snapGrid: l } = t; let d = e; if (d.originalEvent && (d = d.originalEvent), a.allowTouchCallbacks && t.emit('touchEnd', d), a.allowTouchCallbacks = !1, !a.isTouched) return a.isMoved && s.grabCursor && t.setGrabCursor(!1), a.isMoved = !1, void (a.startMoving = !1); s.grabCursor && a.isMoved && a.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1); const c = _.now(); const p = c - a.touchStartTime; if (t.allowClick && (t.updateClickedSlide(d), t.emit('tap click', d), p < 300 && c - a.lastClickTime < 300 && t.emit('doubleTap doubleClick', d)), a.lastClickTime = _.now(), _.nextTick(() => { t.destroyed || (t.allowClick = !0) }), !a.isTouched || !a.isMoved || !t.swipeDirection || i.diff === 0 || a.currentTranslate === a.startTranslate) return a.isTouched = !1, a.isMoved = !1, void (a.startMoving = !1); let u; if (a.isTouched = !1, a.isMoved = !1, a.startMoving = !1, u = s.followFinger ? n ? t.translate : -t.translate : -a.currentTranslate, s.cssMode) return; if (s.freeMode) { if (u < -t.minTranslate()) return void t.slideTo(t.activeIndex); if (u > -t.maxTranslate()) return void (t.slides.length < l.length ? t.slideTo(l.length - 1) : t.slideTo(t.slides.length - 1)); if (s.freeModeMomentum) { if (a.velocities.length > 1) { const e = a.velocities.pop(); const i = a.velocities.pop(); const n = e.position - i.position; const r = e.time - i.time; t.velocity = n / r, t.velocity /= 2, Math.abs(t.velocity) < s.freeModeMinimumVelocity && (t.velocity = 0), (r > 150 || _.now() - e.time > 300) && (t.velocity = 0) } else t.velocity = 0; t.velocity *= s.freeModeMomentumVelocityRatio, a.velocities.length = 0; let e = 1e3 * s.freeModeMomentumRatio; const i = t.velocity * e; let o = t.translate + i; n && (o = -o); let d; let c = !1; const p = 20 * Math.abs(t.velocity) * s.freeModeMomentumBounceRatio; let u; if (o < t.maxTranslate())s.freeModeMomentumBounce ? (o + t.maxTranslate() < -p && (o = t.maxTranslate() - p), d = t.maxTranslate(), c = !0, a.allowMomentumBounce = !0) : o = t.maxTranslate(), s.loop && s.centeredSlides && (u = !0); else if (o > t.minTranslate())s.freeModeMomentumBounce ? (o - t.minTranslate() > p && (o = t.minTranslate() + p), d = t.minTranslate(), c = !0, a.allowMomentumBounce = !0) : o = t.minTranslate(), s.loop && s.centeredSlides && (u = !0); else if (s.freeModeSticky) { let e; for (let t = 0; t < l.length; t += 1) if (l[t] > -o) { e = t; break }o = Math.abs(l[e] - o) < Math.abs(l[e - 1] - o) || t.swipeDirection === 'next' ? l[e] : l[e - 1], o = -o } if (u && t.once('transitionEnd', () => { t.loopFix() }), t.velocity !== 0) { if (e = n ? Math.abs((-o - t.translate) / t.velocity) : Math.abs((o - t.translate) / t.velocity), s.freeModeSticky) { const a = Math.abs((n ? -o : o) - t.translate); const i = t.slidesSizesGrid[t.activeIndex]; e = a < i ? s.speed : a < 2 * i ? 1.5 * s.speed : 2.5 * s.speed } } else if (s.freeModeSticky) return void t.slideToClosest(); s.freeModeMomentumBounce && c ? (t.updateProgress(d), t.setTransition(e), t.setTranslate(o), t.transitionStart(!0, t.swipeDirection), t.animating = !0, r.transitionEnd(() => { t && !t.destroyed && a.allowMomentumBounce && (t.emit('momentumBounce'), t.setTransition(s.speed), t.setTranslate(d), r.transitionEnd(() => { t && !t.destroyed && t.transitionEnd() })) })) : t.velocity ? (t.updateProgress(o), t.setTransition(e), t.setTranslate(o), t.transitionStart(!0, t.swipeDirection), t.animating || (t.animating = !0, r.transitionEnd(() => { t && !t.destroyed && t.transitionEnd() }))) : t.updateProgress(o), t.updateActiveIndex(), t.updateSlidesClasses() } else if (s.freeModeSticky) return void t.slideToClosest(); return void ((!s.freeModeMomentum || p >= s.longSwipesMs) && (t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses())) } let h = 0; let f = t.slidesSizesGrid[0]; for (let g = 0; g < o.length; g += g < s.slidesPerGroupSkip ? 1 : s.slidesPerGroup) { const e = g < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup; typeof o[g + e] !== 'undefined' ? u >= o[g] && u < o[g + e] && (h = g, f = o[g + e] - o[g]) : u >= o[g] && (h = g, f = o[o.length - 1] - o[o.length - 2]) } const m = (u - o[h]) / f; const v = h < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup; if (p > s.longSwipesMs) { if (!s.longSwipes) return void t.slideTo(t.activeIndex); t.swipeDirection === 'next' && (m >= s.longSwipesRatio ? t.slideTo(h + v) : t.slideTo(h)), t.swipeDirection === 'prev' && (m > 1 - s.longSwipesRatio ? t.slideTo(h + v) : t.slideTo(h)) } else { if (!s.shortSwipes) return void t.slideTo(t.activeIndex); const e = t.navigation && (d.target === t.navigation.nextEl || d.target === t.navigation.prevEl); e ? d.target === t.navigation.nextEl ? t.slideTo(h + v) : t.slideTo(h) : (t.swipeDirection === 'next' && t.slideTo(h + v), t.swipeDirection === 'prev' && t.slideTo(h)) } } function Ye () { const e = this; const { params: t, el: a } = e; if (a && a.offsetWidth === 0) return; t.breakpoints && e.setBreakpoint(); const { allowSlideNext: s, allowSlidePrev: i, snapGrid: n } = e; e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(), (t.slidesPerView === 'auto' || t.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.run(), e.allowSlidePrev = i, e.allowSlideNext = s, e.params.watchOverflow && n !== e.snapGrid && e.checkOverflow() } function Re (e) { const t = this; t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation())) } function Fe () { const e = this; const { wrapperEl: t } = e; let a; e.previousTranslate = e.translate, e.translate = e.isHorizontal() ? -t.scrollLeft : -t.scrollTop, e.translate === -0 && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses(); const s = e.maxTranslate() - e.minTranslate(); a = s === 0 ? 0 : (e.translate - e.minTranslate()) / s, a !== e.progress && e.updateProgress(e.translate), e.emit('setTranslate', e.translate, !1) } let We = !1; function je () {} function qe () { const e = this; const { params: t, touchEvents: a, el: s, wrapperEl: n } = e; e.onTouchStart = He.bind(e), e.onTouchMove = Xe.bind(e), e.onTouchEnd = Ve.bind(e), t.cssMode && (e.onScroll = Fe.bind(e)), e.onClick = Re.bind(e); const r = !!t.nested; if (!U.touch && U.pointerEvents)s.addEventListener(a.start, e.onTouchStart, !1), i.addEventListener(a.move, e.onTouchMove, r), i.addEventListener(a.end, e.onTouchEnd, !1); else { if (U.touch) { const n = !(a.start !== 'touchstart' || !U.passiveListener || !t.passiveListeners) && { passive: !0, capture: !1 }; s.addEventListener(a.start, e.onTouchStart, n), s.addEventListener(a.move, e.onTouchMove, U.passiveListener ? { passive: !1, capture: r } : r), s.addEventListener(a.end, e.onTouchEnd, n), a.cancel && s.addEventListener(a.cancel, e.onTouchEnd, n), We || (i.addEventListener('touchstart', je), We = !0) }(t.simulateTouch && !Ne.ios && !Ne.android || t.simulateTouch && !U.touch && Ne.ios) && (s.addEventListener('mousedown', e.onTouchStart, !1), i.addEventListener('mousemove', e.onTouchMove, r), i.addEventListener('mouseup', e.onTouchEnd, !1)) }(t.preventClicks || t.preventClicksPropagation) && s.addEventListener('click', e.onClick, !0), t.cssMode && n.addEventListener('scroll', e.onScroll), t.updateOnWindowResize ? e.on(Ne.ios || Ne.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', Ye, !0) : e.on('observerUpdate', Ye, !0) } function _e () { const e = this; const { params: t, touchEvents: a, el: s, wrapperEl: n } = e; const r = !!t.nested; if (!U.touch && U.pointerEvents)s.removeEventListener(a.start, e.onTouchStart, !1), i.removeEventListener(a.move, e.onTouchMove, r), i.removeEventListener(a.end, e.onTouchEnd, !1); else { if (U.touch) { const i = !(a.start !== 'onTouchStart' || !U.passiveListener || !t.passiveListeners) && { passive: !0, capture: !1 }; s.removeEventListener(a.start, e.onTouchStart, i), s.removeEventListener(a.move, e.onTouchMove, r), s.removeEventListener(a.end, e.onTouchEnd, i), a.cancel && s.removeEventListener(a.cancel, e.onTouchEnd, i) }(t.simulateTouch && !Ne.ios && !Ne.android || t.simulateTouch && !U.touch && Ne.ios) && (s.removeEventListener('mousedown', e.onTouchStart, !1), i.removeEventListener('mousemove', e.onTouchMove, r), i.removeEventListener('mouseup', e.onTouchEnd, !1)) }(t.preventClicks || t.preventClicksPropagation) && s.removeEventListener('click', e.onClick, !0), t.cssMode && n.removeEventListener('scroll', e.onScroll), e.off(Ne.ios || Ne.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', Ye) } const Ue = { attachEvents: qe, detachEvents: _e }; function Ke () { const e = this; const { activeIndex: t, initialized: a, loopedSlides: s = 0, params: i, $el: n } = e; const r = i.breakpoints; if (!r || r && Object.keys(r).length === 0) return; const o = e.getBreakpoint(r); if (o && e.currentBreakpoint !== o) { const l = o in r ? r[o] : void 0; l && ['slidesPerView', 'spaceBetween', 'slidesPerGroup', 'slidesPerGroupSkip', 'slidesPerColumn'].forEach(e => { const t = l[e]; typeof t !== 'undefined' && (l[e] = e !== 'slidesPerView' || t !== 'AUTO' && t !== 'auto' ? e === 'slidesPerView' ? parseFloat(t) : parseInt(t, 10) : 'auto') }); const d = l || e.originalParams; const c = i.slidesPerColumn > 1; const p = d.slidesPerColumn > 1; c && !p ? n.removeClass(`${i.containerModifierClass}multirow ${i.containerModifierClass}multirow-column`) : !c && p && (n.addClass(`${i.containerModifierClass}multirow`), d.slidesPerColumnFill === 'column' && n.addClass(`${i.containerModifierClass}multirow-column`)); const u = d.direction && d.direction !== i.direction; const h = i.loop && (d.slidesPerView !== i.slidesPerView || u); u && a && e.changeDirection(), _.extend(e.params, d), _.extend(e, { allowTouchMove: e.params.allowTouchMove, allowSlideNext: e.params.allowSlideNext, allowSlidePrev: e.params.allowSlidePrev }), e.currentBreakpoint = o, h && a && (e.loopDestroy(), e.loopCreate(), e.updateSlides(), e.slideTo(t - s + e.loopedSlides, 0, !1)), e.emit('breakpoint', d) } } function Ze (e) { if (!e) return; let t = !1; const a = Object.keys(e).map(e => { if (typeof e === 'string' && e.startsWith('@')) { const t = parseFloat(e.substr(1)); const a = n.innerHeight * t; return { value: a, point: e } } return { value: e, point: e } }); a.sort((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10)); for (let s = 0; s < a.length; s += 1) { const { point: e, value: i } = a[s]; i <= n.innerWidth && (t = e) } return t || 'max' } const Qe = { setBreakpoint: Ke, getBreakpoint: Ze }; function Je () { const e = this; const { classNames: t, params: a, rtl: s, $el: i } = e; const n = []; n.push('initialized'), n.push(a.direction), a.freeMode && n.push('free-mode'), a.autoHeight && n.push('autoheight'), s && n.push('rtl'), a.slidesPerColumn > 1 && (n.push('multirow'), a.slidesPerColumnFill === 'column' && n.push('multirow-column')), Ne.android && n.push('android'), Ne.ios && n.push('ios'), a.cssMode && n.push('css-mode'), n.forEach(e => { t.push(a.containerModifierClass + e) }), i.addClass(t.join(' ')) } function et () { const e = this; const { $el: t, classNames: a } = e; t.removeClass(a.join(' ')) } const tt = { addClasses: Je, removeClasses: et }; function at (e, t, a, s, i, r) { let o; function l () { r && r() }e.complete && i ? l() : t ? (o = new n.Image(), o.onload = l, o.onerror = l, s && (o.sizes = s), a && (o.srcset = a), t && (o.src = t)) : l() } function st () { const e = this; function t () { typeof e !== 'undefined' && e !== null && e && !e.destroyed && (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1), e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(), e.emit('imagesReady'))) }e.imagesToLoad = e.$el.find('img'); for (let a = 0; a < e.imagesToLoad.length; a += 1) { const s = e.imagesToLoad[a]; e.loadImage(s, s.currentSrc || s.getAttribute('src'), s.srcset || s.getAttribute('srcset'), s.sizes || s.getAttribute('sizes'), !0, t) } } const it = { loadImage: at, preloadImages: st }; function nt () { const e = this; const t = e.params; const a = e.isLocked; const s = e.slides.length > 0 && t.slidesOffsetBefore + t.spaceBetween * (e.slides.length - 1) + e.slides[0].offsetWidth * e.slides.length; t.slidesOffsetBefore && t.slidesOffsetAfter && s ? e.isLocked = s <= e.size : e.isLocked = e.snapGrid.length === 1, e.allowSlideNext = !e.isLocked, e.allowSlidePrev = !e.isLocked, a !== e.isLocked && e.emit(e.isLocked ? 'lock' : 'unlock'), a && a !== e.isLocked && (e.isEnd = !1, e.navigation.update()) } const rt = { checkOverflow: nt }; const ot = { init: !0, direction: 'horizontal', touchEventsTarget: 'container', initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, preventInteractionOnTransition: !1, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, freeMode: !1, freeModeMomentum: !0, freeModeMomentumRatio: 1, freeModeMomentumBounce: !0, freeModeMomentumBounceRatio: 1, freeModeMomentumVelocityRatio: 1, freeModeSticky: !1, freeModeMinimumVelocity: 0.02, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: 'slide', breakpoints: void 0, spaceBetween: 0, slidesPerView: 1, slidesPerColumn: 1, slidesPerColumnFill: 'column', slidesPerGroup: 1, slidesPerGroupSkip: 0, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !1, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: 0.5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 0, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: 0.85, watchSlidesProgress: !1, watchSlidesVisibility: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, preloadImages: !0, updateOnImagesReady: !0, loop: !1, loopAdditionalSlides: 0, loopedSlides: null, loopFillGroupWithBlank: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: 'swiper-no-swiping', noSwipingSelector: null, passiveListeners: !0, containerModifierClass: 'swiper-container-', slideClass: 'swiper-slide', slideBlankClass: 'swiper-slide-invisible-blank', slideActiveClass: 'swiper-slide-active', slideDuplicateActiveClass: 'swiper-slide-duplicate-active', slideVisibleClass: 'swiper-slide-visible', slideDuplicateClass: 'swiper-slide-duplicate', slideNextClass: 'swiper-slide-next', slideDuplicateNextClass: 'swiper-slide-duplicate-next', slidePrevClass: 'swiper-slide-prev', slideDuplicatePrevClass: 'swiper-slide-duplicate-prev', wrapperClass: 'swiper-wrapper', runCallbacksOnInit: !0 }; const lt = { update: re, translate: ue, transition: ve, slide: Se, loop: Pe, grabCursor: Le, manipulation: Be, events: Ue, breakpoints: Qe, checkOverflow: rt, classes: tt, images: it }; const dt = {}; class ct extends K {constructor (...e) { let t, a; e.length === 1 && e[0].constructor && e[0].constructor === Object ? a = e[0] : [t, a] = e, a || (a = {}), a = _.extend({}, a), t && !a.el && (a.el = t), super(a), Object.keys(lt).forEach(e => { Object.keys(lt[e]).forEach(t => { ct.prototype[t] || (ct.prototype[t] = lt[e][t]) }) }); const s = this; typeof s.modules === 'undefined' && (s.modules = {}), Object.keys(s.modules).forEach(e => { const t = s.modules[e]; if (t.params) { const e = Object.keys(t.params)[0]; const s = t.params[e]; if (typeof s !== 'object' || s === null) return; if (!(e in a && 'enabled' in s)) return; !0 === a[e] && (a[e] = { enabled: !0 }), typeof a[e] !== 'object' || 'enabled' in a[e] || (a[e].enabled = !0), a[e] || (a[e] = { enabled: !1 }) } }); const i = _.extend({}, ot); s.useModulesParams(i), s.params = _.extend({}, i, dt, a), s.originalParams = _.extend({}, s.params), s.passedParams = _.extend({}, a), s.$ = o; const n = o(s.params.el); if (t = n[0], !t) return; if (n.length > 1) { const e = []; return n.each((t, s) => { const i = _.extend({}, a, { el: s }); e.push(new ct(i)) }), e } let r; return t.swiper = s, n.data('swiper', s), t && t.shadowRoot && t.shadowRoot.querySelector ? (r = o(t.shadowRoot.querySelector(`.${s.params.wrapperClass}`)), r.children = e => n.children(e)) : r = n.children(`.${s.params.wrapperClass}`), _.extend(s, { $el: n, el: t, $wrapperEl: r, wrapperEl: r[0], classNames: [], slides: o(), slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal () { return s.params.direction === 'horizontal' }, isVertical () { return s.params.direction === 'vertical' }, rtl: t.dir.toLowerCase() === 'rtl' || n.css('direction') === 'rtl', rtlTranslate: s.params.direction === 'horizontal' && (t.dir.toLowerCase() === 'rtl' || n.css('direction') === 'rtl'), wrongRTL: r.css('display') === '-webkit-box', activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, allowSlideNext: s.params.allowSlideNext, allowSlidePrev: s.params.allowSlidePrev, touchEvents: (function () { const e = ['touchstart', 'touchmove', 'touchend', 'touchcancel']; let t = ['mousedown', 'mousemove', 'mouseup']; return U.pointerEvents && (t = ['pointerdown', 'pointermove', 'pointerup']), s.touchEventsTouch = { start: e[0], move: e[1], end: e[2], cancel: e[3] }, s.touchEventsDesktop = { start: t[0], move: t[1], end: t[2] }, U.touch || !s.params.simulateTouch ? s.touchEventsTouch : s.touchEventsDesktop }()), touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, formElements: 'input, select, option, textarea, button, video, label', lastClickTime: _.now(), clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, isTouchEvent: void 0, startMoving: void 0 }, allowClick: !0, allowTouchMove: s.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), s.useModules(), s.params.init && s.init(), s }slidesPerViewDynamic () { const e = this; const { params: t, slides: a, slidesGrid: s, size: i, activeIndex: n } = e; let r = 1; if (t.centeredSlides) { let e; let t = a[n].swiperSlideSize; for (let s = n + 1; s < a.length; s += 1)a[s] && !e && (t += a[s].swiperSlideSize, r += 1, t > i && (e = !0)); for (let s = n - 1; s >= 0; s -= 1)a[s] && !e && (t += a[s].swiperSlideSize, r += 1, t > i && (e = !0)) } else for (let o = n + 1; o < a.length; o += 1)s[o] - s[n] < i && (r += 1); return r }update () { const e = this; if (!e || e.destroyed) return; const { snapGrid: t, params: a } = e; function s () { const t = e.rtlTranslate ? -1 * e.translate : e.translate; const a = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate()); e.setTranslate(a), e.updateActiveIndex(), e.updateSlidesClasses() } let i; a.breakpoints && e.setBreakpoint(), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.params.freeMode ? (s(), e.params.autoHeight && e.updateAutoHeight()) : (i = (e.params.slidesPerView === 'auto' || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), i || s()), a.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit('update') }changeDirection (e, t = !0) { const a = this; const s = a.params.direction; return e || (e = s === 'horizontal' ? 'vertical' : 'horizontal'), e === s || e !== 'horizontal' && e !== 'vertical' ? a : (a.$el.removeClass(`${a.params.containerModifierClass}${s}`).addClass(`${a.params.containerModifierClass}${e}`), a.params.direction = e, a.slides.each((t, a) => { e === 'vertical' ? a.style.width = '' : a.style.height = '' }), a.emit('changeDirection'), t && a.update(), a) }init () { const e = this; e.initialized || (e.emit('beforeInit'), e.params.breakpoints && e.setBreakpoint(), e.addClasses(), e.params.loop && e.loopCreate(), e.updateSize(), e.updateSlides(), e.params.watchOverflow && e.checkOverflow(), e.params.grabCursor && e.setGrabCursor(), e.params.preloadImages && e.preloadImages(), e.params.loop ? e.slideTo(e.params.initialSlide + e.loopedSlides, 0, e.params.runCallbacksOnInit) : e.slideTo(e.params.initialSlide, 0, e.params.runCallbacksOnInit), e.attachEvents(), e.initialized = !0, e.emit('init')) }destroy (e = !0, t = !0) { const a = this; const { params: s, $el: i, $wrapperEl: n, slides: r } = a; return typeof a.params === 'undefined' || a.destroyed ? null : (a.emit('beforeDestroy'), a.initialized = !1, a.detachEvents(), s.loop && a.loopDestroy(), t && (a.removeClasses(), i.removeAttr('style'), n.removeAttr('style'), r && r.length && r.removeClass([s.slideVisibleClass, s.slideActiveClass, s.slideNextClass, s.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index')), a.emit('destroy'), Object.keys(a.eventsListeners).forEach(e => { a.off(e) }), !1 !== e && (a.$el[0].swiper = null, a.$el.data('swiper', null), _.deleteProps(a)), a.destroyed = !0, null) } static extendDefaults (e) { _.extend(dt, e) } static get extendedDefaults () { return dt } static get defaults () { return ot } static get Class () { return K } static get $ () { return o }} const pt = { name: 'device', proto: { device: Ne }, static: { device: Ne } }; const ut = { name: 'support', proto: { support: U }, static: { support: U } }; const ht = (function () { function e () { const e = n.navigator.userAgent.toLowerCase(); return e.indexOf('safari') >= 0 && e.indexOf('chrome') < 0 && e.indexOf('android') < 0 } return { isEdge: !!n.navigator.userAgent.match(/Edge/g), isSafari: e(), isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(n.navigator.userAgent) } }()); const ft = { name: 'browser', proto: { browser: ht }, static: { browser: ht } }; const mt = { name: 'resize', create () { const e = this; _.extend(e, { resize: { resizeHandler () { e && !e.destroyed && e.initialized && (e.emit('beforeResize'), e.emit('resize')) }, orientationChangeHandler () { e && !e.destroyed && e.initialized && e.emit('orientationchange') } } }) }, on: { init () { const e = this; n.addEventListener('resize', e.resize.resizeHandler), n.addEventListener('orientationchange', e.resize.orientationChangeHandler) }, destroy () { const e = this; n.removeEventListener('resize', e.resize.resizeHandler), n.removeEventListener('orientationchange', e.resize.orientationChangeHandler) } } }; const vt = { func: n.MutationObserver || n.WebkitMutationObserver, attach (e, t = {}) { const a = this; const s = vt.func; const i = new s(e => { if (e.length === 1) return void a.emit('observerUpdate', e[0]); const t = function () { a.emit('observerUpdate', e[0]) }; n.requestAnimationFrame ? n.requestAnimationFrame(t) : n.setTimeout(t, 0) }); i.observe(e, { attributes: typeof t.attributes === 'undefined' || t.attributes, childList: typeof t.childList === 'undefined' || t.childList, characterData: typeof t.characterData === 'undefined' || t.characterData }), a.observer.observers.push(i) }, init () { const e = this; if (U.observer && e.params.observer) { if (e.params.observeParents) { const t = e.$el.parents(); for (let a = 0; a < t.length; a += 1)e.observer.attach(t[a]) }e.observer.attach(e.$el[0], { childList: e.params.observeSlideChildren }), e.observer.attach(e.$wrapperEl[0], { attributes: !1 }) } }, destroy () { const e = this; e.observer.observers.forEach(e => { e.disconnect() }), e.observer.observers = [] } }; const gt = { name: 'observer', params: { observer: !1, observeParents: !1, observeSlideChildren: !1 }, create () { const e = this; _.extend(e, { observer: { init: vt.init.bind(e), attach: vt.attach.bind(e), destroy: vt.destroy.bind(e), observers: [] } }) }, on: { init () { const e = this; e.observer.init() }, destroy () { const e = this; e.observer.destroy() } } }; const bt = { update (e) { const t = this; const { slidesPerView: a, slidesPerGroup: s, centeredSlides: i } = t.params; const { addSlidesBefore: n, addSlidesAfter: r } = t.params.virtual; const { from: o, to: l, slides: d, slidesGrid: c, renderSlide: p, offset: u } = t.virtual; t.updateActiveIndex(); const h = t.activeIndex || 0; let f, m, v; f = t.rtlTranslate ? 'right' : t.isHorizontal() ? 'left' : 'top', i ? (m = Math.floor(a / 2) + s + n, v = Math.floor(a / 2) + s + r) : (m = a + (s - 1) + n, v = s + r); const g = Math.max((h || 0) - v, 0); const b = Math.min((h || 0) + m, d.length - 1); const w = (t.slidesGrid[g] || 0) - (t.slidesGrid[0] || 0); function y () { t.updateSlides(), t.updateProgress(), t.updateSlidesClasses(), t.lazy && t.params.lazy.enabled && t.lazy.load() } if (_.extend(t.virtual, { from: g, to: b, offset: w, slidesGrid: t.slidesGrid }), o === g && l === b && !e) return t.slidesGrid !== c && w !== u && t.slides.css(f, `${w}px`), void t.updateProgress(); if (t.params.virtual.renderExternal) return t.params.virtual.renderExternal.call(t, { offset: w, from: g, to: b, slides: (function () { const e = []; for (let t = g; t <= b; t += 1)e.push(d[t]); return e }()) }), void y(); const x = []; const E = []; if (e)t.$wrapperEl.find(`.${t.params.slideClass}`).remove(); else for (let T = o; T <= l; T += 1)(T < g || T > b) && t.$wrapperEl.find(`.${t.params.slideClass}[data-swiper-slide-index="${T}"]`).remove(); for (let T = 0; T < d.length; T += 1)T >= g && T <= b && (typeof l === 'undefined' || e ? E.push(T) : (T > l && E.push(T), T < o && x.push(T))); E.forEach(e => { t.$wrapperEl.append(p(d[e], e)) }), x.sort((e, t) => t - e).forEach(e => { t.$wrapperEl.prepend(p(d[e], e)) }), t.$wrapperEl.children('.swiper-slide').css(f, `${w}px`), y() }, renderSlide (e, t) { const a = this; const s = a.params.virtual; if (s.cache && a.virtual.cache[t]) return a.virtual.cache[t]; const i = s.renderSlide ? o(s.renderSlide.call(a, e, t)) : o(`<div class="${a.params.slideClass}" data-swiper-slide-index="${t}">${e}</div>`); return i.attr('data-swiper-slide-index') || i.attr('data-swiper-slide-index', t), s.cache && (a.virtual.cache[t] = i), i }, appendSlide (e) { const t = this; if (typeof e === 'object' && 'length' in e) for (let a = 0; a < e.length; a += 1)e[a] && t.virtual.slides.push(e[a]); else t.virtual.slides.push(e); t.virtual.update(!0) }, prependSlide (e) { const t = this; const a = t.activeIndex; let s = a + 1; let i = 1; if (Array.isArray(e)) { for (let a = 0; a < e.length; a += 1)e[a] && t.virtual.slides.unshift(e[a]); s = a + e.length, i = e.length } else t.virtual.slides.unshift(e); if (t.params.virtual.cache) { const e = t.virtual.cache; const a = {}; Object.keys(e).forEach(t => { const s = e[t]; const n = s.attr('data-swiper-slide-index'); n && s.attr('data-swiper-slide-index', parseInt(n, 10) + 1), a[parseInt(t, 10) + i] = s }), t.virtual.cache = a }t.virtual.update(!0), t.slideTo(s, 0) }, removeSlide (e) { const t = this; if (typeof e === 'undefined' || e === null) return; let a = t.activeIndex; if (Array.isArray(e)) for (let s = e.length - 1; s >= 0; s -= 1)t.virtual.slides.splice(e[s], 1), t.params.virtual.cache && delete t.virtual.cache[e[s]], e[s] < a && (a -= 1), a = Math.max(a, 0); else t.virtual.slides.splice(e, 1), t.params.virtual.cache && delete t.virtual.cache[e], e < a && (a -= 1), a = Math.max(a, 0); t.virtual.update(!0), t.slideTo(a, 0) }, removeAllSlides () { const e = this; e.virtual.slides = [], e.params.virtual.cache && (e.virtual.cache = {}), e.virtual.update(!0), e.slideTo(0, 0) } }; const wt = { name: 'virtual', params: { virtual: { enabled: !1, slides: [], cache: !0, renderSlide: null, renderExternal: null, addSlidesBefore: 0, addSlidesAfter: 0 } }, create () { const e = this; _.extend(e, { virtual: { update: bt.update.bind(e), appendSlide: bt.appendSlide.bind(e), prependSlide: bt.prependSlide.bind(e), removeSlide: bt.removeSlide.bind(e), removeAllSlides: bt.removeAllSlides.bind(e), renderSlide: bt.renderSlide.bind(e), slides: e.params.virtual.slides, cache: {} } }) }, on: { beforeInit () { const e = this; if (!e.params.virtual.enabled) return; e.classNames.push(`${e.params.containerModifierClass}virtual`); const t = { watchSlidesProgress: !0 }; _.extend(e.params, t), _.extend(e.originalParams, t), e.params.initialSlide || e.virtual.update() }, setTranslate () { const e = this; e.params.virtual.enabled && e.virtual.update() } } }; const yt = { handle (e) { const t = this; const { rtlTranslate: a } = t; let s = e; s.originalEvent && (s = s.originalEvent); const r = s.keyCode || s.charCode; if (!t.allowSlideNext && (t.isHorizontal() && r === 39 || t.isVertical() && r === 40 || r === 34)) return !1; if (!t.allowSlidePrev && (t.isHorizontal() && r === 37 || t.isVertical() && r === 38 || r === 33)) return !1; if (!(s.shiftKey || s.altKey || s.ctrlKey || s.metaKey) && (!i.activeElement || !i.activeElement.nodeName || i.activeElement.nodeName.toLowerCase() !== 'input' && i.activeElement.nodeName.toLowerCase() !== 'textarea')) { if (t.params.keyboard.onlyInViewport && (r === 33 || r === 34 || r === 37 || r === 39 || r === 38 || r === 40)) { let e = !1; if (t.$el.parents(`.${t.params.slideClass}`).length > 0 && t.$el.parents(`.${t.params.slideActiveClass}`).length === 0) return; const s = n.innerWidth; const i = n.innerHeight; const r = t.$el.offset(); a && (r.left -= t.$el[0].scrollLeft); const o = [[r.left, r.top], [r.left + t.width, r.top], [r.left, r.top + t.height], [r.left + t.width, r.top + t.height]]; for (let t = 0; t < o.length; t += 1) { const a = o[t]; a[0] >= 0 && a[0] <= s && a[1] >= 0 && a[1] <= i && (e = !0) } if (!e) return }t.isHorizontal() ? (r !== 33 && r !== 34 && r !== 37 && r !== 39 || (s.preventDefault ? s.preventDefault() : s.returnValue = !1), (r !== 34 && r !== 39 || a) && (r !== 33 && r !== 37 || !a) || t.slideNext(), (r !== 33 && r !== 37 || a) && (r !== 34 && r !== 39 || !a) || t.slidePrev()) : (r !== 33 && r !== 34 && r !== 38 && r !== 40 || (s.preventDefault ? s.preventDefault() : s.returnValue = !1), r !== 34 && r !== 40 || t.slideNext(), r !== 33 && r !== 38 || t.slidePrev()), t.emit('keyPress', r) } }, enable () { const e = this; e.keyboard.enabled || (o(i).on('keydown', e.keyboard.handle), e.keyboard.enabled = !0) }, disable () { const e = this; e.keyboard.enabled && (o(i).off('keydown', e.keyboard.handle), e.keyboard.enabled = !1) } }; const xt = { name: 'keyboard', params: { keyboard: { enabled: !1, onlyInViewport: !0 } }, create () { const e = this; _.extend(e, { keyboard: { enabled: !1, enable: yt.enable.bind(e), disable: yt.disable.bind(e), handle: yt.handle.bind(e) } }) }, on: { init () { const e = this; e.params.keyboard.enabled && e.keyboard.enable() }, destroy () { const e = this; e.keyboard.enabled && e.keyboard.disable() } } }; function Et () { const e = 'onwheel'; let t = e in i; if (!t) { const a = i.createElement('div'); a.setAttribute(e, 'return;'), t = typeof a[e] === 'function' } return !t && i.implementation && i.implementation.hasFeature && !0 !== i.implementation.hasFeature('', '') && (t = i.implementation.hasFeature('Events.wheel', '3.0')), t } const Tt = { lastScrollTime: _.now(), lastEventBeforeSnap: void 0, recentWheelEvents: [], event () { return n.navigator.userAgent.indexOf('firefox') > -1 ? 'DOMMouseScroll' : Et() ? 'wheel' : 'mousewheel' }, normalize (e) { const t = 10; const a = 40; const s = 800; let i = 0; let n = 0; let r = 0; let o = 0; return 'detail' in e && (n = e.detail), 'wheelDelta' in e && (n = -e.wheelDelta / 120), 'wheelDeltaY' in e && (n = -e.wheelDeltaY / 120), 'wheelDeltaX' in e && (i = -e.wheelDeltaX / 120), 'axis' in e && e.axis === e.HORIZONTAL_AXIS && (i = n, n = 0), r = i * t, o = n * t, 'deltaY' in e && (o = e.deltaY), 'deltaX' in e && (r = e.deltaX), e.shiftKey && !r && (r = o, o = 0), (r || o) && e.deltaMode && (e.deltaMode === 1 ? (r *= a, o *= a) : (r *= s, o *= s)), r && !i && (i = r < 1 ? -1 : 1), o && !n && (n = o < 1 ? -1 : 1), { spinX: i, spinY: n, pixelX: r, pixelY: o } }, handleMouseEnter () { const e = this; e.mouseEntered = !0 }, handleMouseLeave () { const e = this; e.mouseEntered = !1 }, handle (e) { let t = e; const a = this; const s = a.params.mousewheel; a.params.cssMode && t.preventDefault(); let i = a.$el; if (a.params.mousewheel.eventsTarged !== 'container' && (i = o(a.params.mousewheel.eventsTarged)), !a.mouseEntered && !i[0].contains(t.target) && !s.releaseOnEdges) return !0; t.originalEvent && (t = t.originalEvent); let n = 0; const r = a.rtlTranslate ? -1 : 1; const l = Tt.normalize(t); if (s.forceToAxis) if (a.isHorizontal()) { if (!(Math.abs(l.pixelX) > Math.abs(l.pixelY))) return !0; n = l.pixelX * r } else { if (!(Math.abs(l.pixelY) > Math.abs(l.pixelX))) return !0; n = l.pixelY } else n = Math.abs(l.pixelX) > Math.abs(l.pixelY) ? -l.pixelX * r : -l.pixelY; if (n === 0) return !0; if (s.invert && (n = -n), a.params.freeMode) { const e = { time: _.now(), delta: Math.abs(n), direction: Math.sign(n) }; const { lastEventBeforeSnap: i } = a.mousewheel; const r = i && e.time < i.time + 500 && e.delta <= i.delta && e.direction === i.direction; if (!r) { a.mousewheel.lastEventBeforeSnap = void 0, a.params.loop && a.loopFix(); let i = a.getTranslate() + n * s.sensitivity; const o = a.isBeginning; const l = a.isEnd; if (i >= a.minTranslate() && (i = a.minTranslate()), i <= a.maxTranslate() && (i = a.maxTranslate()), a.setTransition(0), a.setTranslate(i), a.updateProgress(), a.updateActiveIndex(), a.updateSlidesClasses(), (!o && a.isBeginning || !l && a.isEnd) && a.updateSlidesClasses(), a.params.freeModeSticky) { clearTimeout(a.mousewheel.timeout), a.mousewheel.timeout = void 0; const t = a.mousewheel.recentWheelEvents; t.length >= 15 && t.shift(); const s = t.length ? t[t.length - 1] : void 0; const i = t[0]; if (t.push(e), s && (e.delta > s.delta || e.direction !== s.direction))t.splice(0); else if (t.length >= 15 && e.time - i.time < 500 && i.delta - e.delta >= 1 && e.delta <= 6) { const s = n > 0 ? 0.8 : 0.2; a.mousewheel.lastEventBeforeSnap = e, t.splice(0), a.mousewheel.timeout = _.nextTick(() => { a.slideToClosest(a.params.speed, !0, void 0, s) }, 0) }a.mousewheel.timeout || (a.mousewheel.timeout = _.nextTick(() => { const s = 0.5; a.mousewheel.lastEventBeforeSnap = e, t.splice(0), a.slideToClosest(a.params.speed, !0, void 0, s) }, 500)) } if (r || a.emit('scroll', t), a.params.autoplay && a.params.autoplayDisableOnInteraction && a.autoplay.stop(), i === a.minTranslate() || i === a.maxTranslate()) return !0 } } else { const t = { time: _.now(), delta: Math.abs(n), direction: Math.sign(n), raw: e }; const s = a.mousewheel.recentWheelEvents; s.length >= 2 && s.shift(); const i = s.length ? s[s.length - 1] : void 0; if (s.push(t), i ? (t.direction !== i.direction || t.delta > i.delta) && a.mousewheel.animateSlider(t) : a.mousewheel.animateSlider(t), a.mousewheel.releaseScroll(t)) return !0 } return t.preventDefault ? t.preventDefault() : t.returnValue = !1, !1 }, animateSlider (e) { const t = this; return e.delta >= 6 && _.now() - t.mousewheel.lastScrollTime < 60 || (e.direction < 0 ? t.isEnd && !t.params.loop || t.animating || (t.slideNext(), t.emit('scroll', e.raw)) : t.isBeginning && !t.params.loop || t.animating || (t.slidePrev(), t.emit('scroll', e.raw)), t.mousewheel.lastScrollTime = (new n.Date()).getTime(), !1) }, releaseScroll (e) { const t = this; const a = t.params.mousewheel; if (e.direction < 0) { if (t.isEnd && !t.params.loop && a.releaseOnEdges) return !0 } else if (t.isBeginning && !t.params.loop && a.releaseOnEdges) return !0; return !1 }, enable () { const e = this; const t = Tt.event(); if (e.params.cssMode) return e.wrapperEl.removeEventListener(t, e.mousewheel.handle), !0; if (!t) return !1; if (e.mousewheel.enabled) return !1; let a = e.$el; return e.params.mousewheel.eventsTarged !== 'container' && (a = o(e.params.mousewheel.eventsTarged)), a.on('mouseenter', e.mousewheel.handleMouseEnter), a.on('mouseleave', e.mousewheel.handleMouseLeave), a.on(t, e.mousewheel.handle), e.mousewheel.enabled = !0, !0 }, disable () { const e = this; const t = Tt.event(); if (e.params.cssMode) return e.wrapperEl.addEventListener(t, e.mousewheel.handle), !0; if (!t) return !1; if (!e.mousewheel.enabled) return !1; let a = e.$el; return e.params.mousewheel.eventsTarged !== 'container' && (a = o(e.params.mousewheel.eventsTarged)), a.off(t, e.mousewheel.handle), e.mousewheel.enabled = !1, !0 } }; const St = { name: 'mousewheel', params: { mousewheel: { enabled: !1, releaseOnEdges: !1, invert: !1, forceToAxis: !1, sensitivity: 1, eventsTarged: 'container' } }, create () { const e = this; _.extend(e, { mousewheel: { enabled: !1, enable: Tt.enable.bind(e), disable: Tt.disable.bind(e), handle: Tt.handle.bind(e), handleMouseEnter: Tt.handleMouseEnter.bind(e), handleMouseLeave: Tt.handleMouseLeave.bind(e), animateSlider: Tt.animateSlider.bind(e), releaseScroll: Tt.releaseScroll.bind(e), lastScrollTime: _.now(), lastEventBeforeSnap: void 0, recentWheelEvents: [] } }) }, on: { init () { const e = this; !e.params.mousewheel.enabled && e.params.cssMode && e.mousewheel.disable(), e.params.mousewheel.enabled && e.mousewheel.enable() }, destroy () { const e = this; e.params.cssMode && e.mousewheel.enable(), e.mousewheel.enabled && e.mousewheel.disable() } } }; const Ct = { update () { const e = this; const t = e.params.navigation; if (e.params.loop) return; const { $nextEl: a, $prevEl: s } = e.navigation; s && s.length > 0 && (e.isBeginning ? s.addClass(t.disabledClass) : s.removeClass(t.disabledClass), s[e.params.watchOverflow && e.isLocked ? 'addClass' : 'removeClass'](t.lockClass)), a && a.length > 0 && (e.isEnd ? a.addClass(t.disabledClass) : a.removeClass(t.disabledClass), a[e.params.watchOverflow && e.isLocked ? 'addClass' : 'removeClass'](t.lockClass)) }, onPrevClick (e) { const t = this; e.preventDefault(), t.isBeginning && !t.params.loop || t.slidePrev() }, onNextClick (e) { const t = this; e.preventDefault(), t.isEnd && !t.params.loop || t.slideNext() }, init () { const e = this; const t = e.params.navigation; if (!t.nextEl && !t.prevEl) return; let a, s; t.nextEl && (a = o(t.nextEl), e.params.uniqueNavElements && typeof t.nextEl === 'string' && a.length > 1 && e.$el.find(t.nextEl).length === 1 && (a = e.$el.find(t.nextEl))), t.prevEl && (s = o(t.prevEl), e.params.uniqueNavElements && typeof t.prevEl === 'string' && s.length > 1 && e.$el.find(t.prevEl).length === 1 && (s = e.$el.find(t.prevEl))), a && a.length > 0 && a.on('click', e.navigation.onNextClick), s && s.length > 0 && s.on('click', e.navigation.onPrevClick), _.extend(e.navigation, { $nextEl: a, nextEl: a && a[0], $prevEl: s, prevEl: s && s[0] }) }, destroy () { const e = this; const { $nextEl: t, $prevEl: a } = e.navigation; t && t.length && (t.off('click', e.navigation.onNextClick), t.removeClass(e.params.navigation.disabledClass)), a && a.length && (a.off('click', e.navigation.onPrevClick), a.removeClass(e.params.navigation.disabledClass)) } }; const Mt = { name: 'navigation', params: { navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: 'swiper-button-disabled', hiddenClass: 'swiper-button-hidden', lockClass: 'swiper-button-lock' } }, create () { const e = this; _.extend(e, { navigation: { init: Ct.init.bind(e), update: Ct.update.bind(e), destroy: Ct.destroy.bind(e), onNextClick: Ct.onNextClick.bind(e), onPrevClick: Ct.onPrevClick.bind(e) } }) }, on: { init () { const e = this; e.navigation.init(), e.navigation.update() }, toEdge () { const e = this; e.navigation.update() }, fromEdge () { const e = this; e.navigation.update() }, destroy () { const e = this; e.navigation.destroy() }, click (e) { const t = this; const { $nextEl: a, $prevEl: s } = t.navigation; if (t.params.navigation.hideOnClick && !o(e.target).is(s) && !o(e.target).is(a)) { let e; a ? e = a.hasClass(t.params.navigation.hiddenClass) : s && (e = s.hasClass(t.params.navigation.hiddenClass)), !0 === e ? t.emit('navigationShow', t) : t.emit('navigationHide', t), a && a.toggleClass(t.params.navigation.hiddenClass), s && s.toggleClass(t.params.navigation.hiddenClass) } } } }; const $t = { update () { const e = this; const t = e.rtl; const a = e.params.pagination; if (!a.el || !e.pagination.el || !e.pagination.$el || e.pagination.$el.length === 0) return; const s = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length; const i = e.pagination.$el; let n; const r = e.params.loop ? Math.ceil((s - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length; if (e.params.loop ? (n = Math.ceil((e.activeIndex - e.loopedSlides) / e.params.slidesPerGroup), n > s - 1 - 2 * e.loopedSlides && (n -= s - 2 * e.loopedSlides), n > r - 1 && (n -= r), n < 0 && e.params.paginationType !== 'bullets' && (n = r + n)) : n = typeof e.snapIndex !== 'undefined' ? e.snapIndex : e.activeIndex || 0, a.type === 'bullets' && e.pagination.bullets && e.pagination.bullets.length > 0) { const s = e.pagination.bullets; let r, l, d; if (a.dynamicBullets && (e.pagination.bulletSize = s.eq(0)[e.isHorizontal() ? 'outerWidth' : 'outerHeight'](!0), i.css(e.isHorizontal() ? 'width' : 'height', `${e.pagination.bulletSize * (a.dynamicMainBullets + 4)}px`), a.dynamicMainBullets > 1 && void 0 !== e.previousIndex && (e.pagination.dynamicBulletIndex += n - e.previousIndex, e.pagination.dynamicBulletIndex > a.dynamicMainBullets - 1 ? e.pagination.dynamicBulletIndex = a.dynamicMainBullets - 1 : e.pagination.dynamicBulletIndex < 0 && (e.pagination.dynamicBulletIndex = 0)), r = n - e.pagination.dynamicBulletIndex, l = r + (Math.min(s.length, a.dynamicMainBullets) - 1), d = (l + r) / 2), s.removeClass(`${a.bulletActiveClass} ${a.bulletActiveClass}-next ${a.bulletActiveClass}-next-next ${a.bulletActiveClass}-prev ${a.bulletActiveClass}-prev-prev ${a.bulletActiveClass}-main`), i.length > 1)s.each((e, t) => { const s = o(t); const i = s.index(); i === n && s.addClass(a.bulletActiveClass), a.dynamicBullets && (i >= r && i <= l && s.addClass(`${a.bulletActiveClass}-main`), i === r && s.prev().addClass(`${a.bulletActiveClass}-prev`).prev().addClass(`${a.bulletActiveClass}-prev-prev`), i === l && s.next().addClass(`${a.bulletActiveClass}-next`).next().addClass(`${a.bulletActiveClass}-next-next`)) }); else { const t = s.eq(n); const i = t.index(); if (t.addClass(a.bulletActiveClass), a.dynamicBullets) { const t = s.eq(r); const n = s.eq(l); for (let e = r; e <= l; e += 1)s.eq(e).addClass(`${a.bulletActiveClass}-main`); if (e.params.loop) if (i >= s.length - a.dynamicMainBullets) { for (let e = a.dynamicMainBullets; e >= 0; e -= 1)s.eq(s.length - e).addClass(`${a.bulletActiveClass}-main`); s.eq(s.length - a.dynamicMainBullets - 1).addClass(`${a.bulletActiveClass}-prev`) } else t.prev().addClass(`${a.bulletActiveClass}-prev`).prev().addClass(`${a.bulletActiveClass}-prev-prev`), n.next().addClass(`${a.bulletActiveClass}-next`).next().addClass(`${a.bulletActiveClass}-next-next`); else t.prev().addClass(`${a.bulletActiveClass}-prev`).prev().addClass(`${a.bulletActiveClass}-prev-prev`), n.next().addClass(`${a.bulletActiveClass}-next`).next().addClass(`${a.bulletActiveClass}-next-next`) } } if (a.dynamicBullets) { const i = Math.min(s.length, a.dynamicMainBullets + 4); const n = (e.pagination.bulletSize * i - e.pagination.bulletSize) / 2 - d * e.pagination.bulletSize; const r = t ? 'right' : 'left'; s.css(e.isHorizontal() ? r : 'top', `${n}px`) } } if (a.type === 'fraction' && (i.find(`.${a.currentClass}`).text(a.formatFractionCurrent(n + 1)), i.find(`.${a.totalClass}`).text(a.formatFractionTotal(r))), a.type === 'progressbar') { let t; t = a.progressbarOpposite ? e.isHorizontal() ? 'vertical' : 'horizontal' : e.isHorizontal() ? 'horizontal' : 'vertical'; const s = (n + 1) / r; let o = 1; let l = 1; t === 'horizontal' ? o = s : l = s, i.find(`.${a.progressbarFillClass}`).transform(`translate3d(0,0,0) scaleX(${o}) scaleY(${l})`).transition(e.params.speed) }a.type === 'custom' && a.renderCustom ? (i.html(a.renderCustom(e, n + 1, r)), e.emit('paginationRender', e, i[0])) : e.emit('paginationUpdate', e, i[0]), i[e.params.watchOverflow && e.isLocked ? 'addClass' : 'removeClass'](a.lockClass) }, render () { const e = this; const t = e.params.pagination; if (!t.el || !e.pagination.el || !e.pagination.$el || e.pagination.$el.length === 0) return; const a = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length; const s = e.pagination.$el; let i = ''; if (t.type === 'bullets') { const n = e.params.loop ? Math.ceil((a - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length; for (let a = 0; a < n; a += 1)t.renderBullet ? i += t.renderBullet.call(e, a, t.bulletClass) : i += `<${t.bulletElement} class="${t.bulletClass}"></${t.bulletElement}>`; s.html(i), e.pagination.bullets = s.find(`.${t.bulletClass}`) }t.type === 'fraction' && (i = t.renderFraction ? t.renderFraction.call(e, t.currentClass, t.totalClass) : `<span class="${t.currentClass}"></span>` + ' / ' + `<span class="${t.totalClass}"></span>`, s.html(i)), t.type === 'progressbar' && (i = t.renderProgressbar ? t.renderProgressbar.call(e, t.progressbarFillClass) : `<span class="${t.progressbarFillClass}"></span>`, s.html(i)), t.type !== 'custom' && e.emit('paginationRender', e.pagination.$el[0]) }, init () { const e = this; const t = e.params.pagination; if (!t.el) return; let a = o(t.el); a.length !== 0 && (e.params.uniqueNavElements && typeof t.el === 'string' && a.length > 1 && e.$el.find(t.el).length === 1 && (a = e.$el.find(t.el)), t.type === 'bullets' && t.clickable && a.addClass(t.clickableClass), a.addClass(t.modifierClass + t.type), t.type === 'bullets' && t.dynamicBullets && (a.addClass(`${t.modifierClass}${t.type}-dynamic`), e.pagination.dynamicBulletIndex = 0, t.dynamicMainBullets < 1 && (t.dynamicMainBullets = 1)), t.type === 'progressbar' && t.progressbarOpposite && a.addClass(t.progressbarOppositeClass), t.clickable && a.on('click', `.${t.bulletClass}`, function (t) { t.preventDefault(); let a = o(this).index() * e.params.slidesPerGroup; e.params.loop && (a += e.loopedSlides), e.slideTo(a) }), _.extend(e.pagination, { $el: a, el: a[0] })) }, destroy () { const e = this; const t = e.params.pagination; if (!t.el || !e.pagination.el || !e.pagination.$el || e.pagination.$el.length === 0) return; const a = e.pagination.$el; a.removeClass(t.hiddenClass), a.removeClass(t.modifierClass + t.type), e.pagination.bullets && e.pagination.bullets.removeClass(t.bulletActiveClass), t.clickable && a.off('click', `.${t.bulletClass}`) } }; const Pt = { name: 'pagination', params: { pagination: { el: null, bulletElement: 'span', clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: 'bullets', dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent: e => e, formatFractionTotal: e => e, bulletClass: 'swiper-pagination-bullet', bulletActiveClass: 'swiper-pagination-bullet-active', modifierClass: 'swiper-pagination-', currentClass: 'swiper-pagination-current', totalClass: 'swiper-pagination-total', hiddenClass: 'swiper-pagination-hidden', progressbarFillClass: 'swiper-pagination-progressbar-fill', progressbarOppositeClass: 'swiper-pagination-progressbar-opposite', clickableClass: 'swiper-pagination-clickable', lockClass: 'swiper-pagination-lock' } }, create () { const e = this; _.extend(e, { pagination: { init: $t.init.bind(e), render: $t.render.bind(e), update: $t.update.bind(e), destroy: $t.destroy.bind(e), dynamicBulletIndex: 0 } }) }, on: { init () { const e = this; e.pagination.init(), e.pagination.render(), e.pagination.update() }, activeIndexChange () { const e = this; e.params.loop ? e.pagination.update() : typeof e.snapIndex === 'undefined' && e.pagination.update() }, snapIndexChange () { const e = this; e.params.loop || e.pagination.update() }, slidesLengthChange () { const e = this; e.params.loop && (e.pagination.render(), e.pagination.update()) }, snapGridLengthChange () { const e = this; e.params.loop || (e.pagination.render(), e.pagination.update()) }, destroy () { const e = this; e.pagination.destroy() }, click (e) { const t = this; if (t.params.pagination.el && t.params.pagination.hideOnClick && t.pagination.$el.length > 0 && !o(e.target).hasClass(t.params.pagination.bulletClass)) { const e = t.pagination.$el.hasClass(t.params.pagination.hiddenClass); !0 === e ? t.emit('paginationShow', t) : t.emit('paginationHide', t), t.pagination.$el.toggleClass(t.params.pagination.hiddenClass) } } } }; const kt = { setTranslate () { const e = this; if (!e.params.scrollbar.el || !e.scrollbar.el) return; const { scrollbar: t, rtlTranslate: a, progress: s } = e; const { dragSize: i, trackSize: n, $dragEl: r, $el: o } = t; const l = e.params.scrollbar; let d = i; let c = (n - i) * s; a ? (c = -c, c > 0 ? (d = i - c, c = 0) : -c + i > n && (d = n + c)) : c < 0 ? (d = i + c, c = 0) : c + i > n && (d = n - c), e.isHorizontal() ? (r.transform(`translate3d(${c}px, 0, 0)`), r[0].style.width = `${d}px`) : (r.transform(`translate3d(0px, ${c}px, 0)`), r[0].style.height = `${d}px`), l.hide && (clearTimeout(e.scrollbar.timeout), o[0].style.opacity = 1, e.scrollbar.timeout = setTimeout(() => { o[0].style.opacity = 0, o.transition(400) }, 1e3)) }, setTransition (e) { const t = this; t.params.scrollbar.el && t.scrollbar.el && t.scrollbar.$dragEl.transition(e) }, updateSize () { const e = this; if (!e.params.scrollbar.el || !e.scrollbar.el) return; const { scrollbar: t } = e; const { $dragEl: a, $el: s } = t; a[0].style.width = '', a[0].style.height = ''; const i = e.isHorizontal() ? s[0].offsetWidth : s[0].offsetHeight; const n = e.size / e.virtualSize; const r = n * (i / e.size); let o; o = e.params.scrollbar.dragSize === 'auto' ? i * n : parseInt(e.params.scrollbar.dragSize, 10), e.isHorizontal() ? a[0].style.width = `${o}px` : a[0].style.height = `${o}px`, s[0].style.display = n >= 1 ? 'none' : '', e.params.scrollbar.hide && (s[0].style.opacity = 0), _.extend(t, { trackSize: i, divider: n, moveDivider: r, dragSize: o }), t.$el[e.params.watchOverflow && e.isLocked ? 'addClass' : 'removeClass'](e.params.scrollbar.lockClass) }, getPointerPosition (e) { const t = this; return t.isHorizontal() ? e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX : e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY }, setDragPosition (e) { const t = this; const { scrollbar: a, rtlTranslate: s } = t; const { $el: i, dragSize: n, trackSize: r, dragStartPos: o } = a; let l; l = (a.getPointerPosition(e) - i.offset()[t.isHorizontal() ? 'left' : 'top'] - (o !== null ? o : n / 2)) / (r - n), l = Math.max(Math.min(l, 1), 0), s && (l = 1 - l); const d = t.minTranslate() + (t.maxTranslate() - t.minTranslate()) * l; t.updateProgress(d), t.setTranslate(d), t.updateActiveIndex(), t.updateSlidesClasses() }, onDragStart (e) { const t = this; const a = t.params.scrollbar; const { scrollbar: s, $wrapperEl: i } = t; const { $el: n, $dragEl: r } = s; t.scrollbar.isTouched = !0, t.scrollbar.dragStartPos = e.target === r[0] || e.target === r ? s.getPointerPosition(e) - e.target.getBoundingClientRect()[t.isHorizontal() ? 'left' : 'top'] : null, e.preventDefault(), e.stopPropagation(), i.transition(100), r.transition(100), s.setDragPosition(e), clearTimeout(t.scrollbar.dragTimeout), n.transition(0), a.hide && n.css('opacity', 1), t.params.cssMode && t.$wrapperEl.css('scroll-snap-type', 'none'), t.emit('scrollbarDragStart', e) }, onDragMove (e) { const t = this; const { scrollbar: a, $wrapperEl: s } = t; const { $el: i, $dragEl: n } = a; t.scrollbar.isTouched && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, a.setDragPosition(e), s.transition(0), i.transition(0), n.transition(0), t.emit('scrollbarDragMove', e)) }, onDragEnd (e) { const t = this; const a = t.params.scrollbar; const { scrollbar: s, $wrapperEl: i } = t; const { $el: n } = s; t.scrollbar.isTouched && (t.scrollbar.isTouched = !1, t.params.cssMode && (t.$wrapperEl.css('scroll-snap-type', ''), i.transition('')), a.hide && (clearTimeout(t.scrollbar.dragTimeout), t.scrollbar.dragTimeout = _.nextTick(() => { n.css('opacity', 0), n.transition(400) }, 1e3)), t.emit('scrollbarDragEnd', e), a.snapOnRelease && t.slideToClosest()) }, enableDraggable () { const e = this; if (!e.params.scrollbar.el) return; const { scrollbar: t, touchEventsTouch: a, touchEventsDesktop: s, params: n } = e; const r = t.$el; const o = r[0]; const l = !(!U.passiveListener || !n.passiveListeners) && { passive: !1, capture: !1 }; const d = !(!U.passiveListener || !n.passiveListeners) && { passive: !0, capture: !1 }; U.touch ? (o.addEventListener(a.start, e.scrollbar.onDragStart, l), o.addEventListener(a.move, e.scrollbar.onDragMove, l), o.addEventListener(a.end, e.scrollbar.onDragEnd, d)) : (o.addEventListener(s.start, e.scrollbar.onDragStart, l), i.addEventListener(s.move, e.scrollbar.onDragMove, l), i.addEventListener(s.end, e.scrollbar.onDragEnd, d)) }, disableDraggable () { const e = this; if (!e.params.scrollbar.el) return; const { scrollbar: t, touchEventsTouch: a, touchEventsDesktop: s, params: n } = e; const r = t.$el; const o = r[0]; const l = !(!U.passiveListener || !n.passiveListeners) && { passive: !1, capture: !1 }; const d = !(!U.passiveListener || !n.passiveListeners) && { passive: !0, capture: !1 }; U.touch ? (o.removeEventListener(a.start, e.scrollbar.onDragStart, l), o.removeEventListener(a.move, e.scrollbar.onDragMove, l), o.removeEventListener(a.end, e.scrollbar.onDragEnd, d)) : (o.removeEventListener(s.start, e.scrollbar.onDragStart, l), i.removeEventListener(s.move, e.scrollbar.onDragMove, l), i.removeEventListener(s.end, e.scrollbar.onDragEnd, d)) }, init () { const e = this; if (!e.params.scrollbar.el) return; const { scrollbar: t, $el: a } = e; const s = e.params.scrollbar; let i = o(s.el); e.params.uniqueNavElements && typeof s.el === 'string' && i.length > 1 && a.find(s.el).length === 1 && (i = a.find(s.el)); let n = i.find(`.${e.params.scrollbar.dragClass}`); n.length === 0 && (n = o(`<div class="${e.params.scrollbar.dragClass}"></div>`), i.append(n)), _.extend(t, { $el: i, el: i[0], $dragEl: n, dragEl: n[0] }), s.draggable && t.enableDraggable() }, destroy () { const e = this; e.scrollbar.disableDraggable() } }; const zt = { name: 'scrollbar', params: { scrollbar: { el: null, dragSize: 'auto', hide: !1, draggable: !1, snapOnRelease: !0, lockClass: 'swiper-scrollbar-lock', dragClass: 'swiper-scrollbar-drag' } }, create () { const e = this; _.extend(e, { scrollbar: { init: kt.init.bind(e), destroy: kt.destroy.bind(e), updateSize: kt.updateSize.bind(e), setTranslate: kt.setTranslate.bind(e), setTransition: kt.setTransition.bind(e), enableDraggable: kt.enableDraggable.bind(e), disableDraggable: kt.disableDraggable.bind(e), setDragPosition: kt.setDragPosition.bind(e), getPointerPosition: kt.getPointerPosition.bind(e), onDragStart: kt.onDragStart.bind(e), onDragMove: kt.onDragMove.bind(e), onDragEnd: kt.onDragEnd.bind(e), isTouched: !1, timeout: null, dragTimeout: null } }) }, on: { init () { const e = this; e.scrollbar.init(), e.scrollbar.updateSize(), e.scrollbar.setTranslate() }, update () { const e = this; e.scrollbar.updateSize() }, resize () { const e = this; e.scrollbar.updateSize() }, observerUpdate () { const e = this; e.scrollbar.updateSize() }, setTranslate () { const e = this; e.scrollbar.setTranslate() }, setTransition (e) { const t = this; t.scrollbar.setTransition(e) }, destroy () { const e = this; e.scrollbar.destroy() } } }; const Lt = { setTransform (e, t) { const a = this; const { rtl: s } = a; const i = o(e); const n = s ? -1 : 1; const r = i.attr('data-swiper-parallax') || '0'; let l = i.attr('data-swiper-parallax-x'); let d = i.attr('data-swiper-parallax-y'); const c = i.attr('data-swiper-parallax-scale'); const p = i.attr('data-swiper-parallax-opacity'); if (l || d ? (l = l || '0', d = d || '0') : a.isHorizontal() ? (l = r, d = '0') : (d = r, l = '0'), l = l.indexOf('%') >= 0 ? `${parseInt(l, 10) * t * n}%` : `${l * t * n}px`, d = d.indexOf('%') >= 0 ? `${parseInt(d, 10) * t}%` : `${d * t}px`, typeof p !== 'undefined' && p !== null) { const e = p - (p - 1) * (1 - Math.abs(t)); i[0].style.opacity = e } if (typeof c === 'undefined' || c === null)i.transform(`translate3d(${l}, ${d}, 0px)`); else { const e = c - (c - 1) * (1 - Math.abs(t)); i.transform(`translate3d(${l}, ${d}, 0px) scale(${e})`) } }, setTranslate () { const e = this; const { $el: t, slides: a, progress: s, snapGrid: i } = e; t.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each((t, a) => { e.parallax.setTransform(a, s) }), a.each((t, a) => { let n = a.progress; e.params.slidesPerGroup > 1 && e.params.slidesPerView !== 'auto' && (n += Math.ceil(t / 2) - s * (i.length - 1)), n = Math.min(Math.max(n, -1), 1), o(a).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each((t, a) => { e.parallax.setTransform(a, n) }) }) }, setTransition (e = this.params.speed) { const t = this; const { $el: a } = t; a.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each((t, a) => { const s = o(a); let i = parseInt(s.attr('data-swiper-parallax-duration'), 10) || e; e === 0 && (i = 0), s.transition(i) }) } }; const It = { name: 'parallax', params: { parallax: { enabled: !1 } }, create () { const e = this; _.extend(e, { parallax: { setTransform: Lt.setTransform.bind(e), setTranslate: Lt.setTranslate.bind(e), setTransition: Lt.setTransition.bind(e) } }) }, on: { beforeInit () { const e = this; e.params.parallax.enabled && (e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0) }, init () { const e = this; e.params.parallax.enabled && e.parallax.setTranslate() }, setTranslate () { const e = this; e.params.parallax.enabled && e.parallax.setTranslate() }, setTransition (e) { const t = this; t.params.parallax.enabled && t.parallax.setTransition(e) } } }; const Ot = { getDistanceBetweenTouches (e) { if (e.targetTouches.length < 2) return 1; const t = e.targetTouches[0].pageX; const a = e.targetTouches[0].pageY; const s = e.targetTouches[1].pageX; const i = e.targetTouches[1].pageY; const n = Math.sqrt((s - t) ** 2 + (i - a) ** 2); return n }, onGestureStart (e) { const t = this; const a = t.params.zoom; const s = t.zoom; const { gesture: i } = s; if (s.fakeGestureTouched = !1, s.fakeGestureMoved = !1, !U.gestures) { if (e.type !== 'touchstart' || e.type === 'touchstart' && e.targetTouches.length < 2) return; s.fakeGestureTouched = !0, i.scaleStart = Ot.getDistanceBetweenTouches(e) }i.$slideEl && i.$slideEl.length || (i.$slideEl = o(e.target).closest('.swiper-slide'), i.$slideEl.length === 0 && (i.$slideEl = t.slides.eq(t.activeIndex)), i.$imageEl = i.$slideEl.find('img, svg, canvas'), i.$imageWrapEl = i.$imageEl.parent(`.${a.containerClass}`), i.maxRatio = i.$imageWrapEl.attr('data-swiper-zoom') || a.maxRatio, i.$imageWrapEl.length !== 0) ? (i.$imageEl.transition(0), t.zoom.isScaling = !0) : i.$imageEl = void 0 }, onGestureChange (e) { const t = this; const a = t.params.zoom; const s = t.zoom; const { gesture: i } = s; if (!U.gestures) { if (e.type !== 'touchmove' || e.type === 'touchmove' && e.targetTouches.length < 2) return; s.fakeGestureMoved = !0, i.scaleMove = Ot.getDistanceBetweenTouches(e) }i.$imageEl && i.$imageEl.length !== 0 && (U.gestures ? s.scale = e.scale * s.currentScale : s.scale = i.scaleMove / i.scaleStart * s.currentScale, s.scale > i.maxRatio && (s.scale = i.maxRatio - 1 + (s.scale - i.maxRatio + 1) ** 0.5), s.scale < a.minRatio && (s.scale = a.minRatio + 1 - (a.minRatio - s.scale + 1) ** 0.5), i.$imageEl.transform(`translate3d(0,0,0) scale(${s.scale})`)) }, onGestureEnd (e) { const t = this; const a = t.params.zoom; const s = t.zoom; const { gesture: i } = s; if (!U.gestures) { if (!s.fakeGestureTouched || !s.fakeGestureMoved) return; if (e.type !== 'touchend' || e.type === 'touchend' && e.changedTouches.length < 2 && !Ne.android) return; s.fakeGestureTouched = !1, s.fakeGestureMoved = !1 }i.$imageEl && i.$imageEl.length !== 0 && (s.scale = Math.max(Math.min(s.scale, i.maxRatio), a.minRatio), i.$imageEl.transition(t.params.speed).transform(`translate3d(0,0,0) scale(${s.scale})`), s.currentScale = s.scale, s.isScaling = !1, s.scale === 1 && (i.$slideEl = void 0)) }, onTouchStart (e) { const t = this; const a = t.zoom; const { gesture: s, image: i } = a; s.$imageEl && s.$imageEl.length !== 0 && (i.isTouched || (Ne.android && e.preventDefault(), i.isTouched = !0, i.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX, i.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY)) }, onTouchMove (e) { const t = this; const a = t.zoom; const { gesture: s, image: i, velocity: n } = a; if (!s.$imageEl || s.$imageEl.length === 0) return; if (t.allowClick = !1, !i.isTouched || !s.$slideEl) return; i.isMoved || (i.width = s.$imageEl[0].offsetWidth, i.height = s.$imageEl[0].offsetHeight, i.startX = _.getTranslate(s.$imageWrapEl[0], 'x') || 0, i.startY = _.getTranslate(s.$imageWrapEl[0], 'y') || 0, s.slideWidth = s.$slideEl[0].offsetWidth, s.slideHeight = s.$slideEl[0].offsetHeight, s.$imageWrapEl.transition(0), t.rtl && (i.startX = -i.startX, i.startY = -i.startY)); const r = i.width * a.scale; const o = i.height * a.scale; if (!(r < s.slideWidth && o < s.slideHeight)) { if (i.minX = Math.min(s.slideWidth / 2 - r / 2, 0), i.maxX = -i.minX, i.minY = Math.min(s.slideHeight / 2 - o / 2, 0), i.maxY = -i.minY, i.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX, i.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY, !i.isMoved && !a.isScaling) { if (t.isHorizontal() && (Math.floor(i.minX) === Math.floor(i.startX) && i.touchesCurrent.x < i.touchesStart.x || Math.floor(i.maxX) === Math.floor(i.startX) && i.touchesCurrent.x > i.touchesStart.x)) return void (i.isTouched = !1); if (!t.isHorizontal() && (Math.floor(i.minY) === Math.floor(i.startY) && i.touchesCurrent.y < i.touchesStart.y || Math.floor(i.maxY) === Math.floor(i.startY) && i.touchesCurrent.y > i.touchesStart.y)) return void (i.isTouched = !1) }e.preventDefault(), e.stopPropagation(), i.isMoved = !0, i.currentX = i.touchesCurrent.x - i.touchesStart.x + i.startX, i.currentY = i.touchesCurrent.y - i.touchesStart.y + i.startY, i.currentX < i.minX && (i.currentX = i.minX + 1 - (i.minX - i.currentX + 1) ** 0.8), i.currentX > i.maxX && (i.currentX = i.maxX - 1 + (i.currentX - i.maxX + 1) ** 0.8), i.currentY < i.minY && (i.currentY = i.minY + 1 - (i.minY - i.currentY + 1) ** 0.8), i.currentY > i.maxY && (i.currentY = i.maxY - 1 + (i.currentY - i.maxY + 1) ** 0.8), n.prevPositionX || (n.prevPositionX = i.touchesCurrent.x), n.prevPositionY || (n.prevPositionY = i.touchesCurrent.y), n.prevTime || (n.prevTime = Date.now()), n.x = (i.touchesCurrent.x - n.prevPositionX) / (Date.now() - n.prevTime) / 2, n.y = (i.touchesCurrent.y - n.prevPositionY) / (Date.now() - n.prevTime) / 2, Math.abs(i.touchesCurrent.x - n.prevPositionX) < 2 && (n.x = 0), Math.abs(i.touchesCurrent.y - n.prevPositionY) < 2 && (n.y = 0), n.prevPositionX = i.touchesCurrent.x, n.prevPositionY = i.touchesCurrent.y, n.prevTime = Date.now(), s.$imageWrapEl.transform(`translate3d(${i.currentX}px, ${i.currentY}px,0)`) } }, onTouchEnd () { const e = this; const t = e.zoom; const { gesture: a, image: s, velocity: i } = t; if (!a.$imageEl || a.$imageEl.length === 0) return; if (!s.isTouched || !s.isMoved) return s.isTouched = !1, void (s.isMoved = !1); s.isTouched = !1, s.isMoved = !1; let n = 300; let r = 300; const o = i.x * n; const l = s.currentX + o; const d = i.y * r; const c = s.currentY + d; i.x !== 0 && (n = Math.abs((l - s.currentX) / i.x)), i.y !== 0 && (r = Math.abs((c - s.currentY) / i.y)); const p = Math.max(n, r); s.currentX = l, s.currentY = c; const u = s.width * t.scale; const h = s.height * t.scale; s.minX = Math.min(a.slideWidth / 2 - u / 2, 0), s.maxX = -s.minX, s.minY = Math.min(a.slideHeight / 2 - h / 2, 0), s.maxY = -s.minY, s.currentX = Math.max(Math.min(s.currentX, s.maxX), s.minX), s.currentY = Math.max(Math.min(s.currentY, s.maxY), s.minY), a.$imageWrapEl.transition(p).transform(`translate3d(${s.currentX}px, ${s.currentY}px,0)`) }, onTransitionEnd () { const e = this; const t = e.zoom; const { gesture: a } = t; a.$slideEl && e.previousIndex !== e.activeIndex && (a.$imageEl.transform('translate3d(0,0,0) scale(1)'), a.$imageWrapEl.transform('translate3d(0,0,0)'), t.scale = 1, t.currentScale = 1, a.$slideEl = void 0, a.$imageEl = void 0, a.$imageWrapEl = void 0) }, toggle (e) { const t = this; const a = t.zoom; a.scale && a.scale !== 1 ? a.out() : a.in(e) }, in (e) { const t = this; const a = t.zoom; const s = t.params.zoom; const { gesture: i, image: n } = a; if (i.$slideEl || (i.$slideEl = t.clickedSlide ? o(t.clickedSlide) : t.slides.eq(t.activeIndex), i.$imageEl = i.$slideEl.find('img, svg, canvas'), i.$imageWrapEl = i.$imageEl.parent(`.${s.containerClass}`)), !i.$imageEl || i.$imageEl.length === 0) return; let r, l, d, c, p, u, h, f, m, v, g, b, w, y, x, E, T, S; i.$slideEl.addClass(`${s.zoomedSlideClass}`), typeof n.touchesStart.x === 'undefined' && e ? (r = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX, l = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY) : (r = n.touchesStart.x, l = n.touchesStart.y), a.scale = i.$imageWrapEl.attr('data-swiper-zoom') || s.maxRatio, a.currentScale = i.$imageWrapEl.attr('data-swiper-zoom') || s.maxRatio, e ? (T = i.$slideEl[0].offsetWidth, S = i.$slideEl[0].offsetHeight, d = i.$slideEl.offset().left, c = i.$slideEl.offset().top, p = d + T / 2 - r, u = c + S / 2 - l, m = i.$imageEl[0].offsetWidth, v = i.$imageEl[0].offsetHeight, g = m * a.scale, b = v * a.scale, w = Math.min(T / 2 - g / 2, 0), y = Math.min(S / 2 - b / 2, 0), x = -w, E = -y, h = p * a.scale, f = u * a.scale, h < w && (h = w), h > x && (h = x), f < y && (f = y), f > E && (f = E)) : (h = 0, f = 0), i.$imageWrapEl.transition(300).transform(`translate3d(${h}px, ${f}px,0)`), i.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${a.scale})`) }, out () { const e = this; const t = e.zoom; const a = e.params.zoom; const { gesture: s } = t; s.$slideEl || (s.$slideEl = e.clickedSlide ? o(e.clickedSlide) : e.slides.eq(e.activeIndex), s.$imageEl = s.$slideEl.find('img, svg, canvas'), s.$imageWrapEl = s.$imageEl.parent(`.${a.containerClass}`)), s.$imageEl && s.$imageEl.length !== 0 && (t.scale = 1, t.currentScale = 1, s.$imageWrapEl.transition(300).transform('translate3d(0,0,0)'), s.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)'), s.$slideEl.removeClass(`${a.zoomedSlideClass}`), s.$slideEl = void 0) }, enable () { const e = this; const t = e.zoom; if (t.enabled) return; t.enabled = !0; const a = !(e.touchEvents.start !== 'touchstart' || !U.passiveListener || !e.params.passiveListeners) && { passive: !0, capture: !1 }; const s = !U.passiveListener || { passive: !1, capture: !0 }; U.gestures ? (e.$wrapperEl.on('gesturestart', '.swiper-slide', t.onGestureStart, a), e.$wrapperEl.on('gesturechange', '.swiper-slide', t.onGestureChange, a), e.$wrapperEl.on('gestureend', '.swiper-slide', t.onGestureEnd, a)) : e.touchEvents.start === 'touchstart' && (e.$wrapperEl.on(e.touchEvents.start, '.swiper-slide', t.onGestureStart, a), e.$wrapperEl.on(e.touchEvents.move, '.swiper-slide', t.onGestureChange, s), e.$wrapperEl.on(e.touchEvents.end, '.swiper-slide', t.onGestureEnd, a), e.touchEvents.cancel && e.$wrapperEl.on(e.touchEvents.cancel, '.swiper-slide', t.onGestureEnd, a)), e.$wrapperEl.on(e.touchEvents.move, `.${e.params.zoom.containerClass}`, t.onTouchMove, s) }, disable () { const e = this; const t = e.zoom; if (!t.enabled) return; e.zoom.enabled = !1; const a = !(e.touchEvents.start !== 'touchstart' || !U.passiveListener || !e.params.passiveListeners) && { passive: !0, capture: !1 }; const s = !U.passiveListener || { passive: !1, capture: !0 }; U.gestures ? (e.$wrapperEl.off('gesturestart', '.swiper-slide', t.onGestureStart, a), e.$wrapperEl.off('gesturechange', '.swiper-slide', t.onGestureChange, a), e.$wrapperEl.off('gestureend', '.swiper-slide', t.onGestureEnd, a)) : e.touchEvents.start === 'touchstart' && (e.$wrapperEl.off(e.touchEvents.start, '.swiper-slide', t.onGestureStart, a), e.$wrapperEl.off(e.touchEvents.move, '.swiper-slide', t.onGestureChange, s), e.$wrapperEl.off(e.touchEvents.end, '.swiper-slide', t.onGestureEnd, a), e.touchEvents.cancel && e.$wrapperEl.off(e.touchEvents.cancel, '.swiper-slide', t.onGestureEnd, a)), e.$wrapperEl.off(e.touchEvents.move, `.${e.params.zoom.containerClass}`, t.onTouchMove, s) } }; const Dt = { name: 'zoom', params: { zoom: { enabled: !1, maxRatio: 3, minRatio: 1, toggle: !0, containerClass: 'swiper-zoom-container', zoomedSlideClass: 'swiper-slide-zoomed' } }, create () { const e = this; const t = { enabled: !1, scale: 1, currentScale: 1, isScaling: !1, gesture: { $slideEl: void 0, slideWidth: void 0, slideHeight: void 0, $imageEl: void 0, $imageWrapEl: void 0, maxRatio: 3 }, image: { isTouched: void 0, isMoved: void 0, currentX: void 0, currentY: void 0, minX: void 0, minY: void 0, maxX: void 0, maxY: void 0, width: void 0, height: void 0, startX: void 0, startY: void 0, touchesStart: {}, touchesCurrent: {} }, velocity: { x: void 0, y: void 0, prevPositionX: void 0, prevPositionY: void 0, prevTime: void 0 } }; 'onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out'.split(' ').forEach(a => { t[a] = Ot[a].bind(e) }), _.extend(e, { zoom: t }); let a = 1; Object.defineProperty(e.zoom, 'scale', { get () { return a }, set (t) { if (a !== t) { const a = e.zoom.gesture.$imageEl ? e.zoom.gesture.$imageEl[0] : void 0; const s = e.zoom.gesture.$slideEl ? e.zoom.gesture.$slideEl[0] : void 0; e.emit('zoomChange', t, a, s) }a = t } }) }, on: { init () { const e = this; e.params.zoom.enabled && e.zoom.enable() }, destroy () { const e = this; e.zoom.disable() }, touchStart (e) { const t = this; t.zoom.enabled && t.zoom.onTouchStart(e) }, touchEnd (e) { const t = this; t.zoom.enabled && t.zoom.onTouchEnd(e) }, doubleTap (e) { const t = this; t.params.zoom.enabled && t.zoom.enabled && t.params.zoom.toggle && t.zoom.toggle(e) }, transitionEnd () { const e = this; e.zoom.enabled && e.params.zoom.enabled && e.zoom.onTransitionEnd() }, slideChange () { const e = this; e.zoom.enabled && e.params.zoom.enabled && e.params.cssMode && e.zoom.onTransitionEnd() } } }; const At = { loadInSlide (e, t = !0) { const a = this; const s = a.params.lazy; if (typeof e === 'undefined') return; if (a.slides.length === 0) return; const i = a.virtual && a.params.virtual.enabled; const n = i ? a.$wrapperEl.children(`.${a.params.slideClass}[data-swiper-slide-index="${e}"]`) : a.slides.eq(e); let r = n.find(`.${s.elementClass}:not(.${s.loadedClass}):not(.${s.loadingClass})`); !n.hasClass(s.elementClass) || n.hasClass(s.loadedClass) || n.hasClass(s.loadingClass) || (r = r.add(n[0])), r.length !== 0 && r.each((e, i) => { const r = o(i); r.addClass(s.loadingClass); const l = r.attr('data-background'); const d = r.attr('data-src'); const c = r.attr('data-srcset'); const p = r.attr('data-sizes'); a.loadImage(r[0], d || l, c, p, !1, () => { if (typeof a !== 'undefined' && a !== null && a && (!a || a.params) && !a.destroyed) { if (l ? (r.css('background-image', `url("${l}")`), r.removeAttr('data-background')) : (c && (r.attr('srcset', c), r.removeAttr('data-srcset')), p && (r.attr('sizes', p), r.removeAttr('data-sizes')), d && (r.attr('src', d), r.removeAttr('data-src'))), r.addClass(s.loadedClass).removeClass(s.loadingClass), n.find(`.${s.preloaderClass}`).remove(), a.params.loop && t) { const e = n.attr('data-swiper-slide-index'); if (n.hasClass(a.params.slideDuplicateClass)) { const t = a.$wrapperEl.children(`[data-swiper-slide-index="${e}"]:not(.${a.params.slideDuplicateClass})`); a.lazy.loadInSlide(t.index(), !1) } else { const t = a.$wrapperEl.children(`.${a.params.slideDuplicateClass}[data-swiper-slide-index="${e}"]`); a.lazy.loadInSlide(t.index(), !1) } }a.emit('lazyImageReady', n[0], r[0]) } }), a.emit('lazyImageLoad', n[0], r[0]) }) }, load () { const e = this; const { $wrapperEl: t, params: a, slides: s, activeIndex: i } = e; const n = e.virtual && a.virtual.enabled; const r = a.lazy; let l = a.slidesPerView; function d (e) { if (n) { if (t.children(`.${a.slideClass}[data-swiper-slide-index="${e}"]`).length) return !0 } else if (s[e]) return !0; return !1 } function c (e) { return n ? o(e).attr('data-swiper-slide-index') : o(e).index() } if (l === 'auto' && (l = 0), e.lazy.initialImageLoaded || (e.lazy.initialImageLoaded = !0), e.params.watchSlidesVisibility)t.children(`.${a.slideVisibleClass}`).each((t, a) => { const s = n ? o(a).attr('data-swiper-slide-index') : o(a).index(); e.lazy.loadInSlide(s) }); else if (l > 1) for (let o = i; o < i + l; o += 1)d(o) && e.lazy.loadInSlide(o); else e.lazy.loadInSlide(i); if (r.loadPrevNext) if (l > 1 || r.loadPrevNextAmount && r.loadPrevNextAmount > 1) { const t = r.loadPrevNextAmount; const a = l; const n = Math.min(i + a + Math.max(t, a), s.length); const o = Math.max(i - Math.max(a, t), 0); for (let s = i + l; s < n; s += 1)d(s) && e.lazy.loadInSlide(s); for (let s = o; s < i; s += 1)d(s) && e.lazy.loadInSlide(s) } else { const s = t.children(`.${a.slideNextClass}`); s.length > 0 && e.lazy.loadInSlide(c(s)); const i = t.children(`.${a.slidePrevClass}`); i.length > 0 && e.lazy.loadInSlide(c(i)) } } }; const Gt = { name: 'lazy', params: { lazy: { enabled: !1, loadPrevNext: !1, loadPrevNextAmount: 1, loadOnTransitionStart: !1, elementClass: 'swiper-lazy', loadingClass: 'swiper-lazy-loading', loadedClass: 'swiper-lazy-loaded', preloaderClass: 'swiper-lazy-preloader' } }, create () { const e = this; _.extend(e, { lazy: { initialImageLoaded: !1, load: At.load.bind(e), loadInSlide: At.loadInSlide.bind(e) } }) }, on: { beforeInit () { const e = this; e.params.lazy.enabled && e.params.preloadImages && (e.params.preloadImages = !1) }, init () { const e = this; e.params.lazy.enabled && !e.params.loop && e.params.initialSlide === 0 && e.lazy.load() }, scroll () { const e = this; e.params.freeMode && !e.params.freeModeSticky && e.lazy.load() }, resize () { const e = this; e.params.lazy.enabled && e.lazy.load() }, scrollbarDragMove () { const e = this; e.params.lazy.enabled && e.lazy.load() }, transitionStart () { const e = this; e.params.lazy.enabled && (e.params.lazy.loadOnTransitionStart || !e.params.lazy.loadOnTransitionStart && !e.lazy.initialImageLoaded) && e.lazy.load() }, transitionEnd () { const e = this; e.params.lazy.enabled && !e.params.lazy.loadOnTransitionStart && e.lazy.load() }, slideChange () { const e = this; e.params.lazy.enabled && e.params.cssMode && e.lazy.load() } } }; const Bt = { LinearSpline: function (e, t) { const a = (function () { let e, t, a; return (s, i) => { t = -1, e = s.length; while (e - t > 1)a = e + t >> 1, s[a] <= i ? t = a : e = a; return e } }()); let s, i; return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function (e) { return e ? (i = a(this.x, e), s = i - 1, (e - this.x[s]) * (this.y[i] - this.y[s]) / (this.x[i] - this.x[s]) + this.y[s]) : 0 }, this }, getInterpolateFunction (e) { const t = this; t.controller.spline || (t.controller.spline = t.params.loop ? new Bt.LinearSpline(t.slidesGrid, e.slidesGrid) : new Bt.LinearSpline(t.snapGrid, e.snapGrid)) }, setTranslate (e, t) { const a = this; const s = a.controller.control; let i, n; function r (e) { const t = a.rtlTranslate ? -a.translate : a.translate; a.params.controller.by === 'slide' && (a.controller.getInterpolateFunction(e), n = -a.controller.spline.interpolate(-t)), n && a.params.controller.by !== 'container' || (i = (e.maxTranslate() - e.minTranslate()) / (a.maxTranslate() - a.minTranslate()), n = (t - a.minTranslate()) * i + e.minTranslate()), a.params.controller.inverse && (n = e.maxTranslate() - n), e.updateProgress(n), e.setTranslate(n, a), e.updateActiveIndex(), e.updateSlidesClasses() } if (Array.isArray(s)) for (let o = 0; o < s.length; o += 1)s[o] !== t && s[o] instanceof ct && r(s[o]); else s instanceof ct && t !== s && r(s) }, setTransition (e, t) { const a = this; const s = a.controller.control; let i; function n (t) { t.setTransition(e, a), e !== 0 && (t.transitionStart(), t.params.autoHeight && _.nextTick(() => { t.updateAutoHeight() }), t.$wrapperEl.transitionEnd(() => { s && (t.params.loop && a.params.controller.by === 'slide' && t.loopFix(), t.transitionEnd()) })) } if (Array.isArray(s)) for (i = 0; i < s.length; i += 1)s[i] !== t && s[i] instanceof ct && n(s[i]); else s instanceof ct && t !== s && n(s) } }; const Nt = { name: 'controller', params: { controller: { control: void 0, inverse: !1, by: 'slide' } }, create () { const e = this; _.extend(e, { controller: { control: e.params.controller.control, getInterpolateFunction: Bt.getInterpolateFunction.bind(e), setTranslate: Bt.setTranslate.bind(e), setTransition: Bt.setTransition.bind(e) } }) }, on: { update () { const e = this; e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline) }, resize () { const e = this; e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline) }, observerUpdate () { const e = this; e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline) }, setTranslate (e, t) { const a = this; a.controller.control && a.controller.setTranslate(e, t) }, setTransition (e, t) { const a = this; a.controller.control && a.controller.setTransition(e, t) } } }; const Ht = { makeElFocusable (e) { return e.attr('tabIndex', '0'), e }, addElRole (e, t) { return e.attr('role', t), e }, addElLabel (e, t) { return e.attr('aria-label', t), e }, disableEl (e) { return e.attr('aria-disabled', !0), e }, enableEl (e) { return e.attr('aria-disabled', !1), e }, onEnterKey (e) { const t = this; const a = t.params.a11y; if (e.keyCode !== 13) return; const s = o(e.target); t.navigation && t.navigation.$nextEl && s.is(t.navigation.$nextEl) && (t.isEnd && !t.params.loop || t.slideNext(), t.isEnd ? t.a11y.notify(a.lastSlideMessage) : t.a11y.notify(a.nextSlideMessage)), t.navigation && t.navigation.$prevEl && s.is(t.navigation.$prevEl) && (t.isBeginning && !t.params.loop || t.slidePrev(), t.isBeginning ? t.a11y.notify(a.firstSlideMessage) : t.a11y.notify(a.prevSlideMessage)), t.pagination && s.is(`.${t.params.pagination.bulletClass}`) && s[0].click() }, notify (e) { const t = this; const a = t.a11y.liveRegion; a.length !== 0 && (a.html(''), a.html(e)) }, updateNavigation () { const e = this; if (e.params.loop || !e.navigation) return; const { $nextEl: t, $prevEl: a } = e.navigation; a && a.length > 0 && (e.isBeginning ? e.a11y.disableEl(a) : e.a11y.enableEl(a)), t && t.length > 0 && (e.isEnd ? e.a11y.disableEl(t) : e.a11y.enableEl(t)) }, updatePagination () { const e = this; const t = e.params.a11y; e.pagination && e.params.pagination.clickable && e.pagination.bullets && e.pagination.bullets.length && e.pagination.bullets.each((a, s) => { const i = o(s); e.a11y.makeElFocusable(i), e.a11y.addElRole(i, 'button'), e.a11y.addElLabel(i, t.paginationBulletMessage.replace(/{{index}}/, i.index() + 1)) }) }, init () { const e = this; e.$el.append(e.a11y.liveRegion); const t = e.params.a11y; let a, s; e.navigation && e.navigation.$nextEl && (a = e.navigation.$nextEl), e.navigation && e.navigation.$prevEl && (s = e.navigation.$prevEl), a && (e.a11y.makeElFocusable(a), e.a11y.addElRole(a, 'button'), e.a11y.addElLabel(a, t.nextSlideMessage), a.on('keydown', e.a11y.onEnterKey)), s && (e.a11y.makeElFocusable(s), e.a11y.addElRole(s, 'button'), e.a11y.addElLabel(s, t.prevSlideMessage), s.on('keydown', e.a11y.onEnterKey)), e.pagination && e.params.pagination.clickable && e.pagination.bullets && e.pagination.bullets.length && e.pagination.$el.on('keydown', `.${e.params.pagination.bulletClass}`, e.a11y.onEnterKey) }, destroy () { const e = this; let t, a; e.a11y.liveRegion && e.a11y.liveRegion.length > 0 && e.a11y.liveRegion.remove(), e.navigation && e.navigation.$nextEl && (t = e.navigation.$nextEl), e.navigation && e.navigation.$prevEl && (a = e.navigation.$prevEl), t && t.off('keydown', e.a11y.onEnterKey), a && a.off('keydown', e.a11y.onEnterKey), e.pagination && e.params.pagination.clickable && e.pagination.bullets && e.pagination.bullets.length && e.pagination.$el.off('keydown', `.${e.params.pagination.bulletClass}`, e.a11y.onEnterKey) } }; const Xt = { name: 'a11y', params: { a11y: { enabled: !0, notificationClass: 'swiper-notification', prevSlideMessage: 'Previous slide', nextSlideMessage: 'Next slide', firstSlideMessage: 'This is the first slide', lastSlideMessage: 'This is the last slide', paginationBulletMessage: 'Go to slide {{index}}' } }, create () { const e = this; _.extend(e, { a11y: { liveRegion: o(`<span class="${e.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`) } }), Object.keys(Ht).forEach(t => { e.a11y[t] = Ht[t].bind(e) }) }, on: { init () { const e = this; e.params.a11y.enabled && (e.a11y.init(), e.a11y.updateNavigation()) }, toEdge () { const e = this; e.params.a11y.enabled && e.a11y.updateNavigation() }, fromEdge () { const e = this; e.params.a11y.enabled && e.a11y.updateNavigation() }, paginationUpdate () { const e = this; e.params.a11y.enabled && e.a11y.updatePagination() }, destroy () { const e = this; e.params.a11y.enabled && e.a11y.destroy() } } }; const Vt = { init () { const e = this; if (!e.params.history) return; if (!n.history || !n.history.pushState) return e.params.history.enabled = !1, void (e.params.hashNavigation.enabled = !0); const t = e.history; t.initialized = !0, t.paths = Vt.getPathValues(), (t.paths.key || t.paths.value) && (t.scrollToSlide(0, t.paths.value, e.params.runCallbacksOnInit), e.params.history.replaceState || n.addEventListener('popstate', e.history.setHistoryPopState)) }, destroy () { const e = this; e.params.history.replaceState || n.removeEventListener('popstate', e.history.setHistoryPopState) }, setHistoryPopState () { const e = this; e.history.paths = Vt.getPathValues(), e.history.scrollToSlide(e.params.speed, e.history.paths.value, !1) }, getPathValues () { const e = n.location.pathname.slice(1).split('/').filter(e => e !== ''); const t = e.length; const a = e[t - 2]; const s = e[t - 1]; return { key: a, value: s } }, setHistory (e, t) { const a = this; if (!a.history.initialized || !a.params.history.enabled) return; const s = a.slides.eq(t); let i = Vt.slugify(s.attr('data-history')); n.location.pathname.includes(e) || (i = `${e}/${i}`); const r = n.history.state; r && r.value === i || (a.params.history.replaceState ? n.history.replaceState({ value: i }, null, i) : n.history.pushState({ value: i }, null, i)) }, slugify (e) { return e.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '') }, scrollToSlide (e, t, a) { const s = this; if (t) for (let i = 0, n = s.slides.length; i < n; i += 1) { const n = s.slides.eq(i); const r = Vt.slugify(n.attr('data-history')); if (r === t && !n.hasClass(s.params.slideDuplicateClass)) { const t = n.index(); s.slideTo(t, e, a) } } else s.slideTo(0, e, a) } }; const Yt = { name: 'history', params: { history: { enabled: !1, replaceState: !1, key: 'slides' } }, create () { const e = this; _.extend(e, { history: { init: Vt.init.bind(e), setHistory: Vt.setHistory.bind(e), setHistoryPopState: Vt.setHistoryPopState.bind(e), scrollToSlide: Vt.scrollToSlide.bind(e), destroy: Vt.destroy.bind(e) } }) }, on: { init () { const e = this; e.params.history.enabled && e.history.init() }, destroy () { const e = this; e.params.history.enabled && e.history.destroy() }, transitionEnd () { const e = this; e.history.initialized && e.history.setHistory(e.params.history.key, e.activeIndex) }, slideChange () { const e = this; e.history.initialized && e.params.cssMode && e.history.setHistory(e.params.history.key, e.activeIndex) } } }; const Rt = { onHashCange () { const e = this; const t = i.location.hash.replace('#', ''); const a = e.slides.eq(e.activeIndex).attr('data-hash'); if (t !== a) { const a = e.$wrapperEl.children(`.${e.params.slideClass}[data-hash="${t}"]`).index(); if (typeof a === 'undefined') return; e.slideTo(a) } }, setHash () { const e = this; if (e.hashNavigation.initialized && e.params.hashNavigation.enabled) if (e.params.hashNavigation.replaceState && n.history && n.history.replaceState)n.history.replaceState(null, null, `#${e.slides.eq(e.activeIndex).attr('data-hash')}` || ''); else { const t = e.slides.eq(e.activeIndex); const a = t.attr('data-hash') || t.attr('data-history'); i.location.hash = a || '' } }, init () { const e = this; if (!e.params.hashNavigation.enabled || e.params.history && e.params.history.enabled) return; e.hashNavigation.initialized = !0; const t = i.location.hash.replace('#', ''); if (t) { const a = 0; for (let s = 0, i = e.slides.length; s < i; s += 1) { const i = e.slides.eq(s); const n = i.attr('data-hash') || i.attr('data-history'); if (n === t && !i.hasClass(e.params.slideDuplicateClass)) { const t = i.index(); e.slideTo(t, a, e.params.runCallbacksOnInit, !0) } } }e.params.hashNavigation.watchState && o(n).on('hashchange', e.hashNavigation.onHashCange) }, destroy () { const e = this; e.params.hashNavigation.watchState && o(n).off('hashchange', e.hashNavigation.onHashCange) } }; const Ft = { name: 'hash-navigation', params: { hashNavigation: { enabled: !1, replaceState: !1, watchState: !1 } }, create () { const e = this; _.extend(e, { hashNavigation: { initialized: !1, init: Rt.init.bind(e), destroy: Rt.destroy.bind(e), setHash: Rt.setHash.bind(e), onHashCange: Rt.onHashCange.bind(e) } }) }, on: { init () { const e = this; e.params.hashNavigation.enabled && e.hashNavigation.init() }, destroy () { const e = this; e.params.hashNavigation.enabled && e.hashNavigation.destroy() }, transitionEnd () { const e = this; e.hashNavigation.initialized && e.hashNavigation.setHash() }, slideChange () { const e = this; e.hashNavigation.initialized && e.params.cssMode && e.hashNavigation.setHash() } } }; const Wt = { run () { const e = this; const t = e.slides.eq(e.activeIndex); let a = e.params.autoplay.delay; t.attr('data-swiper-autoplay') && (a = t.attr('data-swiper-autoplay') || e.params.autoplay.delay), clearTimeout(e.autoplay.timeout), e.autoplay.timeout = _.nextTick(() => { e.params.autoplay.reverseDirection ? e.params.loop ? (e.loopFix(), e.slidePrev(e.params.speed, !0, !0), e.emit('autoplay')) : e.isBeginning ? e.params.autoplay.stopOnLastSlide ? e.autoplay.stop() : (e.slideTo(e.slides.length - 1, e.params.speed, !0, !0), e.emit('autoplay')) : (e.slidePrev(e.params.speed, !0, !0), e.emit('autoplay')) : e.params.loop ? (e.loopFix(), e.slideNext(e.params.speed, !0, !0), e.emit('autoplay')) : e.isEnd ? e.params.autoplay.stopOnLastSlide ? e.autoplay.stop() : (e.slideTo(0, e.params.speed, !0, !0), e.emit('autoplay')) : (e.slideNext(e.params.speed, !0, !0), e.emit('autoplay')), e.params.cssMode && e.autoplay.running && e.autoplay.run() }, a) }, start () { const e = this; return typeof e.autoplay.timeout === 'undefined' && (!e.autoplay.running && (e.autoplay.running = !0, e.emit('autoplayStart'), e.autoplay.run(), !0)) }, stop () { const e = this; return !!e.autoplay.running && (typeof e.autoplay.timeout !== 'undefined' && (e.autoplay.timeout && (clearTimeout(e.autoplay.timeout), e.autoplay.timeout = void 0), e.autoplay.running = !1, e.emit('autoplayStop'), !0)) }, pause (e) { const t = this; t.autoplay.running && (t.autoplay.paused || (t.autoplay.timeout && clearTimeout(t.autoplay.timeout), t.autoplay.paused = !0, e !== 0 && t.params.autoplay.waitForTransition ? (t.$wrapperEl[0].addEventListener('transitionend', t.autoplay.onTransitionEnd), t.$wrapperEl[0].addEventListener('webkitTransitionEnd', t.autoplay.onTransitionEnd)) : (t.autoplay.paused = !1, t.autoplay.run()))) } }; const jt = { name: 'autoplay', params: { autoplay: { enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !0, stopOnLastSlide: !1, reverseDirection: !1 } }, create () { const e = this; _.extend(e, { autoplay: { running: !1, paused: !1, run: Wt.run.bind(e), start: Wt.start.bind(e), stop: Wt.stop.bind(e), pause: Wt.pause.bind(e), onVisibilityChange () { document.visibilityState === 'hidden' && e.autoplay.running && e.autoplay.pause(), document.visibilityState === 'visible' && e.autoplay.paused && (e.autoplay.run(), e.autoplay.paused = !1) }, onTransitionEnd (t) { e && !e.destroyed && e.$wrapperEl && t.target === this && (e.$wrapperEl[0].removeEventListener('transitionend', e.autoplay.onTransitionEnd), e.$wrapperEl[0].removeEventListener('webkitTransitionEnd', e.autoplay.onTransitionEnd), e.autoplay.paused = !1, e.autoplay.running ? e.autoplay.run() : e.autoplay.stop()) } } }) }, on: { init () { const e = this; e.params.autoplay.enabled && (e.autoplay.start(), document.addEventListener('visibilitychange', e.autoplay.onVisibilityChange)) }, beforeTransitionStart (e, t) { const a = this; a.autoplay.running && (t || !a.params.autoplay.disableOnInteraction ? a.autoplay.pause(e) : a.autoplay.stop()) }, sliderFirstMove () { const e = this; e.autoplay.running && (e.params.autoplay.disableOnInteraction ? e.autoplay.stop() : e.autoplay.pause()) }, touchEnd () { const e = this; e.params.cssMode && e.autoplay.paused && !e.params.autoplay.disableOnInteraction && e.autoplay.run() }, destroy () { const e = this; e.autoplay.running && e.autoplay.stop(), document.removeEventListener('visibilitychange', e.autoplay.onVisibilityChange) } } }; const qt = { setTranslate () { const e = this; const { slides: t } = e; for (let a = 0; a < t.length; a += 1) { const t = e.slides.eq(a); const s = t[0].swiperSlideOffset; let i = -s; e.params.virtualTranslate || (i -= e.translate); let n = 0; e.isHorizontal() || (n = i, i = 0); const r = e.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(t[0].progress), 0) : 1 + Math.min(Math.max(t[0].progress, -1), 0); t.css({ opacity: r }).transform(`translate3d(${i}px, ${n}px, 0px)`) } }, setTransition (e) { const t = this; const { slides: a, $wrapperEl: s } = t; if (a.transition(e), t.params.virtualTranslate && e !== 0) { let e = !1; a.transitionEnd(() => { if (e) return; if (!t || t.destroyed) return; e = !0, t.animating = !1; const a = ['webkitTransitionEnd', 'transitionend']; for (let e = 0; e < a.length; e += 1)s.trigger(a[e]) }) } } }; const _t = { name: 'effect-fade', params: { fadeEffect: { crossFade: !1 } }, create () { const e = this; _.extend(e, { fadeEffect: { setTranslate: qt.setTranslate.bind(e), setTransition: qt.setTransition.bind(e) } }) }, on: { beforeInit () { const e = this; if (e.params.effect !== 'fade') return; e.classNames.push(`${e.params.containerModifierClass}fade`); const t = { slidesPerView: 1, slidesPerColumn: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !0 }; _.extend(e.params, t), _.extend(e.originalParams, t) }, setTranslate () { const e = this; e.params.effect === 'fade' && e.fadeEffect.setTranslate() }, setTransition (e) { const t = this; t.params.effect === 'fade' && t.fadeEffect.setTransition(e) } } }; const Ut = { setTranslate () { const e = this; const { $el: t, $wrapperEl: a, slides: s, width: i, height: n, rtlTranslate: r, size: l } = e; const d = e.params.cubeEffect; const c = e.isHorizontal(); const p = e.virtual && e.params.virtual.enabled; let u; let h = 0; d.shadow && (c ? (u = a.find('.swiper-cube-shadow'), u.length === 0 && (u = o('<div class="swiper-cube-shadow"></div>'), a.append(u)), u.css({ height: `${i}px` })) : (u = t.find('.swiper-cube-shadow'), u.length === 0 && (u = o('<div class="swiper-cube-shadow"></div>'), t.append(u)))); for (let m = 0; m < s.length; m += 1) { const e = s.eq(m); let t = m; p && (t = parseInt(e.attr('data-swiper-slide-index'), 10)); let a = 90 * t; let i = Math.floor(a / 360); r && (a = -a, i = Math.floor(-a / 360)); const n = Math.max(Math.min(e[0].progress, 1), -1); let u = 0; let f = 0; let v = 0; t % 4 === 0 ? (u = 4 * -i * l, v = 0) : (t - 1) % 4 === 0 ? (u = 0, v = 4 * -i * l) : (t - 2) % 4 === 0 ? (u = l + 4 * i * l, v = l) : (t - 3) % 4 === 0 && (u = -l, v = 3 * l + 4 * l * i), r && (u = -u), c || (f = u, u = 0); const g = `rotateX(${c ? 0 : -a}deg) rotateY(${c ? a : 0}deg) translate3d(${u}px, ${f}px, ${v}px)`; if (n <= 1 && n > -1 && (h = 90 * t + 90 * n, r && (h = 90 * -t - 90 * n)), e.transform(g), d.slideShadows) { let t = c ? e.find('.swiper-slide-shadow-left') : e.find('.swiper-slide-shadow-top'); let a = c ? e.find('.swiper-slide-shadow-right') : e.find('.swiper-slide-shadow-bottom'); t.length === 0 && (t = o(`<div class="swiper-slide-shadow-${c ? 'left' : 'top'}"></div>`), e.append(t)), a.length === 0 && (a = o(`<div class="swiper-slide-shadow-${c ? 'right' : 'bottom'}"></div>`), e.append(a)), t.length && (t[0].style.opacity = Math.max(-n, 0)), a.length && (a[0].style.opacity = Math.max(n, 0)) } } if (a.css({ '-webkit-transform-origin': `50% 50% -${l / 2}px`, '-moz-transform-origin': `50% 50% -${l / 2}px`, '-ms-transform-origin': `50% 50% -${l / 2}px`, 'transform-origin': `50% 50% -${l / 2}px` }), d.shadow) if (c)u.transform(`translate3d(0px, ${i / 2 + d.shadowOffset}px, ${-i / 2}px) rotateX(90deg) rotateZ(0deg) scale(${d.shadowScale})`); else { const e = Math.abs(h) - 90 * Math.floor(Math.abs(h) / 90); const t = 1.5 - (Math.sin(2 * e * Math.PI / 360) / 2 + Math.cos(2 * e * Math.PI / 360) / 2); const a = d.shadowScale; const s = d.shadowScale / t; const i = d.shadowOffset; u.transform(`scale3d(${a}, 1, ${s}) translate3d(0px, ${n / 2 + i}px, ${-n / 2 / s}px) rotateX(-90deg)`) } const f = ht.isSafari || ht.isUiWebView ? -l / 2 : 0; a.transform(`translate3d(0px,0,${f}px) rotateX(${e.isHorizontal() ? 0 : h}deg) rotateY(${e.isHorizontal() ? -h : 0}deg)`) }, setTransition (e) { const t = this; const { $el: a, slides: s } = t; s.transition(e).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(e), t.params.cubeEffect.shadow && !t.isHorizontal() && a.find('.swiper-cube-shadow').transition(e) } }; const Kt = { name: 'effect-cube', params: { cubeEffect: { slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: 0.94 } }, create () { const e = this; _.extend(e, { cubeEffect: { setTranslate: Ut.setTranslate.bind(e), setTransition: Ut.setTransition.bind(e) } }) }, on: { beforeInit () { const e = this; if (e.params.effect !== 'cube') return; e.classNames.push(`${e.params.containerModifierClass}cube`), e.classNames.push(`${e.params.containerModifierClass}3d`); const t = { slidesPerView: 1, slidesPerColumn: 1, slidesPerGroup: 1, watchSlidesProgress: !0, resistanceRatio: 0, spaceBetween: 0, centeredSlides: !1, virtualTranslate: !0 }; _.extend(e.params, t), _.extend(e.originalParams, t) }, setTranslate () { const e = this; e.params.effect === 'cube' && e.cubeEffect.setTranslate() }, setTransition (e) { const t = this; t.params.effect === 'cube' && t.cubeEffect.setTransition(e) } } }; const Zt = { setTranslate () { const e = this; const { slides: t, rtlTranslate: a } = e; for (let s = 0; s < t.length; s += 1) { const i = t.eq(s); let n = i[0].progress; e.params.flipEffect.limitRotation && (n = Math.max(Math.min(i[0].progress, 1), -1)); const r = i[0].swiperSlideOffset; const l = -180 * n; let d = l; let c = 0; let p = -r; let u = 0; if (e.isHorizontal() ? a && (d = -d) : (u = p, p = 0, c = -d, d = 0), i[0].style.zIndex = -Math.abs(Math.round(n)) + t.length, e.params.flipEffect.slideShadows) { let t = e.isHorizontal() ? i.find('.swiper-slide-shadow-left') : i.find('.swiper-slide-shadow-top'); let a = e.isHorizontal() ? i.find('.swiper-slide-shadow-right') : i.find('.swiper-slide-shadow-bottom'); t.length === 0 && (t = o(`<div class="swiper-slide-shadow-${e.isHorizontal() ? 'left' : 'top'}"></div>`), i.append(t)), a.length === 0 && (a = o(`<div class="swiper-slide-shadow-${e.isHorizontal() ? 'right' : 'bottom'}"></div>`), i.append(a)), t.length && (t[0].style.opacity = Math.max(-n, 0)), a.length && (a[0].style.opacity = Math.max(n, 0)) }i.transform(`translate3d(${p}px, ${u}px, 0px) rotateX(${c}deg) rotateY(${d}deg)`) } }, setTransition (e) { const t = this; const { slides: a, activeIndex: s, $wrapperEl: i } = t; if (a.transition(e).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(e), t.params.virtualTranslate && e !== 0) { let e = !1; a.eq(s).transitionEnd(function () { if (e) return; if (!t || t.destroyed) return; e = !0, t.animating = !1; const a = ['webkitTransitionEnd', 'transitionend']; for (let e = 0; e < a.length; e += 1)i.trigger(a[e]) }) } } }; const Qt = { name: 'effect-flip', params: { flipEffect: { slideShadows: !0, limitRotation: !0 } }, create () { const e = this; _.extend(e, { flipEffect: { setTranslate: Zt.setTranslate.bind(e), setTransition: Zt.setTransition.bind(e) } }) }, on: { beforeInit () { const e = this; if (e.params.effect !== 'flip') return; e.classNames.push(`${e.params.containerModifierClass}flip`), e.classNames.push(`${e.params.containerModifierClass}3d`); const t = { slidesPerView: 1, slidesPerColumn: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !0 }; _.extend(e.params, t), _.extend(e.originalParams, t) }, setTranslate () { const e = this; e.params.effect === 'flip' && e.flipEffect.setTranslate() }, setTransition (e) { const t = this; t.params.effect === 'flip' && t.flipEffect.setTransition(e) } } }; const Jt = { setTranslate () { const e = this; const { width: t, height: a, slides: s, $wrapperEl: i, slidesSizesGrid: n } = e; const r = e.params.coverflowEffect; const l = e.isHorizontal(); const d = e.translate; const c = l ? t / 2 - d : a / 2 - d; const p = l ? r.rotate : -r.rotate; const u = r.depth; for (let h = 0, f = s.length; h < f; h += 1) { const e = s.eq(h); const t = n[h]; const a = e[0].swiperSlideOffset; const i = (c - a - t / 2) / t * r.modifier; let d = l ? p * i : 0; let f = l ? 0 : p * i; let m = -u * Math.abs(i); let v = l ? 0 : r.stretch * i; let g = l ? r.stretch * i : 0; Math.abs(g) < 0.001 && (g = 0), Math.abs(v) < 0.001 && (v = 0), Math.abs(m) < 0.001 && (m = 0), Math.abs(d) < 0.001 && (d = 0), Math.abs(f) < 0.001 && (f = 0); const b = `translate3d(${g}px,${v}px,${m}px)  rotateX(${f}deg) rotateY(${d}deg)`; if (e.transform(b), e[0].style.zIndex = 1 - Math.abs(Math.round(i)), r.slideShadows) { let t = l ? e.find('.swiper-slide-shadow-left') : e.find('.swiper-slide-shadow-top'); let a = l ? e.find('.swiper-slide-shadow-right') : e.find('.swiper-slide-shadow-bottom'); t.length === 0 && (t = o(`<div class="swiper-slide-shadow-${l ? 'left' : 'top'}"></div>`), e.append(t)), a.length === 0 && (a = o(`<div class="swiper-slide-shadow-${l ? 'right' : 'bottom'}"></div>`), e.append(a)), t.length && (t[0].style.opacity = i > 0 ? i : 0), a.length && (a[0].style.opacity = -i > 0 ? -i : 0) } } if (U.pointerEvents || U.prefixedPointerEvents) { const e = i[0].style; e.perspectiveOrigin = `${c}px 50%` } }, setTransition (e) { const t = this; t.slides.transition(e).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(e) } }; const ea = { name: 'effect-coverflow', params: { coverflowEffect: { rotate: 50, stretch: 0, depth: 100, modifier: 1, slideShadows: !0 } }, create () { const e = this; _.extend(e, { coverflowEffect: { setTranslate: Jt.setTranslate.bind(e), setTransition: Jt.setTransition.bind(e) } }) }, on: { beforeInit () { const e = this; e.params.effect === 'coverflow' && (e.classNames.push(`${e.params.containerModifierClass}coverflow`), e.classNames.push(`${e.params.containerModifierClass}3d`), e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0) }, setTranslate () { const e = this; e.params.effect === 'coverflow' && e.coverflowEffect.setTranslate() }, setTransition (e) { const t = this; t.params.effect === 'coverflow' && t.coverflowEffect.setTransition(e) } } }; const ta = { init () { const e = this; const { thumbs: t } = e.params; const a = e.constructor; t.swiper instanceof a ? (e.thumbs.swiper = t.swiper, _.extend(e.thumbs.swiper.originalParams, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), _.extend(e.thumbs.swiper.params, { watchSlidesProgress: !0, slideToClickedSlide: !1 })) : _.isObject(t.swiper) && (e.thumbs.swiper = new a(_.extend({}, t.swiper, { watchSlidesVisibility: !0, watchSlidesProgress: !0, slideToClickedSlide: !1 })), e.thumbs.swiperCreated = !0), e.thumbs.swiper.$el.addClass(e.params.thumbs.thumbsContainerClass), e.thumbs.swiper.on('tap', e.thumbs.onThumbClick) }, onThumbClick () { const e = this; const t = e.thumbs.swiper; if (!t) return; const a = t.clickedIndex; const s = t.clickedSlide; if (s && o(s).hasClass(e.params.thumbs.slideThumbActiveClass)) return; if (typeof a === 'undefined' || a === null) return; let i; if (i = t.params.loop ? parseInt(o(t.clickedSlide).attr('data-swiper-slide-index'), 10) : a, e.params.loop) { let t = e.activeIndex; e.slides.eq(t).hasClass(e.params.slideDuplicateClass) && (e.loopFix(), e._clientLeft = e.$wrapperEl[0].clientLeft, t = e.activeIndex); const a = e.slides.eq(t).prevAll(`[data-swiper-slide-index="${i}"]`).eq(0).index(); const s = e.slides.eq(t).nextAll(`[data-swiper-slide-index="${i}"]`).eq(0).index(); i = typeof a === 'undefined' ? s : typeof s === 'undefined' ? a : s - t < t - a ? s : a }e.slideTo(i) }, update (e) { const t = this; const a = t.thumbs.swiper; if (!a) return; const s = a.params.slidesPerView === 'auto' ? a.slidesPerViewDynamic() : a.params.slidesPerView; if (t.realIndex !== a.realIndex) { let i; let n = a.activeIndex; if (a.params.loop) { a.slides.eq(n).hasClass(a.params.slideDuplicateClass) && (a.loopFix(), a._clientLeft = a.$wrapperEl[0].clientLeft, n = a.activeIndex); const e = a.slides.eq(n).prevAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index(); const s = a.slides.eq(n).nextAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index(); i = typeof e === 'undefined' ? s : typeof s === 'undefined' ? e : s - n === n - e ? n : s - n < n - e ? s : e } else i = t.realIndex; a.visibleSlidesIndexes && a.visibleSlidesIndexes.indexOf(i) < 0 && (a.params.centeredSlides ? i = i > n ? i - Math.floor(s / 2) + 1 : i + Math.floor(s / 2) - 1 : i > n && (i = i - s + 1), a.slideTo(i, e ? 0 : void 0)) } let i = 1; const n = t.params.thumbs.slideThumbActiveClass; if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (i = t.params.slidesPerView), t.params.thumbs.multipleActiveThumbs || (i = 1), i = Math.floor(i), a.slides.removeClass(n), a.params.loop || a.params.virtual && a.params.virtual.enabled) for (let r = 0; r < i; r += 1)a.$wrapperEl.children(`[data-swiper-slide-index="${t.realIndex + r}"]`).addClass(n); else for (let r = 0; r < i; r += 1)a.slides.eq(t.realIndex + r).addClass(n) } }; const aa = { name: 'thumbs', params: { thumbs: { multipleActiveThumbs: !0, swiper: null, slideThumbActiveClass: 'swiper-slide-thumb-active', thumbsContainerClass: 'swiper-container-thumbs' } }, create () { const e = this; _.extend(e, { thumbs: { swiper: null, init: ta.init.bind(e), update: ta.update.bind(e), onThumbClick: ta.onThumbClick.bind(e) } }) }, on: { beforeInit () { const e = this; const { thumbs: t } = e.params; t && t.swiper && (e.thumbs.init(), e.thumbs.update(!0)) }, slideChange () { const e = this; e.thumbs.swiper && e.thumbs.update() }, update () { const e = this; e.thumbs.swiper && e.thumbs.update() }, resize () { const e = this; e.thumbs.swiper && e.thumbs.update() }, observerUpdate () { const e = this; e.thumbs.swiper && e.thumbs.update() }, setTransition (e) { const t = this; const a = t.thumbs.swiper; a && a.setTransition(e) }, beforeDestroy () { const e = this; const t = e.thumbs.swiper; t && e.thumbs.swiperCreated && t && t.destroy() } } }; const sa = [pt, ut, ft, mt, gt, wt, xt, St, Mt, Pt, zt, It, Dt, Gt, Nt, Xt, Yt, Ft, jt, _t, Kt, Qt, ea, aa]; typeof ct.use === 'undefined' && (ct.use = ct.Class.use, ct.installModule = ct.Class.installModule), ct.use(sa); const ia = ct; const na = function () { const e = this; const t = e.$createElement; const a = e._self._c || t; return a('div', { class: e.slideClass }, [e._t('default')], 2) }; const ra = []; const oa = { name: 'swiper-slide', data: function () { return { slideClass: 'swiper-slide' } }, ready: function () { this.update() }, mounted: function () { this.update(), this.$parent && this.$parent.options && this.$parent.options.slideClass && (this.slideClass = this.$parent.options.slideClass) }, updated: function () { this.update() }, attached: function () { this.update() }, methods: { update: function () { this.$parent && this.$parent.swiper && this.$parent.update() } } }; const la = oa; function da (e, t, a, s, i, n, r, o) { let l; const d = typeof e === 'function' ? e.options : e; if (t && (d.render = t, d.staticRenderFns = a, d._compiled = !0), s && (d.functional = !0), n && (d._scopeId = 'data-v-' + n), r ? (l = function (e) { e = e || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext, e || typeof __VUE_SSR_CONTEXT__ === 'undefined' || (e = __VUE_SSR_CONTEXT__), i && i.call(this, e), e && e._registeredComponents && e._registeredComponents.add(r) }, d._ssrRegister = l) : i && (l = o ? function () { i.call(this, this.$root.$options.shadowRoot) } : i), l) if (d.functional) { d._injectStyles = l; const c = d.render; d.render = function (e, t) { return l.call(t), c(e, t) } } else { const p = d.beforeCreate; d.beforeCreate = p ? [].concat(p, l) : [l] } return { exports: e, options: d } } const ca = da(la, na, ra, !1, null, null, null); const pa = ca.exports; const ua = function () { const e = this; const t = e.$createElement; const a = e._self._c || t; return a('div', { staticClass: 'swiper-container' }, [e._t('parallax-bg'), a('div', { class: e.classes.wrapperClass }, [e._t('default')], 2), e._t('pagination'), e._t('button-prev'), e._t('button-next'), e._t('scrollbar')], 2) }; const ha = []; const fa = (a('99af'), a('4160'), a('cca6'), a('ac1f'), a('5319'), a('02a3')); const ma = a.n(fa); const va = window.Swiper || ma.a; const ga = ['beforeDestroy', 'slideChange', 'slideChangeTransitionStart', 'slideChangeTransitionEnd', 'slideNextTransitionStart', 'slideNextTransitionEnd', 'slidePrevTransitionStart', 'slidePrevTransitionEnd', 'transitionStart', 'transitionEnd', 'touchStart', 'touchMove', 'touchMoveOpposite', 'sliderMove', 'touchEnd', 'click', 'tap', 'doubleTap', 'imagesReady', 'progress', 'reachBeginning', 'reachEnd', 'fromEdge', 'setTranslate', 'setTransition', 'resize']; const ba = { name: 'swiper', props: { options: { type: Object, default: function () { return {} } }, globalOptions: { type: Object, required: !1, default: function () { return {} } } }, data: function () { return { swiper: null, classes: { wrapperClass: 'swiper-wrapper' } } }, ready: function () { this.swiper || this.mountInstance() }, mounted: function () { if (!this.swiper) { let e = !1; for (const t in this.classes) this.classes.hasOwnProperty(t) && this.options[t] && (e = !0, this.classes[t] = this.options[t]); e ? this.$nextTick(this.mountInstance) : this.mountInstance() } }, activated: function () { this.update() }, updated: function () { this.update() }, beforeDestroy: function () { this.$nextTick(function () { this.swiper && (this.swiper.destroy && this.swiper.destroy(), delete this.swiper) }) }, methods: { update: function () { this.swiper && (this.swiper.update && this.swiper.update(), this.swiper.navigation && this.swiper.navigation.update(), this.swiper.pagination && this.swiper.pagination.render(), this.swiper.pagination && this.swiper.pagination.update()) }, mountInstance: function () { const e = Object.assign({}, this.globalOptions, this.options); this.swiper = new va(this.$el, e), this.bindEvents(), this.$emit('ready', this.swiper) }, bindEvents: function () { const e = this; ga.forEach(function (t) { e.swiper.on(t, function () { for (var e = arguments.length, a = new Array(e), s = 0; s < e; s++)a[s] = arguments[s]; this.$emit.apply(this, [t].concat(a)), this.$emit.apply(this, [t.replace(/([A-Z])/g, '-$1').toLowerCase()].concat(a)) }) }) } } }; const wa = ba; const ya = da(wa, ua, ha, !1, null, null, null); const xa = ya.exports; const Ea = ia; const Ta = xa; const Sa = pa; const Ca = function (e, t) { e.component(xa.name, xa), e.component(pa.name, pa) }; const Ma = { Swiper: Ea, swiper: Ta, swiperSlide: Sa, install: Ca }; const $a = Ma; a.d(t, 'Swiper', function () { return Ea }), a.d(t, 'swiper', function () { return Ta }), a.d(t, 'swiperSlide', function () { return Sa }), a.d(t, 'install', function () { return Ca }); t.default = $a }, fc6a: function (e, t, a) { const s = a('44ad'); const i = a('1d80'); e.exports = function (e) { return s(i(e)) } }, fdbf: function (e, t, a) { const s = a('4930'); e.exports = s && !Symbol.sham && typeof Symbol.iterator === 'symbol' } })) })
// # sourceMappingURL=vue-awesome-swiper.umd.min.js.map
